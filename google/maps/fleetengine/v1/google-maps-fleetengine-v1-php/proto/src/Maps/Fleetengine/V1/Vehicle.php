<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/maps/fleetengine/v1/vehicles.proto

namespace Maps\Fleetengine\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Vehicle metadata.
 *
 * Generated from protobuf message <code>maps.fleetengine.v1.Vehicle</code>
 */
class Vehicle extends \Google\Protobuf\Internal\Message
{
    /**
     * The unique name for this vehicle.
     * The format is providers/{provider}/vehicles/{vehicle}
     *
     * Generated from protobuf field <code>string name = 1;</code>
     */
    protected $name = '';
    /**
     * The vehicle state.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.VehicleState vehicle_state = 2;</code>
     */
    protected $vehicle_state = 0;
    /**
     * Supported trip types.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TripType supported_trip_types = 3;</code>
     */
    private $supported_trip_types;
    /**
     * List of IDs for trips in progress.
     *
     * Generated from protobuf field <code>repeated string current_trips = 4;</code>
     */
    private $current_trips;
    /**
     * Last reported location of the vehicle.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.VehicleLocation last_location = 5;</code>
     */
    protected $last_location = null;
    /**
     * Maximum capacity of the vehicle.  This is the total numbers of riders
     * on trips this vehicle can contain.  The driver is not considered in
     * this value.  This value must be greater than or equal to one.
     *
     * Generated from protobuf field <code>int32 maximum_capacity = 6;</code>
     */
    protected $maximum_capacity = 0;
    /**
     * The current available capacity of the vehicle.  This is the
     * maximum_capacity minus the current number of riders.
     *
     * Generated from protobuf field <code>int32 available_capacity = 7;</code>
     */
    protected $available_capacity = 0;
    /**
     * List of vehicle service attributes.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.VehicleAttribute attributes = 8;</code>
     */
    private $attributes;
    /**
     * The type of this Vehicle.  Can be filtered during SearchVehicles.  Also
     * influences ETA and route calculations.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.Vehicle.VehicleType vehicle_type = 9;</code>
     */
    protected $vehicle_type = null;
    /**
     * License plate information for the vehicle.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.LicensePlate license_plate = 10;</code>
     */
    protected $license_plate = null;
    /**
     * Deprecated. Use vehicle.waypoint instead.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TerminalLocation route = 12 [deprecated = true];</code>
     * @deprecated
     */
    private $route;
    /**
     * The polyline specifying the route the driver app intends to take to
     * the next waypoint. Your driver app updates this every time a waypoint is
     * passed or the driver reroutes. This list is also returned in
     * Trip.current_route_segment for all active trips assigned to the vehicle.
     * Note: This field is intended only for use by the Driver SDK.
     *
     * Generated from protobuf field <code>string current_route_segment = 20;</code>
     */
    protected $current_route_segment = '';
    /**
     * Time when current_route_segment was set. This field is ignored in
     * UpdateVehicleRequests as it is calculated by the server. It should be
     * stored by client and passed in to future requests to prevent returning
     * routes to first way point that haven't changed.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp current_route_segment_version = 15;</code>
     */
    protected $current_route_segment_version = null;
    /**
     * The waypoint where current_route_segment ends. This can be supplied by
     * drivers on UpdateVehicle calls either as a full trip waypoint, a waypoint
     * latlnt, or as a the last latlng of the current_route_segment. FleetEngine
     * will then do its best to interpolate to an actual waypoint if it is not
     * fully specified. This field is ignored in UpdateVehicle calls unless
     * current_route_segment is also specified.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.TripWaypoint current_route_segment_end_point = 24;</code>
     */
    protected $current_route_segment_end_point = null;
    /**
     * The remaining driving distance for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * This field is also returned in Trip.remaining_distance_meters for all
     * active trips assigned to the vehicle. The value is unspecified if the
     * `Vehicle.current_route_segment` field is empty, or if the Driver app has
     * not updated its value.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_distance_meters = 18;</code>
     */
    protected $remaining_distance_meters = null;
    /**
     * The ETA to the next waypoint that is the first entry in Vehicle.waypoint
     * field. This field facilitates journey sharing between a Driver app and a
     * Consumer app and is updated by the Driver SDK, and Fleet Engine does not
     * update it. This field is also returned in Trip.eta_to_first_waypoint for
     * all active trips assigned to the vehicle. The value is unspecified if the
     * Vehicle.waypoint field is empty, or the Driver app has not updated its
     * value.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp eta_to_first_waypoint = 19;</code>
     */
    protected $eta_to_first_waypoint = null;
    /**
     * The remaining driving time for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * The value is unspecified if the `Vehicle.current_route_segment` field is
     * empty, or if the Driver app has not updated its value. This value should
     * match eta_to_first_waypoint - current_time if all parties are using the
     * same clock. This field is currently write-only and will not yet be
     * populated in Vehicle's get/update/search operations. When updating a
     * vehicle, if you update both eta_to_first_waypoint and
     * remaining_time_seconds in the same request, then only
     * remaining_time_seconds is considered.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_time_seconds = 25;</code>
     */
    protected $remaining_time_seconds = null;
    /**
     * The remaining set of waypoints assigned to this Vehicle.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TripWaypoint waypoints = 22;</code>
     */
    private $waypoints;
    /**
     * Last time the waypoints was updated. Client should cache
     * this value and pass it in GetVehicleRequest to ensure the
     * waypoints.path_to_waypoint is only returned if it is updated
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp waypoints_version = 16;</code>
     */
    protected $waypoints_version = null;
    /**
     * Indicates if the driver accepts back-to-back rides. If
     * `true`, services include the vehicle for back-to-back matches.
     * If `false`, services exclude the vehicle from back-to-back matches.
     * Default value is `false`.
     *
     * Generated from protobuf field <code>bool back_to_back_enabled = 23;</code>
     */
    protected $back_to_back_enabled = false;
    /**
     * Vehicle's navigation status.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.NavigationStatus navigation_status = 26;</code>
     */
    protected $navigation_status = 0;
    /**
     * Information about various device settings. This is internal debug only
     * field, not included in the response.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.DeviceSettings device_settings = 27;</code>
     */
    protected $device_settings = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $name
     *           The unique name for this vehicle.
     *           The format is providers/{provider}/vehicles/{vehicle}
     *     @type int $vehicle_state
     *           The vehicle state.
     *     @type int[]|\Google\Protobuf\Internal\RepeatedField $supported_trip_types
     *           Supported trip types.
     *     @type string[]|\Google\Protobuf\Internal\RepeatedField $current_trips
     *           List of IDs for trips in progress.
     *     @type \Maps\Fleetengine\V1\VehicleLocation $last_location
     *           Last reported location of the vehicle.
     *     @type int $maximum_capacity
     *           Maximum capacity of the vehicle.  This is the total numbers of riders
     *           on trips this vehicle can contain.  The driver is not considered in
     *           this value.  This value must be greater than or equal to one.
     *     @type int $available_capacity
     *           The current available capacity of the vehicle.  This is the
     *           maximum_capacity minus the current number of riders.
     *     @type \Maps\Fleetengine\V1\VehicleAttribute[]|\Google\Protobuf\Internal\RepeatedField $attributes
     *           List of vehicle service attributes.
     *     @type \Maps\Fleetengine\V1\Vehicle\VehicleType $vehicle_type
     *           The type of this Vehicle.  Can be filtered during SearchVehicles.  Also
     *           influences ETA and route calculations.
     *     @type \Maps\Fleetengine\V1\LicensePlate $license_plate
     *           License plate information for the vehicle.
     *     @type \Maps\Fleetengine\V1\TerminalLocation[]|\Google\Protobuf\Internal\RepeatedField $route
     *           Deprecated. Use vehicle.waypoint instead.
     *     @type string $current_route_segment
     *           The polyline specifying the route the driver app intends to take to
     *           the next waypoint. Your driver app updates this every time a waypoint is
     *           passed or the driver reroutes. This list is also returned in
     *           Trip.current_route_segment for all active trips assigned to the vehicle.
     *           Note: This field is intended only for use by the Driver SDK.
     *     @type \Google\Protobuf\Timestamp $current_route_segment_version
     *           Time when current_route_segment was set. This field is ignored in
     *           UpdateVehicleRequests as it is calculated by the server. It should be
     *           stored by client and passed in to future requests to prevent returning
     *           routes to first way point that haven't changed.
     *     @type \Maps\Fleetengine\V1\TripWaypoint $current_route_segment_end_point
     *           The waypoint where current_route_segment ends. This can be supplied by
     *           drivers on UpdateVehicle calls either as a full trip waypoint, a waypoint
     *           latlnt, or as a the last latlng of the current_route_segment. FleetEngine
     *           will then do its best to interpolate to an actual waypoint if it is not
     *           fully specified. This field is ignored in UpdateVehicle calls unless
     *           current_route_segment is also specified.
     *     @type \Google\Protobuf\Int32Value $remaining_distance_meters
     *           The remaining driving distance for the 'current_route_segment'. This field
     *           facilitates journey sharing between the Driver app and the Consumer app.
     *           This value is updated by the Driver SDK. Fleet Engine does not update it.
     *           This field is also returned in Trip.remaining_distance_meters for all
     *           active trips assigned to the vehicle. The value is unspecified if the
     *           `Vehicle.current_route_segment` field is empty, or if the Driver app has
     *           not updated its value.
     *     @type \Google\Protobuf\Timestamp $eta_to_first_waypoint
     *           The ETA to the next waypoint that is the first entry in Vehicle.waypoint
     *           field. This field facilitates journey sharing between a Driver app and a
     *           Consumer app and is updated by the Driver SDK, and Fleet Engine does not
     *           update it. This field is also returned in Trip.eta_to_first_waypoint for
     *           all active trips assigned to the vehicle. The value is unspecified if the
     *           Vehicle.waypoint field is empty, or the Driver app has not updated its
     *           value.
     *     @type \Google\Protobuf\Int32Value $remaining_time_seconds
     *           The remaining driving time for the 'current_route_segment'. This field
     *           facilitates journey sharing between the Driver app and the Consumer app.
     *           This value is updated by the Driver SDK. Fleet Engine does not update it.
     *           The value is unspecified if the `Vehicle.current_route_segment` field is
     *           empty, or if the Driver app has not updated its value. This value should
     *           match eta_to_first_waypoint - current_time if all parties are using the
     *           same clock. This field is currently write-only and will not yet be
     *           populated in Vehicle's get/update/search operations. When updating a
     *           vehicle, if you update both eta_to_first_waypoint and
     *           remaining_time_seconds in the same request, then only
     *           remaining_time_seconds is considered.
     *     @type \Maps\Fleetengine\V1\TripWaypoint[]|\Google\Protobuf\Internal\RepeatedField $waypoints
     *           The remaining set of waypoints assigned to this Vehicle.
     *     @type \Google\Protobuf\Timestamp $waypoints_version
     *           Last time the waypoints was updated. Client should cache
     *           this value and pass it in GetVehicleRequest to ensure the
     *           waypoints.path_to_waypoint is only returned if it is updated
     *     @type bool $back_to_back_enabled
     *           Indicates if the driver accepts back-to-back rides. If
     *           `true`, services include the vehicle for back-to-back matches.
     *           If `false`, services exclude the vehicle from back-to-back matches.
     *           Default value is `false`.
     *     @type int $navigation_status
     *           Vehicle's navigation status.
     *     @type \Maps\Fleetengine\V1\DeviceSettings $device_settings
     *           Information about various device settings. This is internal debug only
     *           field, not included in the response.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Google\Maps\Fleetengine\V1\Vehicles::initOnce();
        parent::__construct($data);
    }

    /**
     * The unique name for this vehicle.
     * The format is providers/{provider}/vehicles/{vehicle}
     *
     * Generated from protobuf field <code>string name = 1;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * The unique name for this vehicle.
     * The format is providers/{provider}/vehicles/{vehicle}
     *
     * Generated from protobuf field <code>string name = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     * The vehicle state.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.VehicleState vehicle_state = 2;</code>
     * @return int
     */
    public function getVehicleState()
    {
        return $this->vehicle_state;
    }

    /**
     * The vehicle state.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.VehicleState vehicle_state = 2;</code>
     * @param int $var
     * @return $this
     */
    public function setVehicleState($var)
    {
        GPBUtil::checkEnum($var, \Maps\Fleetengine\V1\VehicleState::class);
        $this->vehicle_state = $var;

        return $this;
    }

    /**
     * Supported trip types.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TripType supported_trip_types = 3;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getSupportedTripTypes()
    {
        return $this->supported_trip_types;
    }

    /**
     * Supported trip types.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TripType supported_trip_types = 3;</code>
     * @param int[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setSupportedTripTypes($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::ENUM, \Maps\Fleetengine\V1\TripType::class);
        $this->supported_trip_types = $arr;

        return $this;
    }

    /**
     * List of IDs for trips in progress.
     *
     * Generated from protobuf field <code>repeated string current_trips = 4;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getCurrentTrips()
    {
        return $this->current_trips;
    }

    /**
     * List of IDs for trips in progress.
     *
     * Generated from protobuf field <code>repeated string current_trips = 4;</code>
     * @param string[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setCurrentTrips($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);
        $this->current_trips = $arr;

        return $this;
    }

    /**
     * Last reported location of the vehicle.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.VehicleLocation last_location = 5;</code>
     * @return \Maps\Fleetengine\V1\VehicleLocation|null
     */
    public function getLastLocation()
    {
        return $this->last_location;
    }

    public function hasLastLocation()
    {
        return isset($this->last_location);
    }

    public function clearLastLocation()
    {
        unset($this->last_location);
    }

    /**
     * Last reported location of the vehicle.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.VehicleLocation last_location = 5;</code>
     * @param \Maps\Fleetengine\V1\VehicleLocation $var
     * @return $this
     */
    public function setLastLocation($var)
    {
        GPBUtil::checkMessage($var, \Maps\Fleetengine\V1\VehicleLocation::class);
        $this->last_location = $var;

        return $this;
    }

    /**
     * Maximum capacity of the vehicle.  This is the total numbers of riders
     * on trips this vehicle can contain.  The driver is not considered in
     * this value.  This value must be greater than or equal to one.
     *
     * Generated from protobuf field <code>int32 maximum_capacity = 6;</code>
     * @return int
     */
    public function getMaximumCapacity()
    {
        return $this->maximum_capacity;
    }

    /**
     * Maximum capacity of the vehicle.  This is the total numbers of riders
     * on trips this vehicle can contain.  The driver is not considered in
     * this value.  This value must be greater than or equal to one.
     *
     * Generated from protobuf field <code>int32 maximum_capacity = 6;</code>
     * @param int $var
     * @return $this
     */
    public function setMaximumCapacity($var)
    {
        GPBUtil::checkInt32($var);
        $this->maximum_capacity = $var;

        return $this;
    }

    /**
     * The current available capacity of the vehicle.  This is the
     * maximum_capacity minus the current number of riders.
     *
     * Generated from protobuf field <code>int32 available_capacity = 7;</code>
     * @return int
     */
    public function getAvailableCapacity()
    {
        return $this->available_capacity;
    }

    /**
     * The current available capacity of the vehicle.  This is the
     * maximum_capacity minus the current number of riders.
     *
     * Generated from protobuf field <code>int32 available_capacity = 7;</code>
     * @param int $var
     * @return $this
     */
    public function setAvailableCapacity($var)
    {
        GPBUtil::checkInt32($var);
        $this->available_capacity = $var;

        return $this;
    }

    /**
     * List of vehicle service attributes.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.VehicleAttribute attributes = 8;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getAttributes()
    {
        return $this->attributes;
    }

    /**
     * List of vehicle service attributes.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.VehicleAttribute attributes = 8;</code>
     * @param \Maps\Fleetengine\V1\VehicleAttribute[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setAttributes($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Maps\Fleetengine\V1\VehicleAttribute::class);
        $this->attributes = $arr;

        return $this;
    }

    /**
     * The type of this Vehicle.  Can be filtered during SearchVehicles.  Also
     * influences ETA and route calculations.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.Vehicle.VehicleType vehicle_type = 9;</code>
     * @return \Maps\Fleetengine\V1\Vehicle\VehicleType|null
     */
    public function getVehicleType()
    {
        return $this->vehicle_type;
    }

    public function hasVehicleType()
    {
        return isset($this->vehicle_type);
    }

    public function clearVehicleType()
    {
        unset($this->vehicle_type);
    }

    /**
     * The type of this Vehicle.  Can be filtered during SearchVehicles.  Also
     * influences ETA and route calculations.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.Vehicle.VehicleType vehicle_type = 9;</code>
     * @param \Maps\Fleetengine\V1\Vehicle\VehicleType $var
     * @return $this
     */
    public function setVehicleType($var)
    {
        GPBUtil::checkMessage($var, \Maps\Fleetengine\V1\Vehicle\VehicleType::class);
        $this->vehicle_type = $var;

        return $this;
    }

    /**
     * License plate information for the vehicle.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.LicensePlate license_plate = 10;</code>
     * @return \Maps\Fleetengine\V1\LicensePlate|null
     */
    public function getLicensePlate()
    {
        return $this->license_plate;
    }

    public function hasLicensePlate()
    {
        return isset($this->license_plate);
    }

    public function clearLicensePlate()
    {
        unset($this->license_plate);
    }

    /**
     * License plate information for the vehicle.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.LicensePlate license_plate = 10;</code>
     * @param \Maps\Fleetengine\V1\LicensePlate $var
     * @return $this
     */
    public function setLicensePlate($var)
    {
        GPBUtil::checkMessage($var, \Maps\Fleetengine\V1\LicensePlate::class);
        $this->license_plate = $var;

        return $this;
    }

    /**
     * Deprecated. Use vehicle.waypoint instead.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TerminalLocation route = 12 [deprecated = true];</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     * @deprecated
     */
    public function getRoute()
    {
        @trigger_error('route is deprecated.', E_USER_DEPRECATED);
        return $this->route;
    }

    /**
     * Deprecated. Use vehicle.waypoint instead.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TerminalLocation route = 12 [deprecated = true];</code>
     * @param \Maps\Fleetengine\V1\TerminalLocation[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     * @deprecated
     */
    public function setRoute($var)
    {
        @trigger_error('route is deprecated.', E_USER_DEPRECATED);
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Maps\Fleetengine\V1\TerminalLocation::class);
        $this->route = $arr;

        return $this;
    }

    /**
     * The polyline specifying the route the driver app intends to take to
     * the next waypoint. Your driver app updates this every time a waypoint is
     * passed or the driver reroutes. This list is also returned in
     * Trip.current_route_segment for all active trips assigned to the vehicle.
     * Note: This field is intended only for use by the Driver SDK.
     *
     * Generated from protobuf field <code>string current_route_segment = 20;</code>
     * @return string
     */
    public function getCurrentRouteSegment()
    {
        return $this->current_route_segment;
    }

    /**
     * The polyline specifying the route the driver app intends to take to
     * the next waypoint. Your driver app updates this every time a waypoint is
     * passed or the driver reroutes. This list is also returned in
     * Trip.current_route_segment for all active trips assigned to the vehicle.
     * Note: This field is intended only for use by the Driver SDK.
     *
     * Generated from protobuf field <code>string current_route_segment = 20;</code>
     * @param string $var
     * @return $this
     */
    public function setCurrentRouteSegment($var)
    {
        GPBUtil::checkString($var, True);
        $this->current_route_segment = $var;

        return $this;
    }

    /**
     * Time when current_route_segment was set. This field is ignored in
     * UpdateVehicleRequests as it is calculated by the server. It should be
     * stored by client and passed in to future requests to prevent returning
     * routes to first way point that haven't changed.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp current_route_segment_version = 15;</code>
     * @return \Google\Protobuf\Timestamp|null
     */
    public function getCurrentRouteSegmentVersion()
    {
        return $this->current_route_segment_version;
    }

    public function hasCurrentRouteSegmentVersion()
    {
        return isset($this->current_route_segment_version);
    }

    public function clearCurrentRouteSegmentVersion()
    {
        unset($this->current_route_segment_version);
    }

    /**
     * Time when current_route_segment was set. This field is ignored in
     * UpdateVehicleRequests as it is calculated by the server. It should be
     * stored by client and passed in to future requests to prevent returning
     * routes to first way point that haven't changed.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp current_route_segment_version = 15;</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setCurrentRouteSegmentVersion($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->current_route_segment_version = $var;

        return $this;
    }

    /**
     * The waypoint where current_route_segment ends. This can be supplied by
     * drivers on UpdateVehicle calls either as a full trip waypoint, a waypoint
     * latlnt, or as a the last latlng of the current_route_segment. FleetEngine
     * will then do its best to interpolate to an actual waypoint if it is not
     * fully specified. This field is ignored in UpdateVehicle calls unless
     * current_route_segment is also specified.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.TripWaypoint current_route_segment_end_point = 24;</code>
     * @return \Maps\Fleetengine\V1\TripWaypoint|null
     */
    public function getCurrentRouteSegmentEndPoint()
    {
        return $this->current_route_segment_end_point;
    }

    public function hasCurrentRouteSegmentEndPoint()
    {
        return isset($this->current_route_segment_end_point);
    }

    public function clearCurrentRouteSegmentEndPoint()
    {
        unset($this->current_route_segment_end_point);
    }

    /**
     * The waypoint where current_route_segment ends. This can be supplied by
     * drivers on UpdateVehicle calls either as a full trip waypoint, a waypoint
     * latlnt, or as a the last latlng of the current_route_segment. FleetEngine
     * will then do its best to interpolate to an actual waypoint if it is not
     * fully specified. This field is ignored in UpdateVehicle calls unless
     * current_route_segment is also specified.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.TripWaypoint current_route_segment_end_point = 24;</code>
     * @param \Maps\Fleetengine\V1\TripWaypoint $var
     * @return $this
     */
    public function setCurrentRouteSegmentEndPoint($var)
    {
        GPBUtil::checkMessage($var, \Maps\Fleetengine\V1\TripWaypoint::class);
        $this->current_route_segment_end_point = $var;

        return $this;
    }

    /**
     * The remaining driving distance for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * This field is also returned in Trip.remaining_distance_meters for all
     * active trips assigned to the vehicle. The value is unspecified if the
     * `Vehicle.current_route_segment` field is empty, or if the Driver app has
     * not updated its value.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_distance_meters = 18;</code>
     * @return \Google\Protobuf\Int32Value|null
     */
    public function getRemainingDistanceMeters()
    {
        return $this->remaining_distance_meters;
    }

    public function hasRemainingDistanceMeters()
    {
        return isset($this->remaining_distance_meters);
    }

    public function clearRemainingDistanceMeters()
    {
        unset($this->remaining_distance_meters);
    }

    /**
     * Returns the unboxed value from <code>getRemainingDistanceMeters()</code>

     * The remaining driving distance for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * This field is also returned in Trip.remaining_distance_meters for all
     * active trips assigned to the vehicle. The value is unspecified if the
     * `Vehicle.current_route_segment` field is empty, or if the Driver app has
     * not updated its value.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_distance_meters = 18;</code>
     * @return int|null
     */
    public function getRemainingDistanceMetersUnwrapped()
    {
        return $this->readWrapperValue("remaining_distance_meters");
    }

    /**
     * The remaining driving distance for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * This field is also returned in Trip.remaining_distance_meters for all
     * active trips assigned to the vehicle. The value is unspecified if the
     * `Vehicle.current_route_segment` field is empty, or if the Driver app has
     * not updated its value.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_distance_meters = 18;</code>
     * @param \Google\Protobuf\Int32Value $var
     * @return $this
     */
    public function setRemainingDistanceMeters($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Int32Value::class);
        $this->remaining_distance_meters = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\Int32Value object.

     * The remaining driving distance for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * This field is also returned in Trip.remaining_distance_meters for all
     * active trips assigned to the vehicle. The value is unspecified if the
     * `Vehicle.current_route_segment` field is empty, or if the Driver app has
     * not updated its value.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_distance_meters = 18;</code>
     * @param int|null $var
     * @return $this
     */
    public function setRemainingDistanceMetersUnwrapped($var)
    {
        $this->writeWrapperValue("remaining_distance_meters", $var);
        return $this;}

    /**
     * The ETA to the next waypoint that is the first entry in Vehicle.waypoint
     * field. This field facilitates journey sharing between a Driver app and a
     * Consumer app and is updated by the Driver SDK, and Fleet Engine does not
     * update it. This field is also returned in Trip.eta_to_first_waypoint for
     * all active trips assigned to the vehicle. The value is unspecified if the
     * Vehicle.waypoint field is empty, or the Driver app has not updated its
     * value.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp eta_to_first_waypoint = 19;</code>
     * @return \Google\Protobuf\Timestamp|null
     */
    public function getEtaToFirstWaypoint()
    {
        return $this->eta_to_first_waypoint;
    }

    public function hasEtaToFirstWaypoint()
    {
        return isset($this->eta_to_first_waypoint);
    }

    public function clearEtaToFirstWaypoint()
    {
        unset($this->eta_to_first_waypoint);
    }

    /**
     * The ETA to the next waypoint that is the first entry in Vehicle.waypoint
     * field. This field facilitates journey sharing between a Driver app and a
     * Consumer app and is updated by the Driver SDK, and Fleet Engine does not
     * update it. This field is also returned in Trip.eta_to_first_waypoint for
     * all active trips assigned to the vehicle. The value is unspecified if the
     * Vehicle.waypoint field is empty, or the Driver app has not updated its
     * value.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp eta_to_first_waypoint = 19;</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setEtaToFirstWaypoint($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->eta_to_first_waypoint = $var;

        return $this;
    }

    /**
     * The remaining driving time for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * The value is unspecified if the `Vehicle.current_route_segment` field is
     * empty, or if the Driver app has not updated its value. This value should
     * match eta_to_first_waypoint - current_time if all parties are using the
     * same clock. This field is currently write-only and will not yet be
     * populated in Vehicle's get/update/search operations. When updating a
     * vehicle, if you update both eta_to_first_waypoint and
     * remaining_time_seconds in the same request, then only
     * remaining_time_seconds is considered.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_time_seconds = 25;</code>
     * @return \Google\Protobuf\Int32Value|null
     */
    public function getRemainingTimeSeconds()
    {
        return $this->remaining_time_seconds;
    }

    public function hasRemainingTimeSeconds()
    {
        return isset($this->remaining_time_seconds);
    }

    public function clearRemainingTimeSeconds()
    {
        unset($this->remaining_time_seconds);
    }

    /**
     * Returns the unboxed value from <code>getRemainingTimeSeconds()</code>

     * The remaining driving time for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * The value is unspecified if the `Vehicle.current_route_segment` field is
     * empty, or if the Driver app has not updated its value. This value should
     * match eta_to_first_waypoint - current_time if all parties are using the
     * same clock. This field is currently write-only and will not yet be
     * populated in Vehicle's get/update/search operations. When updating a
     * vehicle, if you update both eta_to_first_waypoint and
     * remaining_time_seconds in the same request, then only
     * remaining_time_seconds is considered.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_time_seconds = 25;</code>
     * @return int|null
     */
    public function getRemainingTimeSecondsUnwrapped()
    {
        return $this->readWrapperValue("remaining_time_seconds");
    }

    /**
     * The remaining driving time for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * The value is unspecified if the `Vehicle.current_route_segment` field is
     * empty, or if the Driver app has not updated its value. This value should
     * match eta_to_first_waypoint - current_time if all parties are using the
     * same clock. This field is currently write-only and will not yet be
     * populated in Vehicle's get/update/search operations. When updating a
     * vehicle, if you update both eta_to_first_waypoint and
     * remaining_time_seconds in the same request, then only
     * remaining_time_seconds is considered.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_time_seconds = 25;</code>
     * @param \Google\Protobuf\Int32Value $var
     * @return $this
     */
    public function setRemainingTimeSeconds($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Int32Value::class);
        $this->remaining_time_seconds = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\Int32Value object.

     * The remaining driving time for the 'current_route_segment'. This field
     * facilitates journey sharing between the Driver app and the Consumer app.
     * This value is updated by the Driver SDK. Fleet Engine does not update it.
     * The value is unspecified if the `Vehicle.current_route_segment` field is
     * empty, or if the Driver app has not updated its value. This value should
     * match eta_to_first_waypoint - current_time if all parties are using the
     * same clock. This field is currently write-only and will not yet be
     * populated in Vehicle's get/update/search operations. When updating a
     * vehicle, if you update both eta_to_first_waypoint and
     * remaining_time_seconds in the same request, then only
     * remaining_time_seconds is considered.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value remaining_time_seconds = 25;</code>
     * @param int|null $var
     * @return $this
     */
    public function setRemainingTimeSecondsUnwrapped($var)
    {
        $this->writeWrapperValue("remaining_time_seconds", $var);
        return $this;}

    /**
     * The remaining set of waypoints assigned to this Vehicle.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TripWaypoint waypoints = 22;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getWaypoints()
    {
        return $this->waypoints;
    }

    /**
     * The remaining set of waypoints assigned to this Vehicle.
     *
     * Generated from protobuf field <code>repeated .maps.fleetengine.v1.TripWaypoint waypoints = 22;</code>
     * @param \Maps\Fleetengine\V1\TripWaypoint[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setWaypoints($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Maps\Fleetengine\V1\TripWaypoint::class);
        $this->waypoints = $arr;

        return $this;
    }

    /**
     * Last time the waypoints was updated. Client should cache
     * this value and pass it in GetVehicleRequest to ensure the
     * waypoints.path_to_waypoint is only returned if it is updated
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp waypoints_version = 16;</code>
     * @return \Google\Protobuf\Timestamp|null
     */
    public function getWaypointsVersion()
    {
        return $this->waypoints_version;
    }

    public function hasWaypointsVersion()
    {
        return isset($this->waypoints_version);
    }

    public function clearWaypointsVersion()
    {
        unset($this->waypoints_version);
    }

    /**
     * Last time the waypoints was updated. Client should cache
     * this value and pass it in GetVehicleRequest to ensure the
     * waypoints.path_to_waypoint is only returned if it is updated
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp waypoints_version = 16;</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setWaypointsVersion($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->waypoints_version = $var;

        return $this;
    }

    /**
     * Indicates if the driver accepts back-to-back rides. If
     * `true`, services include the vehicle for back-to-back matches.
     * If `false`, services exclude the vehicle from back-to-back matches.
     * Default value is `false`.
     *
     * Generated from protobuf field <code>bool back_to_back_enabled = 23;</code>
     * @return bool
     */
    public function getBackToBackEnabled()
    {
        return $this->back_to_back_enabled;
    }

    /**
     * Indicates if the driver accepts back-to-back rides. If
     * `true`, services include the vehicle for back-to-back matches.
     * If `false`, services exclude the vehicle from back-to-back matches.
     * Default value is `false`.
     *
     * Generated from protobuf field <code>bool back_to_back_enabled = 23;</code>
     * @param bool $var
     * @return $this
     */
    public function setBackToBackEnabled($var)
    {
        GPBUtil::checkBool($var);
        $this->back_to_back_enabled = $var;

        return $this;
    }

    /**
     * Vehicle's navigation status.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.NavigationStatus navigation_status = 26;</code>
     * @return int
     */
    public function getNavigationStatus()
    {
        return $this->navigation_status;
    }

    /**
     * Vehicle's navigation status.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.NavigationStatus navigation_status = 26;</code>
     * @param int $var
     * @return $this
     */
    public function setNavigationStatus($var)
    {
        GPBUtil::checkEnum($var, \Maps\Fleetengine\V1\NavigationStatus::class);
        $this->navigation_status = $var;

        return $this;
    }

    /**
     * Information about various device settings. This is internal debug only
     * field, not included in the response.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.DeviceSettings device_settings = 27;</code>
     * @return \Maps\Fleetengine\V1\DeviceSettings|null
     */
    public function getDeviceSettings()
    {
        return $this->device_settings;
    }

    public function hasDeviceSettings()
    {
        return isset($this->device_settings);
    }

    public function clearDeviceSettings()
    {
        unset($this->device_settings);
    }

    /**
     * Information about various device settings. This is internal debug only
     * field, not included in the response.
     *
     * Generated from protobuf field <code>.maps.fleetengine.v1.DeviceSettings device_settings = 27;</code>
     * @param \Maps\Fleetengine\V1\DeviceSettings $var
     * @return $this
     */
    public function setDeviceSettings($var)
    {
        GPBUtil::checkMessage($var, \Maps\Fleetengine\V1\DeviceSettings::class);
        $this->device_settings = $var;

        return $this;
    }

}

