// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/fleetengine/v1/trips.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Maps.Fleetengine.V1 {

  /// <summary>Holder for reflection information generated from google/maps/fleetengine/v1/trips.proto</summary>
  public static partial class TripsReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/fleetengine/v1/trips.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TripsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiZnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS90cmlwcy5wcm90bxITbWFw",
            "cy5mbGVldGVuZ2luZS52MRofZ29vZ2xlL2FwaS9maWVsZF9iZWhhdmlvci5w",
            "cm90bxoZZ29vZ2xlL2FwaS9yZXNvdXJjZS5wcm90bxosZ29vZ2xlL21hcHMv",
            "ZmxlZXRlbmdpbmUvdjEvZmxlZXRlbmdpbmUucHJvdG8aHmdvb2dsZS9wcm90",
            "b2J1Zi9kdXJhdGlvbi5wcm90bxofZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFt",
            "cC5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGhhnb29n",
            "bGUvdHlwZS9sYXRsbmcucHJvdG8i6A0KBFRyaXASDAoEbmFtZRgBIAEoCRIS",
            "Cgp2ZWhpY2xlX2lkGAIgASgJEjQKC3RyaXBfc3RhdHVzGAMgASgOMh8ubWFw",
            "cy5mbGVldGVuZ2luZS52MS5UcmlwU3RhdHVzEjAKCXRyaXBfdHlwZRgEIAEo",
            "DjIdLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcFR5cGUSOwoMcGlja3VwX3Bv",
            "aW50GAUgASgLMiUubWFwcy5mbGVldGVuZ2luZS52MS5UZXJtaW5hbExvY2F0",
            "aW9uEkMKE2FjdHVhbF9waWNrdXBfcG9pbnQYFiABKAsyIS5tYXBzLmZsZWV0",
            "ZW5naW5lLnYxLlN0b3BMb2NhdGlvbkID4EEEEksKG2FjdHVhbF9waWNrdXBf",
            "YXJyaXZhbF9wb2ludBggIAEoCzIhLm1hcHMuZmxlZXRlbmdpbmUudjEuU3Rv",
            "cExvY2F0aW9uQgPgQQQSLwoLcGlja3VwX3RpbWUYBiABKAsyGi5nb29nbGUu",
            "cHJvdG9idWYuVGltZXN0YW1wEkgKGWludGVybWVkaWF0ZV9kZXN0aW5hdGlv",
            "bnMYDiADKAsyJS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRlcm1pbmFsTG9jYXRp",
            "b24SRQohaW50ZXJtZWRpYXRlX2Rlc3RpbmF0aW9uc192ZXJzaW9uGBkgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBImCh5pbnRlcm1lZGlhdGVf",
            "ZGVzdGluYXRpb25faW5kZXgYDyABKAUSXgouYWN0dWFsX2ludGVybWVkaWF0",
            "ZV9kZXN0aW5hdGlvbl9hcnJpdmFsX3BvaW50cxghIAMoCzIhLm1hcHMuZmxl",
            "ZXRlbmdpbmUudjEuU3RvcExvY2F0aW9uQgPgQQQSUAogYWN0dWFsX2ludGVy",
            "bWVkaWF0ZV9kZXN0aW5hdGlvbnMYIiADKAsyIS5tYXBzLmZsZWV0ZW5naW5l",
            "LnYxLlN0b3BMb2NhdGlvbkID4EEEEjwKDWRyb3BvZmZfcG9pbnQYByABKAsy",
            "JS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRlcm1pbmFsTG9jYXRpb24SRAoUYWN0",
            "dWFsX2Ryb3BvZmZfcG9pbnQYFyABKAsyIS5tYXBzLmZsZWV0ZW5naW5lLnYx",
            "LlN0b3BMb2NhdGlvbkID4EEEEjAKDGRyb3BvZmZfdGltZRgIIAEoCzIaLmdv",
            "b2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASQwoTcmVtYWluaW5nX3dheXBvaW50",
            "cxgQIAMoCzIhLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcFdheXBvaW50QgPg",
            "QQMSPAoRdmVoaWNsZV93YXlwb2ludHMYFCADKAsyIS5tYXBzLmZsZWV0ZW5n",
            "aW5lLnYxLlRyaXBXYXlwb2ludBIiCgVyb3V0ZRgJIAMoCzITLmdvb2dsZS50",
            "eXBlLkxhdExuZxJKCh9jdXJyZW50X3JvdXRlX3NlZ21lbnRfZW5kX3BvaW50",
            "GBggASgLMiEubWFwcy5mbGVldGVuZ2luZS52MS5UcmlwV2F5cG9pbnQSPgoZ",
            "cmVtYWluaW5nX2Rpc3RhbmNlX21ldGVycxgMIAEoCzIbLmdvb2dsZS5wcm90",
            "b2J1Zi5JbnQzMlZhbHVlEj4KFWV0YV90b19maXJzdF93YXlwb2ludBgNIAEo",
            "CzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxJICiByZW1haW5p",
            "bmdfdGltZV90b19maXJzdF93YXlwb2ludBgbIAEoCzIZLmdvb2dsZS5wcm90",
            "b2J1Zi5EdXJhdGlvbkID4EEDEj8KG3JlbWFpbmluZ193YXlwb2ludHNfdmVy",
            "c2lvbhgTIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASRQohcmVt",
            "YWluaW5nX3dheXBvaW50c19yb3V0ZV92ZXJzaW9uGB0gASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLlRpbWVzdGFtcBIcChRudW1iZXJfb2ZfcGFzc2VuZ2VycxgK",
            "IAEoBRI7Cg1sYXN0X2xvY2F0aW9uGAsgASgLMiQubWFwcy5mbGVldGVuZ2lu",
            "ZS52MS5WZWhpY2xlTG9jYXRpb24SHwoXbGFzdF9sb2NhdGlvbl9zbmFwcGFi",
            "bGUYGiABKAgSKwoEdmlldxgfIAEoDjIdLm1hcHMuZmxlZXRlbmdpbmUudjEu",
            "VHJpcFZpZXc6R+pBRAofZmxlZXRlbmdpbmUuZ29vZ2xlYXBpcy5jb20vVHJp",
            "cBIhcHJvdmlkZXJzL3twcm92aWRlcn0vdHJpcHMve3RyaXB9IpUBCgxTdG9w",
            "TG9jYXRpb24SJwoFcG9pbnQYASABKAsyEy5nb29nbGUudHlwZS5MYXRMbmdC",
            "A+BBAhItCgl0aW1lc3RhbXAYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGlt",
            "ZXN0YW1wEi0KCXN0b3BfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5U",
            "aW1lc3RhbXAq4gEKClRyaXBTdGF0dXMSFwoTVU5LTk9XTl9UUklQX1NUQVRV",
            "UxAAEgcKA05FVxABEhUKEUVOUk9VVEVfVE9fUElDS1VQEAISFQoRQVJSSVZF",
            "RF9BVF9QSUNLVVAQAxInCiNBUlJJVkVEX0FUX0lOVEVSTUVESUFURV9ERVNU",
            "SU5BVElPThAHEicKI0VOUk9VVEVfVE9fSU5URVJNRURJQVRFX0RFU1RJTkFU",
            "SU9OEAgSFgoSRU5ST1VURV9UT19EUk9QT0ZGEAQSDAoIQ09NUExFVEUQBRIM",
            "CghDQU5DRUxFRBAGKn8KGUJpbGxpbmdQbGF0Zm9ybUlkZW50aWZpZXISKwon",
            "QklMTElOR19QTEFURk9STV9JREVOVElGSUVSX1VOU1BFQ0lGSUVEEAASCgoG",
            "U0VSVkVSEAESBwoDV0VCEAISCwoHQU5EUk9JRBADEgcKA0lPUxAEEgoKBk9U",
            "SEVSUxAFKkcKCFRyaXBWaWV3EhkKFVRSSVBfVklFV19VTlNQRUNJRklFRBAA",
            "EgcKA1NESxABEhcKE0pPVVJORVlfU0hBUklOR19WMVMQAkJyChpnb29nbGUu",
            "bWFwcy5mbGVldGVuZ2luZS52MUIFVHJpcHNQAVpFZ29vZ2xlLmdvbGFuZy5v",
            "cmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9tYXBzL2ZsZWV0ZW5naW5lL3YxO2Zs",
            "ZWV0ZW5naW5logIDQ0ZFYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Type.LatlngReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Maps.Fleetengine.V1.TripStatus), typeof(global::Maps.Fleetengine.V1.BillingPlatformIdentifier), typeof(global::Maps.Fleetengine.V1.TripView), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.Trip), global::Maps.Fleetengine.V1.Trip.Parser, new[]{ "Name", "VehicleId", "TripStatus", "TripType", "PickupPoint", "ActualPickupPoint", "ActualPickupArrivalPoint", "PickupTime", "IntermediateDestinations", "IntermediateDestinationsVersion", "IntermediateDestinationIndex", "ActualIntermediateDestinationArrivalPoints", "ActualIntermediateDestinations", "DropoffPoint", "ActualDropoffPoint", "DropoffTime", "RemainingWaypoints", "VehicleWaypoints", "Route", "CurrentRouteSegmentEndPoint", "RemainingDistanceMeters", "EtaToFirstWaypoint", "RemainingTimeToFirstWaypoint", "RemainingWaypointsVersion", "RemainingWaypointsRouteVersion", "NumberOfPassengers", "LastLocation", "LastLocationSnappable", "View" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.StopLocation), global::Maps.Fleetengine.V1.StopLocation.Parser, new[]{ "Point", "Timestamp", "StopTime" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// The status of a trip indicating its progression.
  /// </summary>
  public enum TripStatus {
    /// <summary>
    /// Default, used for unspecified or unrecognized trip status.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_TRIP_STATUS")] UnknownTripStatus = 0,
    /// <summary>
    /// Newly created trip.
    /// </summary>
    [pbr::OriginalName("NEW")] New = 1,
    /// <summary>
    /// The driver is on their way to the pickup point.
    /// </summary>
    [pbr::OriginalName("ENROUTE_TO_PICKUP")] EnrouteToPickup = 2,
    /// <summary>
    /// The driver has arrived at the pickup point.
    /// </summary>
    [pbr::OriginalName("ARRIVED_AT_PICKUP")] ArrivedAtPickup = 3,
    /// <summary>
    /// The driver has arrived at an intermediate destination and is waiting for
    /// the rider.
    /// </summary>
    [pbr::OriginalName("ARRIVED_AT_INTERMEDIATE_DESTINATION")] ArrivedAtIntermediateDestination = 7,
    /// <summary>
    /// The driver is on their way to an intermediate destination
    /// (not the dropoff point).
    /// </summary>
    [pbr::OriginalName("ENROUTE_TO_INTERMEDIATE_DESTINATION")] EnrouteToIntermediateDestination = 8,
    /// <summary>
    /// The driver has picked up the rider and is on their way to the
    /// next destination.
    /// </summary>
    [pbr::OriginalName("ENROUTE_TO_DROPOFF")] EnrouteToDropoff = 4,
    /// <summary>
    /// The rider has been dropped off and the trip is complete.
    /// </summary>
    [pbr::OriginalName("COMPLETE")] Complete = 5,
    /// <summary>
    /// The trip was canceled prior to pickup by the driver, rider, or
    /// rideshare provider.
    /// </summary>
    [pbr::OriginalName("CANCELED")] Canceled = 6,
  }

  /// <summary>
  /// A set of values that indicate upon which platform the request was issued.
  /// </summary>
  public enum BillingPlatformIdentifier {
    /// <summary>
    /// Default. Used for unspecified platforms.
    /// </summary>
    [pbr::OriginalName("BILLING_PLATFORM_IDENTIFIER_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// The platform is a client server.
    /// </summary>
    [pbr::OriginalName("SERVER")] Server = 1,
    /// <summary>
    /// The platform is a web browser.
    /// </summary>
    [pbr::OriginalName("WEB")] Web = 2,
    /// <summary>
    /// The platform is an Android mobile device.
    /// </summary>
    [pbr::OriginalName("ANDROID")] Android = 3,
    /// <summary>
    /// The platform is an IOS mobile device.
    /// </summary>
    [pbr::OriginalName("IOS")] Ios = 4,
    /// <summary>
    /// Other platforms that are not listed in this enumeration.
    /// </summary>
    [pbr::OriginalName("OTHERS")] Others = 5,
  }

  /// <summary>
  /// Selector for different sets of Trip fields in a `GetTrip` response.  See
  /// [AIP-157](https://google.aip.dev/157) for context. Additional views are
  /// likely to be added.
  /// </summary>
  public enum TripView {
    /// <summary>
    /// The default value. For backwards-compatibility, the API will default to an
    /// SDK view. To ensure stability and support, customers are
    /// advised to select a `TripView` other than `SDK`.
    /// </summary>
    [pbr::OriginalName("TRIP_VIEW_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Includes fields that may not be interpretable or supportable using
    /// publicly available libraries.
    /// </summary>
    [pbr::OriginalName("SDK")] Sdk = 1,
    /// <summary>
    /// Trip fields are populated for the Journey Sharing use case. This view is
    /// intended for server-to-server communications.
    /// </summary>
    [pbr::OriginalName("JOURNEY_SHARING_V1S")] JourneySharingV1S = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Trip metadata.
  /// </summary>
  public sealed partial class Trip : pb::IMessage<Trip>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Trip> _parser = new pb::MessageParser<Trip>(() => new Trip());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Trip> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Trip() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Trip(Trip other) : this() {
      name_ = other.name_;
      vehicleId_ = other.vehicleId_;
      tripStatus_ = other.tripStatus_;
      tripType_ = other.tripType_;
      pickupPoint_ = other.pickupPoint_ != null ? other.pickupPoint_.Clone() : null;
      actualPickupPoint_ = other.actualPickupPoint_ != null ? other.actualPickupPoint_.Clone() : null;
      actualPickupArrivalPoint_ = other.actualPickupArrivalPoint_ != null ? other.actualPickupArrivalPoint_.Clone() : null;
      pickupTime_ = other.pickupTime_ != null ? other.pickupTime_.Clone() : null;
      intermediateDestinations_ = other.intermediateDestinations_.Clone();
      intermediateDestinationsVersion_ = other.intermediateDestinationsVersion_ != null ? other.intermediateDestinationsVersion_.Clone() : null;
      intermediateDestinationIndex_ = other.intermediateDestinationIndex_;
      actualIntermediateDestinationArrivalPoints_ = other.actualIntermediateDestinationArrivalPoints_.Clone();
      actualIntermediateDestinations_ = other.actualIntermediateDestinations_.Clone();
      dropoffPoint_ = other.dropoffPoint_ != null ? other.dropoffPoint_.Clone() : null;
      actualDropoffPoint_ = other.actualDropoffPoint_ != null ? other.actualDropoffPoint_.Clone() : null;
      dropoffTime_ = other.dropoffTime_ != null ? other.dropoffTime_.Clone() : null;
      remainingWaypoints_ = other.remainingWaypoints_.Clone();
      vehicleWaypoints_ = other.vehicleWaypoints_.Clone();
      route_ = other.route_.Clone();
      currentRouteSegmentEndPoint_ = other.currentRouteSegmentEndPoint_ != null ? other.currentRouteSegmentEndPoint_.Clone() : null;
      RemainingDistanceMeters = other.RemainingDistanceMeters;
      etaToFirstWaypoint_ = other.etaToFirstWaypoint_ != null ? other.etaToFirstWaypoint_.Clone() : null;
      remainingTimeToFirstWaypoint_ = other.remainingTimeToFirstWaypoint_ != null ? other.remainingTimeToFirstWaypoint_.Clone() : null;
      remainingWaypointsVersion_ = other.remainingWaypointsVersion_ != null ? other.remainingWaypointsVersion_.Clone() : null;
      remainingWaypointsRouteVersion_ = other.remainingWaypointsRouteVersion_ != null ? other.remainingWaypointsRouteVersion_.Clone() : null;
      numberOfPassengers_ = other.numberOfPassengers_;
      lastLocation_ = other.lastLocation_ != null ? other.lastLocation_.Clone() : null;
      lastLocationSnappable_ = other.lastLocationSnappable_;
      view_ = other.view_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Trip Clone() {
      return new Trip(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// In the format "providers/{provider}/trips/{trip}"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle_id" field.</summary>
    public const int VehicleIdFieldNumber = 2;
    private string vehicleId_ = "";
    /// <summary>
    /// ID of the vehicle making this trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VehicleId {
      get { return vehicleId_; }
      set {
        vehicleId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip_status" field.</summary>
    public const int TripStatusFieldNumber = 3;
    private global::Maps.Fleetengine.V1.TripStatus tripStatus_ = global::Maps.Fleetengine.V1.TripStatus.UnknownTripStatus;
    /// <summary>
    /// Current status of the trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TripStatus TripStatus {
      get { return tripStatus_; }
      set {
        tripStatus_ = value;
      }
    }

    /// <summary>Field number for the "trip_type" field.</summary>
    public const int TripTypeFieldNumber = 4;
    private global::Maps.Fleetengine.V1.TripType tripType_ = global::Maps.Fleetengine.V1.TripType.UnknownTripType;
    /// <summary>
    /// The type of the trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TripType TripType {
      get { return tripType_; }
      set {
        tripType_ = value;
      }
    }

    /// <summary>Field number for the "pickup_point" field.</summary>
    public const int PickupPointFieldNumber = 5;
    private global::Maps.Fleetengine.V1.TerminalLocation pickupPoint_;
    /// <summary>
    /// Location where customer indicates they will be picked up.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TerminalLocation PickupPoint {
      get { return pickupPoint_; }
      set {
        pickupPoint_ = value;
      }
    }

    /// <summary>Field number for the "actual_pickup_point" field.</summary>
    public const int ActualPickupPointFieldNumber = 22;
    private global::Maps.Fleetengine.V1.StopLocation actualPickupPoint_;
    /// <summary>
    /// Input only. The actual location when and where customer was picked up.
    /// This field is for provider to provide feedback on actual pickup
    /// information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.StopLocation ActualPickupPoint {
      get { return actualPickupPoint_; }
      set {
        actualPickupPoint_ = value;
      }
    }

    /// <summary>Field number for the "actual_pickup_arrival_point" field.</summary>
    public const int ActualPickupArrivalPointFieldNumber = 32;
    private global::Maps.Fleetengine.V1.StopLocation actualPickupArrivalPoint_;
    /// <summary>
    /// Input only. The actual time and location of the driver arrival at
    /// the pickup point.
    /// This field is for provider to provide feedback on actual arrival
    /// information at the pickup point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.StopLocation ActualPickupArrivalPoint {
      get { return actualPickupArrivalPoint_; }
      set {
        actualPickupArrivalPoint_ = value;
      }
    }

    /// <summary>Field number for the "pickup_time" field.</summary>
    public const int PickupTimeFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Timestamp pickupTime_;
    /// <summary>
    /// Either the estimated future time when the rider(s) will be picked up, or
    /// the actual time when they were picked up.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp PickupTime {
      get { return pickupTime_; }
      set {
        pickupTime_ = value;
      }
    }

    /// <summary>Field number for the "intermediate_destinations" field.</summary>
    public const int IntermediateDestinationsFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TerminalLocation> _repeated_intermediateDestinations_codec
        = pb::FieldCodec.ForMessage(114, global::Maps.Fleetengine.V1.TerminalLocation.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TerminalLocation> intermediateDestinations_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TerminalLocation>();
    /// <summary>
    /// Intermediate stops in order that the trip requests (in addition
    /// to pickup and dropoff). Initially this will not be supported for shared
    /// trips.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TerminalLocation> IntermediateDestinations {
      get { return intermediateDestinations_; }
    }

    /// <summary>Field number for the "intermediate_destinations_version" field.</summary>
    public const int IntermediateDestinationsVersionFieldNumber = 25;
    private global::Google.Protobuf.WellKnownTypes.Timestamp intermediateDestinationsVersion_;
    /// <summary>
    /// Indicates the last time the Trip.intermediate_destinations was modified.
    /// Your server should cache this value and pass it in UpdateTripRequest
    /// when update Trip.intermediate_destination_index to ensure the
    /// Trip.intermediate_destinations is not changed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp IntermediateDestinationsVersion {
      get { return intermediateDestinationsVersion_; }
      set {
        intermediateDestinationsVersion_ = value;
      }
    }

    /// <summary>Field number for the "intermediate_destination_index" field.</summary>
    public const int IntermediateDestinationIndexFieldNumber = 15;
    private int intermediateDestinationIndex_;
    /// <summary>
    /// When TripStatus is ENROUTE_TO_INTERMEDIATE_DESTINATION, a number between
    /// [0..N-1] indicating which intermediate destination the vehicle will cross
    /// next.
    /// When TripStatus is ARRIVED_AT_INTERMEDIATE_DESTINATION, a number between
    /// [0..N-1] indicating which intermediate destination the vehicle is at.
    /// The provider sets this value. If there are no intermediate_destinations,
    /// this field is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int IntermediateDestinationIndex {
      get { return intermediateDestinationIndex_; }
      set {
        intermediateDestinationIndex_ = value;
      }
    }

    /// <summary>Field number for the "actual_intermediate_destination_arrival_points" field.</summary>
    public const int ActualIntermediateDestinationArrivalPointsFieldNumber = 33;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.StopLocation> _repeated_actualIntermediateDestinationArrivalPoints_codec
        = pb::FieldCodec.ForMessage(266, global::Maps.Fleetengine.V1.StopLocation.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.StopLocation> actualIntermediateDestinationArrivalPoints_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.StopLocation>();
    /// <summary>
    /// Input only. The actual time and location of the driver's arrival at
    /// an intermediate destination.
    /// This field is for provider to provide feedback on actual arriaval
    /// information at intermediate destinations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.StopLocation> ActualIntermediateDestinationArrivalPoints {
      get { return actualIntermediateDestinationArrivalPoints_; }
    }

    /// <summary>Field number for the "actual_intermediate_destinations" field.</summary>
    public const int ActualIntermediateDestinationsFieldNumber = 34;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.StopLocation> _repeated_actualIntermediateDestinations_codec
        = pb::FieldCodec.ForMessage(274, global::Maps.Fleetengine.V1.StopLocation.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.StopLocation> actualIntermediateDestinations_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.StopLocation>();
    /// <summary>
    /// Input only. The actual time and location when and where the customer was picked up from
    /// an intermediate destination.
    /// This field is for provider to provide feedback on actual pickup
    /// information at intermediate destinations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.StopLocation> ActualIntermediateDestinations {
      get { return actualIntermediateDestinations_; }
    }

    /// <summary>Field number for the "dropoff_point" field.</summary>
    public const int DropoffPointFieldNumber = 7;
    private global::Maps.Fleetengine.V1.TerminalLocation dropoffPoint_;
    /// <summary>
    /// Location where customer indicates they will be dropped off.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TerminalLocation DropoffPoint {
      get { return dropoffPoint_; }
      set {
        dropoffPoint_ = value;
      }
    }

    /// <summary>Field number for the "actual_dropoff_point" field.</summary>
    public const int ActualDropoffPointFieldNumber = 23;
    private global::Maps.Fleetengine.V1.StopLocation actualDropoffPoint_;
    /// <summary>
    /// Input only. The actual time and location when and where customer was dropped off.
    /// This field is for provider to provide feedback on actual dropoff
    /// information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.StopLocation ActualDropoffPoint {
      get { return actualDropoffPoint_; }
      set {
        actualDropoffPoint_ = value;
      }
    }

    /// <summary>Field number for the "dropoff_time" field.</summary>
    public const int DropoffTimeFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Timestamp dropoffTime_;
    /// <summary>
    /// Either the estimated future time when the rider(s) will be dropped off at
    /// the final destination, or the actual time when they were dropped off.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp DropoffTime {
      get { return dropoffTime_; }
      set {
        dropoffTime_ = value;
      }
    }

    /// <summary>Field number for the "remaining_waypoints" field.</summary>
    public const int RemainingWaypointsFieldNumber = 16;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TripWaypoint> _repeated_remainingWaypoints_codec
        = pb::FieldCodec.ForMessage(130, global::Maps.Fleetengine.V1.TripWaypoint.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint> remainingWaypoints_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint>();
    /// <summary>
    /// Output only. The full path from the current location to the dropoff point, inclusive.
    /// If this is a shared ride, this path could include waypoints from other
    /// trips.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint> RemainingWaypoints {
      get { return remainingWaypoints_; }
    }

    /// <summary>Field number for the "vehicle_waypoints" field.</summary>
    public const int VehicleWaypointsFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TripWaypoint> _repeated_vehicleWaypoints_codec
        = pb::FieldCodec.ForMessage(162, global::Maps.Fleetengine.V1.TripWaypoint.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint> vehicleWaypoints_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint>();
    /// <summary>
    /// This field supports manual ordering of the waypoints for the trip.
    /// It contains all of the remaining waypoints of vehicle assigned, as well as
    /// the pickup and drop-off waypoints for this trip.
    /// If the trip hasn't been assigned to a vehicle, then this field is ignored.
    /// For privacy reasons, this field is only populated by the server on
    /// UpdateTrip and CreateTrip calls, and NOT on GetTrip calls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint> VehicleWaypoints {
      get { return vehicleWaypoints_; }
    }

    /// <summary>Field number for the "route" field.</summary>
    public const int RouteFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Type.LatLng> _repeated_route_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Type.LatLng.Parser);
    private readonly pbc::RepeatedField<global::Google.Type.LatLng> route_ = new pbc::RepeatedField<global::Google.Type.LatLng>();
    /// <summary>
    /// Anticipated route for this trip to the first entry in remaining_waypoints.
    /// If back_to_back or shared trips are enabled, the waypoint may belong to a
    /// different trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Type.LatLng> Route {
      get { return route_; }
    }

    /// <summary>Field number for the "current_route_segment_end_point" field.</summary>
    public const int CurrentRouteSegmentEndPointFieldNumber = 24;
    private global::Maps.Fleetengine.V1.TripWaypoint currentRouteSegmentEndPoint_;
    /// <summary>
    /// The waypoint where current_route_segment ends. This can be supplied by
    /// drivers on UpdateVehicle calls either as a full trip waypoint, a waypoint
    /// latlng, or as a the last latlng of the current_route_segment. FleetEngine
    /// will then do its best to interpolate to an actual waypoint if it is not
    /// fully specified. It will be returned in GetTrip calls. It is not respected
    /// in Create/Update Trip calls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TripWaypoint CurrentRouteSegmentEndPoint {
      get { return currentRouteSegmentEndPoint_; }
      set {
        currentRouteSegmentEndPoint_ = value;
      }
    }

    /// <summary>Field number for the "remaining_distance_meters" field.</summary>
    public const int RemainingDistanceMetersFieldNumber = 12;
    private static readonly pb::FieldCodec<int?> _single_remainingDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(98);
    private int? remainingDistanceMeters_;
    /// <summary>
    /// The remaining driving distance in Trip.current_route_segment field.
    /// This field facilitates journey sharing between a driver and rider and
    /// Fleet Engine does not update it. Your driver app is responsible for setting
    /// field on all of its current trips by passing
    /// Vehicle.remaining_distance_meters to an Vehicle.update call.
    /// The value is unspecified if the trip is not assigned to a vehicle, or the
    /// trip is inactive (completed or cancelled), or driver hasn't updated this
    /// value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? RemainingDistanceMeters {
      get { return remainingDistanceMeters_; }
      set {
        remainingDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "eta_to_first_waypoint" field.</summary>
    public const int EtaToFirstWaypointFieldNumber = 13;
    private global::Google.Protobuf.WellKnownTypes.Timestamp etaToFirstWaypoint_;
    /// <summary>
    /// Output only. The ETA to the next waypoint (the first entry in the
    /// Trip.remaining_waypoints field). This field facilitates journey sharing
    /// between a driver and a consumer. Fleet Engine does not update this value.
    /// Your driver app is responsible for setting this field by passing
    /// Vehicle.remaining_time_seconds in a call to Vehicle.update. FleetEngine
    /// converts the Vehicle.remaining_time_seconds to Trip.eta_to_first_waypoint,
    /// and returns it to the rider. The value is unspecified if the trip is not
    /// assigned to a vehicle, or the trip is inactive (completed or cancelled), or
    /// driver hasn't updated this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EtaToFirstWaypoint {
      get { return etaToFirstWaypoint_; }
      set {
        etaToFirstWaypoint_ = value;
      }
    }

    /// <summary>Field number for the "remaining_time_to_first_waypoint" field.</summary>
    public const int RemainingTimeToFirstWaypointFieldNumber = 27;
    private global::Google.Protobuf.WellKnownTypes.Duration remainingTimeToFirstWaypoint_;
    /// <summary>
    /// Output only. The duration from when the Trip data is returned to the time in
    /// Trip.eta_to_first_waypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration RemainingTimeToFirstWaypoint {
      get { return remainingTimeToFirstWaypoint_; }
      set {
        remainingTimeToFirstWaypoint_ = value;
      }
    }

    /// <summary>Field number for the "remaining_waypoints_version" field.</summary>
    public const int RemainingWaypointsVersionFieldNumber = 19;
    private global::Google.Protobuf.WellKnownTypes.Timestamp remainingWaypointsVersion_;
    /// <summary>
    /// Indicates the last time that `remaining_waypoints` was changed (a
    /// waypoint was added, removed, or changed).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp RemainingWaypointsVersion {
      get { return remainingWaypointsVersion_; }
      set {
        remainingWaypointsVersion_ = value;
      }
    }

    /// <summary>Field number for the "remaining_waypoints_route_version" field.</summary>
    public const int RemainingWaypointsRouteVersionFieldNumber = 29;
    private global::Google.Protobuf.WellKnownTypes.Timestamp remainingWaypointsRouteVersion_;
    /// <summary>
    /// Indicates the last time the remaining_waypoints.path_to_waypoint and
    /// remaining_waypoints.traffic_to_waypoint were modified. Your client app
    /// should cache this value and pass it in GetTripRequest to ensure the
    /// paths and traffic for remaining_waypoints are only returned if updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp RemainingWaypointsRouteVersion {
      get { return remainingWaypointsRouteVersion_; }
      set {
        remainingWaypointsRouteVersion_ = value;
      }
    }

    /// <summary>Field number for the "number_of_passengers" field.</summary>
    public const int NumberOfPassengersFieldNumber = 10;
    private int numberOfPassengers_;
    /// <summary>
    /// Indicates the number of passengers on this trip and does not include the
    /// driver. A vehicle must have available_capacity to be returned
    /// in SearchTrips.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumberOfPassengers {
      get { return numberOfPassengers_; }
      set {
        numberOfPassengers_ = value;
      }
    }

    /// <summary>Field number for the "last_location" field.</summary>
    public const int LastLocationFieldNumber = 11;
    private global::Maps.Fleetengine.V1.VehicleLocation lastLocation_;
    /// <summary>
    /// Indicates the last reported location of the vehicle along the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.VehicleLocation LastLocation {
      get { return lastLocation_; }
      set {
        lastLocation_ = value;
      }
    }

    /// <summary>Field number for the "last_location_snappable" field.</summary>
    public const int LastLocationSnappableFieldNumber = 26;
    private bool lastLocationSnappable_;
    /// <summary>
    /// Indicates whether the vehicle's last_location can be snapped to
    /// the current_route_segment. False if last_location or current_route_segment
    /// doesn't exist.
    /// It is computed by Fleet Engine. Any update from clients will be ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool LastLocationSnappable {
      get { return lastLocationSnappable_; }
      set {
        lastLocationSnappable_ = value;
      }
    }

    /// <summary>Field number for the "view" field.</summary>
    public const int ViewFieldNumber = 31;
    private global::Maps.Fleetengine.V1.TripView view_ = global::Maps.Fleetengine.V1.TripView.Unspecified;
    /// <summary>
    /// The subset of Trip fields that are populated and how they should be
    /// interpreted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TripView View {
      get { return view_; }
      set {
        view_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Trip);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Trip other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (VehicleId != other.VehicleId) return false;
      if (TripStatus != other.TripStatus) return false;
      if (TripType != other.TripType) return false;
      if (!object.Equals(PickupPoint, other.PickupPoint)) return false;
      if (!object.Equals(ActualPickupPoint, other.ActualPickupPoint)) return false;
      if (!object.Equals(ActualPickupArrivalPoint, other.ActualPickupArrivalPoint)) return false;
      if (!object.Equals(PickupTime, other.PickupTime)) return false;
      if(!intermediateDestinations_.Equals(other.intermediateDestinations_)) return false;
      if (!object.Equals(IntermediateDestinationsVersion, other.IntermediateDestinationsVersion)) return false;
      if (IntermediateDestinationIndex != other.IntermediateDestinationIndex) return false;
      if(!actualIntermediateDestinationArrivalPoints_.Equals(other.actualIntermediateDestinationArrivalPoints_)) return false;
      if(!actualIntermediateDestinations_.Equals(other.actualIntermediateDestinations_)) return false;
      if (!object.Equals(DropoffPoint, other.DropoffPoint)) return false;
      if (!object.Equals(ActualDropoffPoint, other.ActualDropoffPoint)) return false;
      if (!object.Equals(DropoffTime, other.DropoffTime)) return false;
      if(!remainingWaypoints_.Equals(other.remainingWaypoints_)) return false;
      if(!vehicleWaypoints_.Equals(other.vehicleWaypoints_)) return false;
      if(!route_.Equals(other.route_)) return false;
      if (!object.Equals(CurrentRouteSegmentEndPoint, other.CurrentRouteSegmentEndPoint)) return false;
      if (RemainingDistanceMeters != other.RemainingDistanceMeters) return false;
      if (!object.Equals(EtaToFirstWaypoint, other.EtaToFirstWaypoint)) return false;
      if (!object.Equals(RemainingTimeToFirstWaypoint, other.RemainingTimeToFirstWaypoint)) return false;
      if (!object.Equals(RemainingWaypointsVersion, other.RemainingWaypointsVersion)) return false;
      if (!object.Equals(RemainingWaypointsRouteVersion, other.RemainingWaypointsRouteVersion)) return false;
      if (NumberOfPassengers != other.NumberOfPassengers) return false;
      if (!object.Equals(LastLocation, other.LastLocation)) return false;
      if (LastLocationSnappable != other.LastLocationSnappable) return false;
      if (View != other.View) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (VehicleId.Length != 0) hash ^= VehicleId.GetHashCode();
      if (TripStatus != global::Maps.Fleetengine.V1.TripStatus.UnknownTripStatus) hash ^= TripStatus.GetHashCode();
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) hash ^= TripType.GetHashCode();
      if (pickupPoint_ != null) hash ^= PickupPoint.GetHashCode();
      if (actualPickupPoint_ != null) hash ^= ActualPickupPoint.GetHashCode();
      if (actualPickupArrivalPoint_ != null) hash ^= ActualPickupArrivalPoint.GetHashCode();
      if (pickupTime_ != null) hash ^= PickupTime.GetHashCode();
      hash ^= intermediateDestinations_.GetHashCode();
      if (intermediateDestinationsVersion_ != null) hash ^= IntermediateDestinationsVersion.GetHashCode();
      if (IntermediateDestinationIndex != 0) hash ^= IntermediateDestinationIndex.GetHashCode();
      hash ^= actualIntermediateDestinationArrivalPoints_.GetHashCode();
      hash ^= actualIntermediateDestinations_.GetHashCode();
      if (dropoffPoint_ != null) hash ^= DropoffPoint.GetHashCode();
      if (actualDropoffPoint_ != null) hash ^= ActualDropoffPoint.GetHashCode();
      if (dropoffTime_ != null) hash ^= DropoffTime.GetHashCode();
      hash ^= remainingWaypoints_.GetHashCode();
      hash ^= vehicleWaypoints_.GetHashCode();
      hash ^= route_.GetHashCode();
      if (currentRouteSegmentEndPoint_ != null) hash ^= CurrentRouteSegmentEndPoint.GetHashCode();
      if (remainingDistanceMeters_ != null) hash ^= RemainingDistanceMeters.GetHashCode();
      if (etaToFirstWaypoint_ != null) hash ^= EtaToFirstWaypoint.GetHashCode();
      if (remainingTimeToFirstWaypoint_ != null) hash ^= RemainingTimeToFirstWaypoint.GetHashCode();
      if (remainingWaypointsVersion_ != null) hash ^= RemainingWaypointsVersion.GetHashCode();
      if (remainingWaypointsRouteVersion_ != null) hash ^= RemainingWaypointsRouteVersion.GetHashCode();
      if (NumberOfPassengers != 0) hash ^= NumberOfPassengers.GetHashCode();
      if (lastLocation_ != null) hash ^= LastLocation.GetHashCode();
      if (LastLocationSnappable != false) hash ^= LastLocationSnappable.GetHashCode();
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) hash ^= View.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(VehicleId);
      }
      if (TripStatus != global::Maps.Fleetengine.V1.TripStatus.UnknownTripStatus) {
        output.WriteRawTag(24);
        output.WriteEnum((int) TripStatus);
      }
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        output.WriteRawTag(32);
        output.WriteEnum((int) TripType);
      }
      if (pickupPoint_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(PickupPoint);
      }
      if (pickupTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(PickupTime);
      }
      if (dropoffPoint_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DropoffPoint);
      }
      if (dropoffTime_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(DropoffTime);
      }
      route_.WriteTo(output, _repeated_route_codec);
      if (NumberOfPassengers != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(NumberOfPassengers);
      }
      if (lastLocation_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(LastLocation);
      }
      if (remainingDistanceMeters_ != null) {
        _single_remainingDistanceMeters_codec.WriteTagAndValue(output, RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(EtaToFirstWaypoint);
      }
      intermediateDestinations_.WriteTo(output, _repeated_intermediateDestinations_codec);
      if (IntermediateDestinationIndex != 0) {
        output.WriteRawTag(120);
        output.WriteInt32(IntermediateDestinationIndex);
      }
      remainingWaypoints_.WriteTo(output, _repeated_remainingWaypoints_codec);
      if (remainingWaypointsVersion_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(RemainingWaypointsVersion);
      }
      vehicleWaypoints_.WriteTo(output, _repeated_vehicleWaypoints_codec);
      if (actualPickupPoint_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(ActualPickupPoint);
      }
      if (actualDropoffPoint_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(ActualDropoffPoint);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(CurrentRouteSegmentEndPoint);
      }
      if (intermediateDestinationsVersion_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(IntermediateDestinationsVersion);
      }
      if (LastLocationSnappable != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(LastLocationSnappable);
      }
      if (remainingTimeToFirstWaypoint_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(RemainingTimeToFirstWaypoint);
      }
      if (remainingWaypointsRouteVersion_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(RemainingWaypointsRouteVersion);
      }
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        output.WriteRawTag(248, 1);
        output.WriteEnum((int) View);
      }
      if (actualPickupArrivalPoint_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(ActualPickupArrivalPoint);
      }
      actualIntermediateDestinationArrivalPoints_.WriteTo(output, _repeated_actualIntermediateDestinationArrivalPoints_codec);
      actualIntermediateDestinations_.WriteTo(output, _repeated_actualIntermediateDestinations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(VehicleId);
      }
      if (TripStatus != global::Maps.Fleetengine.V1.TripStatus.UnknownTripStatus) {
        output.WriteRawTag(24);
        output.WriteEnum((int) TripStatus);
      }
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        output.WriteRawTag(32);
        output.WriteEnum((int) TripType);
      }
      if (pickupPoint_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(PickupPoint);
      }
      if (pickupTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(PickupTime);
      }
      if (dropoffPoint_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DropoffPoint);
      }
      if (dropoffTime_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(DropoffTime);
      }
      route_.WriteTo(ref output, _repeated_route_codec);
      if (NumberOfPassengers != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(NumberOfPassengers);
      }
      if (lastLocation_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(LastLocation);
      }
      if (remainingDistanceMeters_ != null) {
        _single_remainingDistanceMeters_codec.WriteTagAndValue(ref output, RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(EtaToFirstWaypoint);
      }
      intermediateDestinations_.WriteTo(ref output, _repeated_intermediateDestinations_codec);
      if (IntermediateDestinationIndex != 0) {
        output.WriteRawTag(120);
        output.WriteInt32(IntermediateDestinationIndex);
      }
      remainingWaypoints_.WriteTo(ref output, _repeated_remainingWaypoints_codec);
      if (remainingWaypointsVersion_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(RemainingWaypointsVersion);
      }
      vehicleWaypoints_.WriteTo(ref output, _repeated_vehicleWaypoints_codec);
      if (actualPickupPoint_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(ActualPickupPoint);
      }
      if (actualDropoffPoint_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(ActualDropoffPoint);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(CurrentRouteSegmentEndPoint);
      }
      if (intermediateDestinationsVersion_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(IntermediateDestinationsVersion);
      }
      if (LastLocationSnappable != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(LastLocationSnappable);
      }
      if (remainingTimeToFirstWaypoint_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(RemainingTimeToFirstWaypoint);
      }
      if (remainingWaypointsRouteVersion_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(RemainingWaypointsRouteVersion);
      }
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        output.WriteRawTag(248, 1);
        output.WriteEnum((int) View);
      }
      if (actualPickupArrivalPoint_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(ActualPickupArrivalPoint);
      }
      actualIntermediateDestinationArrivalPoints_.WriteTo(ref output, _repeated_actualIntermediateDestinationArrivalPoints_codec);
      actualIntermediateDestinations_.WriteTo(ref output, _repeated_actualIntermediateDestinations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (VehicleId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VehicleId);
      }
      if (TripStatus != global::Maps.Fleetengine.V1.TripStatus.UnknownTripStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TripStatus);
      }
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TripType);
      }
      if (pickupPoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickupPoint);
      }
      if (actualPickupPoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ActualPickupPoint);
      }
      if (actualPickupArrivalPoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ActualPickupArrivalPoint);
      }
      if (pickupTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickupTime);
      }
      size += intermediateDestinations_.CalculateSize(_repeated_intermediateDestinations_codec);
      if (intermediateDestinationsVersion_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(IntermediateDestinationsVersion);
      }
      if (IntermediateDestinationIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(IntermediateDestinationIndex);
      }
      size += actualIntermediateDestinationArrivalPoints_.CalculateSize(_repeated_actualIntermediateDestinationArrivalPoints_codec);
      size += actualIntermediateDestinations_.CalculateSize(_repeated_actualIntermediateDestinations_codec);
      if (dropoffPoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DropoffPoint);
      }
      if (actualDropoffPoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ActualDropoffPoint);
      }
      if (dropoffTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DropoffTime);
      }
      size += remainingWaypoints_.CalculateSize(_repeated_remainingWaypoints_codec);
      size += vehicleWaypoints_.CalculateSize(_repeated_vehicleWaypoints_codec);
      size += route_.CalculateSize(_repeated_route_codec);
      if (currentRouteSegmentEndPoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentEndPoint);
      }
      if (remainingDistanceMeters_ != null) {
        size += _single_remainingDistanceMeters_codec.CalculateSizeWithTag(RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EtaToFirstWaypoint);
      }
      if (remainingTimeToFirstWaypoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RemainingTimeToFirstWaypoint);
      }
      if (remainingWaypointsVersion_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RemainingWaypointsVersion);
      }
      if (remainingWaypointsRouteVersion_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RemainingWaypointsRouteVersion);
      }
      if (NumberOfPassengers != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumberOfPassengers);
      }
      if (lastLocation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastLocation);
      }
      if (LastLocationSnappable != false) {
        size += 2 + 1;
      }
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) View);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Trip other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.VehicleId.Length != 0) {
        VehicleId = other.VehicleId;
      }
      if (other.TripStatus != global::Maps.Fleetengine.V1.TripStatus.UnknownTripStatus) {
        TripStatus = other.TripStatus;
      }
      if (other.TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        TripType = other.TripType;
      }
      if (other.pickupPoint_ != null) {
        if (pickupPoint_ == null) {
          PickupPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
        }
        PickupPoint.MergeFrom(other.PickupPoint);
      }
      if (other.actualPickupPoint_ != null) {
        if (actualPickupPoint_ == null) {
          ActualPickupPoint = new global::Maps.Fleetengine.V1.StopLocation();
        }
        ActualPickupPoint.MergeFrom(other.ActualPickupPoint);
      }
      if (other.actualPickupArrivalPoint_ != null) {
        if (actualPickupArrivalPoint_ == null) {
          ActualPickupArrivalPoint = new global::Maps.Fleetengine.V1.StopLocation();
        }
        ActualPickupArrivalPoint.MergeFrom(other.ActualPickupArrivalPoint);
      }
      if (other.pickupTime_ != null) {
        if (pickupTime_ == null) {
          PickupTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        PickupTime.MergeFrom(other.PickupTime);
      }
      intermediateDestinations_.Add(other.intermediateDestinations_);
      if (other.intermediateDestinationsVersion_ != null) {
        if (intermediateDestinationsVersion_ == null) {
          IntermediateDestinationsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        IntermediateDestinationsVersion.MergeFrom(other.IntermediateDestinationsVersion);
      }
      if (other.IntermediateDestinationIndex != 0) {
        IntermediateDestinationIndex = other.IntermediateDestinationIndex;
      }
      actualIntermediateDestinationArrivalPoints_.Add(other.actualIntermediateDestinationArrivalPoints_);
      actualIntermediateDestinations_.Add(other.actualIntermediateDestinations_);
      if (other.dropoffPoint_ != null) {
        if (dropoffPoint_ == null) {
          DropoffPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
        }
        DropoffPoint.MergeFrom(other.DropoffPoint);
      }
      if (other.actualDropoffPoint_ != null) {
        if (actualDropoffPoint_ == null) {
          ActualDropoffPoint = new global::Maps.Fleetengine.V1.StopLocation();
        }
        ActualDropoffPoint.MergeFrom(other.ActualDropoffPoint);
      }
      if (other.dropoffTime_ != null) {
        if (dropoffTime_ == null) {
          DropoffTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        DropoffTime.MergeFrom(other.DropoffTime);
      }
      remainingWaypoints_.Add(other.remainingWaypoints_);
      vehicleWaypoints_.Add(other.vehicleWaypoints_);
      route_.Add(other.route_);
      if (other.currentRouteSegmentEndPoint_ != null) {
        if (currentRouteSegmentEndPoint_ == null) {
          CurrentRouteSegmentEndPoint = new global::Maps.Fleetengine.V1.TripWaypoint();
        }
        CurrentRouteSegmentEndPoint.MergeFrom(other.CurrentRouteSegmentEndPoint);
      }
      if (other.remainingDistanceMeters_ != null) {
        if (remainingDistanceMeters_ == null || other.RemainingDistanceMeters != 0) {
          RemainingDistanceMeters = other.RemainingDistanceMeters;
        }
      }
      if (other.etaToFirstWaypoint_ != null) {
        if (etaToFirstWaypoint_ == null) {
          EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EtaToFirstWaypoint.MergeFrom(other.EtaToFirstWaypoint);
      }
      if (other.remainingTimeToFirstWaypoint_ != null) {
        if (remainingTimeToFirstWaypoint_ == null) {
          RemainingTimeToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RemainingTimeToFirstWaypoint.MergeFrom(other.RemainingTimeToFirstWaypoint);
      }
      if (other.remainingWaypointsVersion_ != null) {
        if (remainingWaypointsVersion_ == null) {
          RemainingWaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        RemainingWaypointsVersion.MergeFrom(other.RemainingWaypointsVersion);
      }
      if (other.remainingWaypointsRouteVersion_ != null) {
        if (remainingWaypointsRouteVersion_ == null) {
          RemainingWaypointsRouteVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        RemainingWaypointsRouteVersion.MergeFrom(other.RemainingWaypointsRouteVersion);
      }
      if (other.NumberOfPassengers != 0) {
        NumberOfPassengers = other.NumberOfPassengers;
      }
      if (other.lastLocation_ != null) {
        if (lastLocation_ == null) {
          LastLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
        }
        LastLocation.MergeFrom(other.LastLocation);
      }
      if (other.LastLocationSnappable != false) {
        LastLocationSnappable = other.LastLocationSnappable;
      }
      if (other.View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        View = other.View;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            VehicleId = input.ReadString();
            break;
          }
          case 24: {
            TripStatus = (global::Maps.Fleetengine.V1.TripStatus) input.ReadEnum();
            break;
          }
          case 32: {
            TripType = (global::Maps.Fleetengine.V1.TripType) input.ReadEnum();
            break;
          }
          case 42: {
            if (pickupPoint_ == null) {
              PickupPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(PickupPoint);
            break;
          }
          case 50: {
            if (pickupTime_ == null) {
              PickupTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(PickupTime);
            break;
          }
          case 58: {
            if (dropoffPoint_ == null) {
              DropoffPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(DropoffPoint);
            break;
          }
          case 66: {
            if (dropoffTime_ == null) {
              DropoffTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(DropoffTime);
            break;
          }
          case 74: {
            route_.AddEntriesFrom(input, _repeated_route_codec);
            break;
          }
          case 80: {
            NumberOfPassengers = input.ReadInt32();
            break;
          }
          case 90: {
            if (lastLocation_ == null) {
              LastLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
            }
            input.ReadMessage(LastLocation);
            break;
          }
          case 98: {
            int? value = _single_remainingDistanceMeters_codec.Read(input);
            if (remainingDistanceMeters_ == null || value != 0) {
              RemainingDistanceMeters = value;
            }
            break;
          }
          case 106: {
            if (etaToFirstWaypoint_ == null) {
              EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EtaToFirstWaypoint);
            break;
          }
          case 114: {
            intermediateDestinations_.AddEntriesFrom(input, _repeated_intermediateDestinations_codec);
            break;
          }
          case 120: {
            IntermediateDestinationIndex = input.ReadInt32();
            break;
          }
          case 130: {
            remainingWaypoints_.AddEntriesFrom(input, _repeated_remainingWaypoints_codec);
            break;
          }
          case 154: {
            if (remainingWaypointsVersion_ == null) {
              RemainingWaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RemainingWaypointsVersion);
            break;
          }
          case 162: {
            vehicleWaypoints_.AddEntriesFrom(input, _repeated_vehicleWaypoints_codec);
            break;
          }
          case 178: {
            if (actualPickupPoint_ == null) {
              ActualPickupPoint = new global::Maps.Fleetengine.V1.StopLocation();
            }
            input.ReadMessage(ActualPickupPoint);
            break;
          }
          case 186: {
            if (actualDropoffPoint_ == null) {
              ActualDropoffPoint = new global::Maps.Fleetengine.V1.StopLocation();
            }
            input.ReadMessage(ActualDropoffPoint);
            break;
          }
          case 194: {
            if (currentRouteSegmentEndPoint_ == null) {
              CurrentRouteSegmentEndPoint = new global::Maps.Fleetengine.V1.TripWaypoint();
            }
            input.ReadMessage(CurrentRouteSegmentEndPoint);
            break;
          }
          case 202: {
            if (intermediateDestinationsVersion_ == null) {
              IntermediateDestinationsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(IntermediateDestinationsVersion);
            break;
          }
          case 208: {
            LastLocationSnappable = input.ReadBool();
            break;
          }
          case 218: {
            if (remainingTimeToFirstWaypoint_ == null) {
              RemainingTimeToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RemainingTimeToFirstWaypoint);
            break;
          }
          case 234: {
            if (remainingWaypointsRouteVersion_ == null) {
              RemainingWaypointsRouteVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RemainingWaypointsRouteVersion);
            break;
          }
          case 248: {
            View = (global::Maps.Fleetengine.V1.TripView) input.ReadEnum();
            break;
          }
          case 258: {
            if (actualPickupArrivalPoint_ == null) {
              ActualPickupArrivalPoint = new global::Maps.Fleetengine.V1.StopLocation();
            }
            input.ReadMessage(ActualPickupArrivalPoint);
            break;
          }
          case 266: {
            actualIntermediateDestinationArrivalPoints_.AddEntriesFrom(input, _repeated_actualIntermediateDestinationArrivalPoints_codec);
            break;
          }
          case 274: {
            actualIntermediateDestinations_.AddEntriesFrom(input, _repeated_actualIntermediateDestinations_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            VehicleId = input.ReadString();
            break;
          }
          case 24: {
            TripStatus = (global::Maps.Fleetengine.V1.TripStatus) input.ReadEnum();
            break;
          }
          case 32: {
            TripType = (global::Maps.Fleetengine.V1.TripType) input.ReadEnum();
            break;
          }
          case 42: {
            if (pickupPoint_ == null) {
              PickupPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(PickupPoint);
            break;
          }
          case 50: {
            if (pickupTime_ == null) {
              PickupTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(PickupTime);
            break;
          }
          case 58: {
            if (dropoffPoint_ == null) {
              DropoffPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(DropoffPoint);
            break;
          }
          case 66: {
            if (dropoffTime_ == null) {
              DropoffTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(DropoffTime);
            break;
          }
          case 74: {
            route_.AddEntriesFrom(ref input, _repeated_route_codec);
            break;
          }
          case 80: {
            NumberOfPassengers = input.ReadInt32();
            break;
          }
          case 90: {
            if (lastLocation_ == null) {
              LastLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
            }
            input.ReadMessage(LastLocation);
            break;
          }
          case 98: {
            int? value = _single_remainingDistanceMeters_codec.Read(ref input);
            if (remainingDistanceMeters_ == null || value != 0) {
              RemainingDistanceMeters = value;
            }
            break;
          }
          case 106: {
            if (etaToFirstWaypoint_ == null) {
              EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EtaToFirstWaypoint);
            break;
          }
          case 114: {
            intermediateDestinations_.AddEntriesFrom(ref input, _repeated_intermediateDestinations_codec);
            break;
          }
          case 120: {
            IntermediateDestinationIndex = input.ReadInt32();
            break;
          }
          case 130: {
            remainingWaypoints_.AddEntriesFrom(ref input, _repeated_remainingWaypoints_codec);
            break;
          }
          case 154: {
            if (remainingWaypointsVersion_ == null) {
              RemainingWaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RemainingWaypointsVersion);
            break;
          }
          case 162: {
            vehicleWaypoints_.AddEntriesFrom(ref input, _repeated_vehicleWaypoints_codec);
            break;
          }
          case 178: {
            if (actualPickupPoint_ == null) {
              ActualPickupPoint = new global::Maps.Fleetengine.V1.StopLocation();
            }
            input.ReadMessage(ActualPickupPoint);
            break;
          }
          case 186: {
            if (actualDropoffPoint_ == null) {
              ActualDropoffPoint = new global::Maps.Fleetengine.V1.StopLocation();
            }
            input.ReadMessage(ActualDropoffPoint);
            break;
          }
          case 194: {
            if (currentRouteSegmentEndPoint_ == null) {
              CurrentRouteSegmentEndPoint = new global::Maps.Fleetengine.V1.TripWaypoint();
            }
            input.ReadMessage(CurrentRouteSegmentEndPoint);
            break;
          }
          case 202: {
            if (intermediateDestinationsVersion_ == null) {
              IntermediateDestinationsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(IntermediateDestinationsVersion);
            break;
          }
          case 208: {
            LastLocationSnappable = input.ReadBool();
            break;
          }
          case 218: {
            if (remainingTimeToFirstWaypoint_ == null) {
              RemainingTimeToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RemainingTimeToFirstWaypoint);
            break;
          }
          case 234: {
            if (remainingWaypointsRouteVersion_ == null) {
              RemainingWaypointsRouteVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RemainingWaypointsRouteVersion);
            break;
          }
          case 248: {
            View = (global::Maps.Fleetengine.V1.TripView) input.ReadEnum();
            break;
          }
          case 258: {
            if (actualPickupArrivalPoint_ == null) {
              ActualPickupArrivalPoint = new global::Maps.Fleetengine.V1.StopLocation();
            }
            input.ReadMessage(ActualPickupArrivalPoint);
            break;
          }
          case 266: {
            actualIntermediateDestinationArrivalPoints_.AddEntriesFrom(ref input, _repeated_actualIntermediateDestinationArrivalPoints_codec);
            break;
          }
          case 274: {
            actualIntermediateDestinations_.AddEntriesFrom(ref input, _repeated_actualIntermediateDestinations_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The actual location where a stop (pickup/dropoff) happened.
  /// </summary>
  public sealed partial class StopLocation : pb::IMessage<StopLocation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StopLocation> _parser = new pb::MessageParser<StopLocation>(() => new StopLocation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StopLocation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopLocation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopLocation(StopLocation other) : this() {
      point_ = other.point_ != null ? other.point_.Clone() : null;
      timestamp_ = other.timestamp_ != null ? other.timestamp_.Clone() : null;
      stopTime_ = other.stopTime_ != null ? other.stopTime_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopLocation Clone() {
      return new StopLocation(this);
    }

    /// <summary>Field number for the "point" field.</summary>
    public const int PointFieldNumber = 1;
    private global::Google.Type.LatLng point_;
    /// <summary>
    /// Required. Denotes the actual location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng Point {
      get { return point_; }
      set {
        point_ = value;
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp timestamp_;
    /// <summary>
    /// The timestamp when the location was measured.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "stop_time" field.</summary>
    public const int StopTimeFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp stopTime_;
    /// <summary>
    /// Indicates when the stop actually happened.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp StopTime {
      get { return stopTime_; }
      set {
        stopTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StopLocation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StopLocation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Point, other.Point)) return false;
      if (!object.Equals(Timestamp, other.Timestamp)) return false;
      if (!object.Equals(StopTime, other.StopTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (point_ != null) hash ^= Point.GetHashCode();
      if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
      if (stopTime_ != null) hash ^= StopTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (point_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Point);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      if (stopTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(StopTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (point_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Point);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      if (stopTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(StopTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (point_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Point);
      }
      if (timestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
      }
      if (stopTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StopTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StopLocation other) {
      if (other == null) {
        return;
      }
      if (other.point_ != null) {
        if (point_ == null) {
          Point = new global::Google.Type.LatLng();
        }
        Point.MergeFrom(other.Point);
      }
      if (other.timestamp_ != null) {
        if (timestamp_ == null) {
          Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Timestamp.MergeFrom(other.Timestamp);
      }
      if (other.stopTime_ != null) {
        if (stopTime_ == null) {
          StopTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        StopTime.MergeFrom(other.StopTime);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (point_ == null) {
              Point = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Point);
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 26: {
            if (stopTime_ == null) {
              StopTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(StopTime);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (point_ == null) {
              Point = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Point);
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 26: {
            if (stopTime_ == null) {
              StopTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(StopTime);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
