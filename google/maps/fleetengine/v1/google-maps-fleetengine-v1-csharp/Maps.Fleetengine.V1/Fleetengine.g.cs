// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/fleetengine/v1/fleetengine.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Maps.Fleetengine.V1 {

  /// <summary>Holder for reflection information generated from google/maps/fleetengine/v1/fleetengine.proto</summary>
  public static partial class FleetengineReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/fleetengine/v1/fleetengine.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static FleetengineReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cixnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS9mbGVldGVuZ2luZS5wcm90",
            "bxITbWFwcy5mbGVldGVuZ2luZS52MRofZ29vZ2xlL2FwaS9maWVsZF9iZWhh",
            "dmlvci5wcm90bxoZZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90bxoeZ29vZ2xl",
            "L3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh9nb29nbGUvcHJvdG9idWYvdGlt",
            "ZXN0YW1wLnByb3RvGh5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8a",
            "GGdvb2dsZS90eXBlL2xhdGxuZy5wcm90byJaCg9UZXJtaW5hbFBvaW50SWQS",
            "FgoIcGxhY2VfaWQYAiABKAlCAhgBSAASGgoMZ2VuZXJhdGVkX2lkGAMgASgJ",
            "QgIYAUgAEg0KBXZhbHVlGAQgASgJQgQKAklkIvoBChBUZXJtaW5hbExvY2F0",
            "aW9uEicKBXBvaW50GAEgASgLMhMuZ29vZ2xlLnR5cGUuTGF0TG5nQgPgQQIS",
            "RAoRdGVybWluYWxfcG9pbnRfaWQYAiABKAsyJC5tYXBzLmZsZWV0ZW5naW5l",
            "LnYxLlRlcm1pbmFsUG9pbnRJZEID4EECEhsKD2FjY2Vzc19wb2ludF9pZBgD",
            "IAEoCUICGAESEwoHdHJpcF9pZBgEIAEoCUICGAESRQoWdGVybWluYWxfbG9j",
            "YXRpb25fdHlwZRgFIAEoDjIhLm1hcHMuZmxlZXRlbmdpbmUudjEuV2F5cG9p",
            "bnRUeXBlQgIYASLNAgoMVHJpcFdheXBvaW50EjcKCGxvY2F0aW9uGAEgASgL",
            "MiUubWFwcy5mbGVldGVuZ2luZS52MS5UZXJtaW5hbExvY2F0aW9uEg8KB3Ry",
            "aXBfaWQYAiABKAkSOAoNd2F5cG9pbnRfdHlwZRgDIAEoDjIhLm1hcHMuZmxl",
            "ZXRlbmdpbmUudjEuV2F5cG9pbnRUeXBlEi0KEHBhdGhfdG9fd2F5cG9pbnQY",
            "BCADKAsyEy5nb29nbGUudHlwZS5MYXRMbmcSNAoPZGlzdGFuY2VfbWV0ZXJz",
            "GAYgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUSJwoDZXRhGAcg",
            "ASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIrCghkdXJhdGlvbhgI",
            "IAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiKuAQoGU3RhdHVzEi4K",
            "BGNvZGUYASABKA4yIC5tYXBzLmZsZWV0ZW5naW5lLnYxLlN0YXR1cy5Db2Rl",
            "Eg8KB21lc3NhZ2UYAiABKAkSJQoHZGV0YWlscxgDIAMoCzIULmdvb2dsZS5w",
            "cm90b2J1Zi5BbnkiPAoEQ29kZRIPCgtVTlNQRUNJRklFRBAAEgsKB0ZBSUxV",
            "UkUQARIWChJST1VURV9OT1RfUE9TU0lCTEUQAiIhChBGb3JtYXR0ZWRBZGRy",
            "ZXNzEg0KBWxpbmVzGAEgAygJIksKB0FkZHJlc3MSQAoRZm9ybWF0dGVkX2Fk",
            "ZHJlc3MYASABKAsyJS5tYXBzLmZsZWV0ZW5naW5lLnYxLkZvcm1hdHRlZEFk",
            "ZHJlc3MiLgoQVmVoaWNsZUF0dHJpYnV0ZRILCgNrZXkYASABKAkSDQoFdmFs",
            "dWUYAiABKAkixQwKD1ZlaGljbGVMb2NhdGlvbhIlCghsb2NhdGlvbhgBIAEo",
            "CzITLmdvb2dsZS50eXBlLkxhdExuZxI9ChNob3Jpem9udGFsX2FjY3VyYWN5",
            "GAggASgLMhwuZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlQgIYARI1Cg9s",
            "YXRsbmdfYWNjdXJhY3kYFiABKAsyHC5nb29nbGUucHJvdG9idWYuRG91Ymxl",
            "VmFsdWUSLAoHaGVhZGluZxgCIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQz",
            "MlZhbHVlEjoKEGJlYXJpbmdfYWNjdXJhY3kYCiABKAsyHC5nb29nbGUucHJv",
            "dG9idWYuRG91YmxlVmFsdWVCAhgBEjYKEGhlYWRpbmdfYWNjdXJhY3kYFyAB",
            "KAsyHC5nb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUSLgoIYWx0aXR1ZGUY",
            "BSABKAsyHC5nb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUSOwoRdmVydGlj",
            "YWxfYWNjdXJhY3kYCSABKAsyHC5nb29nbGUucHJvdG9idWYuRG91YmxlVmFs",
            "dWVCAhgBEjcKEWFsdGl0dWRlX2FjY3VyYWN5GBggASgLMhwuZ29vZ2xlLnBy",
            "b3RvYnVmLkRvdWJsZVZhbHVlEjMKCnNwZWVkX2ttcGgYAyABKAsyGy5nb29n",
            "bGUucHJvdG9idWYuSW50MzJWYWx1ZUICGAESKwoFc3BlZWQYBiABKAsyHC5n",
            "b29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUSNAoOc3BlZWRfYWNjdXJhY3kY",
            "ByABKAsyHC5nb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUSLwoLdXBkYXRl",
            "X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjQKC3Nl",
            "cnZlcl90aW1lGA0gASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID",
            "4EEDEjwKD2xvY2F0aW9uX3NlbnNvchgLIAEoDjIjLm1hcHMuZmxlZXRlbmdp",
            "bmUudjEuTG9jYXRpb25TZW5zb3ISMwoPaXNfcm9hZF9zbmFwcGVkGBsgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRI+ChVpc19ncHNfc2Vuc29y",
            "X2VuYWJsZWQYDCABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlQgPg",
            "QQQSOwoRdGltZV9zaW5jZV91cGRhdGUYDiABKAsyGy5nb29nbGUucHJvdG9i",
            "dWYuSW50MzJWYWx1ZUID4EEEEjsKEW51bV9zdGFsZV91cGRhdGVzGA8gASgL",
            "MhsuZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVCA+BBBBIpCgxyYXdfbG9j",
            "YXRpb24YECABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcSOgoRcmF3X2xvY2F0",
            "aW9uX3RpbWUYESABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPg",
            "QQQSRQoTcmF3X2xvY2F0aW9uX3NlbnNvchgcIAEoDjIjLm1hcHMuZmxlZXRl",
            "bmdpbmUudjEuTG9jYXRpb25TZW5zb3JCA+BBBBJAChVyYXdfbG9jYXRpb25f",
            "YWNjdXJhY3kYGSABKAsyHC5nb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVC",
            "A+BBBBI3ChVzdXBwbGVtZW50YWxfbG9jYXRpb24YEiABKAsyEy5nb29nbGUu",
            "dHlwZS5MYXRMbmdCA+BBBBJDChpzdXBwbGVtZW50YWxfbG9jYXRpb25fdGlt",
            "ZRgTIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBBBJOChxz",
            "dXBwbGVtZW50YWxfbG9jYXRpb25fc2Vuc29yGBQgASgOMiMubWFwcy5mbGVl",
            "dGVuZ2luZS52MS5Mb2NhdGlvblNlbnNvckID4EEEEkkKHnN1cHBsZW1lbnRh",
            "bF9sb2NhdGlvbl9hY2N1cmFjeRgVIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5E",
            "b3VibGVWYWx1ZUID4EEEEhgKDHJvYWRfc25hcHBlZBgaIAEoCEICGAEqPAoI",
            "VHJpcFR5cGUSFQoRVU5LTk9XTl9UUklQX1RZUEUQABIKCgZTSEFSRUQQARIN",
            "CglFWENMVVNJVkUQAiqLAQoMV2F5cG9pbnRUeXBlEhkKFVVOS05PV05fV0FZ",
            "UE9JTlRfVFlQRRAAEhgKFFBJQ0tVUF9XQVlQT0lOVF9UWVBFEAESGgoWRFJP",
            "UF9PRkZfV0FZUE9JTlRfVFlQRRACEioKJklOVEVSTUVESUFURV9ERVNUSU5B",
            "VElPTl9XQVlQT0lOVF9UWVBFEAMqXwoSUG9seWxpbmVGb3JtYXRUeXBlEhcK",
            "E1VOS05PV05fRk9STUFUX1RZUEUQABIVChFMQVRfTE5HX0xJU1RfVFlQRRAB",
            "EhkKFUVOQ09ERURfUE9MWUxJTkVfVFlQRRACKokBChBOYXZpZ2F0aW9uU3Rh",
            "dHVzEh0KGVVOS05PV05fTkFWSUdBVElPTl9TVEFUVVMQABIPCgtOT19HVUlE",
            "QU5DRRABEhoKFkVOUk9VVEVfVE9fREVTVElOQVRJT04QAhINCglPRkZfUk9V",
            "VEUQAxIaChZBUlJJVkVEX0FUX0RFU1RJTkFUSU9OEAQqiAEKDkxvY2F0aW9u",
            "U2Vuc29yEhIKDlVOS05PV05fU0VOU09SEAASBwoDR1BTEAESCwoHTkVUV09S",
            "SxACEgsKB1BBU1NJVkUQAxIiCh5ST0FEX1NOQVBQRURfTE9DQVRJT05fUFJP",
            "VklERVIQBBIbChdGVVNFRF9MT0NBVElPTl9QUk9WSURFUhBkQngKGmdvb2ds",
            "ZS5tYXBzLmZsZWV0ZW5naW5lLnYxQgtGbGVldEVuZ2luZVABWkVnb29nbGUu",
            "Z29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL21hcHMvZmxlZXRlbmdp",
            "bmUvdjE7ZmxlZXRlbmdpbmWiAgNDRkViBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Type.LatlngReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Maps.Fleetengine.V1.TripType), typeof(global::Maps.Fleetengine.V1.WaypointType), typeof(global::Maps.Fleetengine.V1.PolylineFormatType), typeof(global::Maps.Fleetengine.V1.NavigationStatus), typeof(global::Maps.Fleetengine.V1.LocationSensor), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.TerminalPointId), global::Maps.Fleetengine.V1.TerminalPointId.Parser, new[]{ "PlaceId", "GeneratedId", "Value" }, new[]{ "Id" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.TerminalLocation), global::Maps.Fleetengine.V1.TerminalLocation.Parser, new[]{ "Point", "TerminalPointId", "AccessPointId", "TripId", "TerminalLocationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.TripWaypoint), global::Maps.Fleetengine.V1.TripWaypoint.Parser, new[]{ "Location", "TripId", "WaypointType", "PathToWaypoint", "DistanceMeters", "Eta", "Duration" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.Status), global::Maps.Fleetengine.V1.Status.Parser, new[]{ "Code", "Message", "Details" }, null, new[]{ typeof(global::Maps.Fleetengine.V1.Status.Types.Code) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.FormattedAddress), global::Maps.Fleetengine.V1.FormattedAddress.Parser, new[]{ "Lines" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.Address), global::Maps.Fleetengine.V1.Address.Parser, new[]{ "FormattedAddress" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.VehicleAttribute), global::Maps.Fleetengine.V1.VehicleAttribute.Parser, new[]{ "Key", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.VehicleLocation), global::Maps.Fleetengine.V1.VehicleLocation.Parser, new[]{ "Location", "HorizontalAccuracy", "LatlngAccuracy", "Heading", "BearingAccuracy", "HeadingAccuracy", "Altitude", "VerticalAccuracy", "AltitudeAccuracy", "SpeedKmph", "Speed", "SpeedAccuracy", "UpdateTime", "ServerTime", "LocationSensor", "IsRoadSnapped", "IsGpsSensorEnabled", "TimeSinceUpdate", "NumStaleUpdates", "RawLocation", "RawLocationTime", "RawLocationSensor", "RawLocationAccuracy", "SupplementalLocation", "SupplementalLocationTime", "SupplementalLocationSensor", "SupplementalLocationAccuracy", "RoadSnapped" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// The type of a trip.
  /// </summary>
  public enum TripType {
    /// <summary>
    /// Default, used for unspecified or unrecognized trip types.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_TRIP_TYPE")] UnknownTripType = 0,
    /// <summary>
    /// The trip may share a vehicle with other trips.
    /// </summary>
    [pbr::OriginalName("SHARED")] Shared = 1,
    /// <summary>
    /// The trip is exclusive to a vehicle.
    /// </summary>
    [pbr::OriginalName("EXCLUSIVE")] Exclusive = 2,
  }

  /// <summary>
  /// The type of waypoint.
  /// </summary>
  public enum WaypointType {
    /// <summary>
    /// Default, unknown waypoint type
    /// </summary>
    [pbr::OriginalName("UNKNOWN_WAYPOINT_TYPE")] UnknownWaypointType = 0,
    /// <summary>
    /// Waypoints for picking up customers or merchandise.
    /// </summary>
    [pbr::OriginalName("PICKUP_WAYPOINT_TYPE")] PickupWaypointType = 1,
    /// <summary>
    /// Waypoints for dropping off customers or merchandise.
    /// </summary>
    [pbr::OriginalName("DROP_OFF_WAYPOINT_TYPE")] DropOffWaypointType = 2,
    /// <summary>
    /// Waypoints for intermediate destinations in a multi-destination trip.
    /// </summary>
    [pbr::OriginalName("INTERMEDIATE_DESTINATION_WAYPOINT_TYPE")] IntermediateDestinationWaypointType = 3,
  }

  /// <summary>
  /// The type of polyline format.
  /// </summary>
  public enum PolylineFormatType {
    /// <summary>
    /// Unspecified format type.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_FORMAT_TYPE")] UnknownFormatType = 0,
    /// <summary>
    /// Repeated LatLng.
    /// </summary>
    [pbr::OriginalName("LAT_LNG_LIST_TYPE")] LatLngListType = 1,
    /// <summary>
    /// A polyline encoded with a polyline compression algorithm. Decoding is not
    /// yet supported.
    /// </summary>
    [pbr::OriginalName("ENCODED_POLYLINE_TYPE")] EncodedPolylineType = 2,
  }

  /// <summary>
  /// A set of values that specify the vehicle's navigation status.
  /// </summary>
  public enum NavigationStatus {
    /// <summary>
    /// Unspecified navigation status.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_NAVIGATION_STATUS")] UnknownNavigationStatus = 0,
    /// <summary>
    /// The Driver app's navigation is in FREE_NAV mode.
    /// </summary>
    [pbr::OriginalName("NO_GUIDANCE")] NoGuidance = 1,
    /// <summary>
    /// Turn-by-turn navigation starts and the Driver app navigation enters
    /// GUIDED_NAV mode showing the green header, route, and destination marker.
    /// </summary>
    [pbr::OriginalName("ENROUTE_TO_DESTINATION")] EnrouteToDestination = 2,
    /// <summary>
    /// Vehicle has gone off the suggested route.
    /// </summary>
    [pbr::OriginalName("OFF_ROUTE")] OffRoute = 3,
    /// <summary>
    /// The vehicle is within 50m of the destination and onArrival was
    /// automatically triggered.
    /// </summary>
    [pbr::OriginalName("ARRIVED_AT_DESTINATION")] ArrivedAtDestination = 4,
  }

  /// <summary>
  /// Possible location providers.
  /// </summary>
  public enum LocationSensor {
    /// <summary>
    /// Undefined sensor.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_SENSOR")] UnknownSensor = 0,
    /// <summary>
    /// Sensors: (GPS, AGPS).
    /// </summary>
    [pbr::OriginalName("GPS")] Gps = 1,
    /// <summary>
    /// Sensors: (AGPS, CellID, WiFi MACID).
    /// </summary>
    [pbr::OriginalName("NETWORK")] Network = 2,
    /// <summary>
    /// Sensors: (CellID, WiFi MACID).
    /// </summary>
    [pbr::OriginalName("PASSIVE")] Passive = 3,
    /// <summary>
    /// GMM's road snapped (gmfc) location.
    /// </summary>
    [pbr::OriginalName("ROAD_SNAPPED_LOCATION_PROVIDER")] RoadSnappedLocationProvider = 4,
    /// <summary>
    /// Unspecified, but generated by the Fused Location Provider.
    /// </summary>
    [pbr::OriginalName("FUSED_LOCATION_PROVIDER")] FusedLocationProvider = 100,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Identifies a terminal point.
  /// </summary>
  public sealed partial class TerminalPointId : pb::IMessage<TerminalPointId>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TerminalPointId> _parser = new pb::MessageParser<TerminalPointId>(() => new TerminalPointId());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TerminalPointId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TerminalPointId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TerminalPointId(TerminalPointId other) : this() {
      value_ = other.value_;
      switch (other.IdCase) {
        case IdOneofCase.PlaceId:
          PlaceId = other.PlaceId;
          break;
        case IdOneofCase.GeneratedId:
          GeneratedId = other.GeneratedId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TerminalPointId Clone() {
      return new TerminalPointId(this);
    }

    /// <summary>Field number for the "place_id" field.</summary>
    public const int PlaceIdFieldNumber = 2;
    /// <summary>
    /// Deprecated.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PlaceId {
      get { return idCase_ == IdOneofCase.PlaceId ? (string) id_ : ""; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        idCase_ = IdOneofCase.PlaceId;
      }
    }

    /// <summary>Field number for the "generated_id" field.</summary>
    public const int GeneratedIdFieldNumber = 3;
    /// <summary>
    /// Deprecated.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GeneratedId {
      get { return idCase_ == IdOneofCase.GeneratedId ? (string) id_ : ""; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        idCase_ = IdOneofCase.GeneratedId;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 4;
    private string value_ = "";
    /// <summary>
    /// Unique ID of the terminal point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object id_;
    /// <summary>Enum of possible cases for the "Id" oneof.</summary>
    public enum IdOneofCase {
      None = 0,
      PlaceId = 2,
      GeneratedId = 3,
    }
    private IdOneofCase idCase_ = IdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IdOneofCase IdCase {
      get { return idCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      idCase_ = IdOneofCase.None;
      id_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TerminalPointId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TerminalPointId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PlaceId != other.PlaceId) return false;
      if (GeneratedId != other.GeneratedId) return false;
      if (Value != other.Value) return false;
      if (IdCase != other.IdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (idCase_ == IdOneofCase.PlaceId) hash ^= PlaceId.GetHashCode();
      if (idCase_ == IdOneofCase.GeneratedId) hash ^= GeneratedId.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      hash ^= (int) idCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (idCase_ == IdOneofCase.PlaceId) {
        output.WriteRawTag(18);
        output.WriteString(PlaceId);
      }
      if (idCase_ == IdOneofCase.GeneratedId) {
        output.WriteRawTag(26);
        output.WriteString(GeneratedId);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (idCase_ == IdOneofCase.PlaceId) {
        output.WriteRawTag(18);
        output.WriteString(PlaceId);
      }
      if (idCase_ == IdOneofCase.GeneratedId) {
        output.WriteRawTag(26);
        output.WriteString(GeneratedId);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (idCase_ == IdOneofCase.PlaceId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PlaceId);
      }
      if (idCase_ == IdOneofCase.GeneratedId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GeneratedId);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TerminalPointId other) {
      if (other == null) {
        return;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      switch (other.IdCase) {
        case IdOneofCase.PlaceId:
          PlaceId = other.PlaceId;
          break;
        case IdOneofCase.GeneratedId:
          GeneratedId = other.GeneratedId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            PlaceId = input.ReadString();
            break;
          }
          case 26: {
            GeneratedId = input.ReadString();
            break;
          }
          case 34: {
            Value = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            PlaceId = input.ReadString();
            break;
          }
          case 26: {
            GeneratedId = input.ReadString();
            break;
          }
          case 34: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes the location of a pickup or dropoff.
  /// </summary>
  public sealed partial class TerminalLocation : pb::IMessage<TerminalLocation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TerminalLocation> _parser = new pb::MessageParser<TerminalLocation>(() => new TerminalLocation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TerminalLocation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TerminalLocation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TerminalLocation(TerminalLocation other) : this() {
      point_ = other.point_ != null ? other.point_.Clone() : null;
      terminalPointId_ = other.terminalPointId_ != null ? other.terminalPointId_.Clone() : null;
      accessPointId_ = other.accessPointId_;
      tripId_ = other.tripId_;
      terminalLocationType_ = other.terminalLocationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TerminalLocation Clone() {
      return new TerminalLocation(this);
    }

    /// <summary>Field number for the "point" field.</summary>
    public const int PointFieldNumber = 1;
    private global::Google.Type.LatLng point_;
    /// <summary>
    /// Required. Denotes the actual location of a pickup or dropoff.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng Point {
      get { return point_; }
      set {
        point_ = value;
      }
    }

    /// <summary>Field number for the "terminal_point_id" field.</summary>
    public const int TerminalPointIdFieldNumber = 2;
    private global::Maps.Fleetengine.V1.TerminalPointId terminalPointId_;
    /// <summary>
    /// Required. ID of the terminal point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TerminalPointId TerminalPointId {
      get { return terminalPointId_; }
      set {
        terminalPointId_ = value;
      }
    }

    /// <summary>Field number for the "access_point_id" field.</summary>
    public const int AccessPointIdFieldNumber = 3;
    private string accessPointId_ = "";
    /// <summary>
    /// Deprecated.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AccessPointId {
      get { return accessPointId_; }
      set {
        accessPointId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 4;
    private string tripId_ = "";
    /// <summary>
    /// Deprecated. Use vehicle.waypoint instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "terminal_location_type" field.</summary>
    public const int TerminalLocationTypeFieldNumber = 5;
    private global::Maps.Fleetengine.V1.WaypointType terminalLocationType_ = global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType;
    /// <summary>
    /// Deprecated. Vehicle.waypoint will have this data.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.WaypointType TerminalLocationType {
      get { return terminalLocationType_; }
      set {
        terminalLocationType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TerminalLocation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TerminalLocation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Point, other.Point)) return false;
      if (!object.Equals(TerminalPointId, other.TerminalPointId)) return false;
      if (AccessPointId != other.AccessPointId) return false;
      if (TripId != other.TripId) return false;
      if (TerminalLocationType != other.TerminalLocationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (point_ != null) hash ^= Point.GetHashCode();
      if (terminalPointId_ != null) hash ^= TerminalPointId.GetHashCode();
      if (AccessPointId.Length != 0) hash ^= AccessPointId.GetHashCode();
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (TerminalLocationType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) hash ^= TerminalLocationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (point_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Point);
      }
      if (terminalPointId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TerminalPointId);
      }
      if (AccessPointId.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AccessPointId);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(TripId);
      }
      if (TerminalLocationType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        output.WriteRawTag(40);
        output.WriteEnum((int) TerminalLocationType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (point_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Point);
      }
      if (terminalPointId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TerminalPointId);
      }
      if (AccessPointId.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AccessPointId);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(TripId);
      }
      if (TerminalLocationType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        output.WriteRawTag(40);
        output.WriteEnum((int) TerminalLocationType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (point_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Point);
      }
      if (terminalPointId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TerminalPointId);
      }
      if (AccessPointId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AccessPointId);
      }
      if (TripId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (TerminalLocationType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TerminalLocationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TerminalLocation other) {
      if (other == null) {
        return;
      }
      if (other.point_ != null) {
        if (point_ == null) {
          Point = new global::Google.Type.LatLng();
        }
        Point.MergeFrom(other.Point);
      }
      if (other.terminalPointId_ != null) {
        if (terminalPointId_ == null) {
          TerminalPointId = new global::Maps.Fleetengine.V1.TerminalPointId();
        }
        TerminalPointId.MergeFrom(other.TerminalPointId);
      }
      if (other.AccessPointId.Length != 0) {
        AccessPointId = other.AccessPointId;
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      if (other.TerminalLocationType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        TerminalLocationType = other.TerminalLocationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (point_ == null) {
              Point = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Point);
            break;
          }
          case 18: {
            if (terminalPointId_ == null) {
              TerminalPointId = new global::Maps.Fleetengine.V1.TerminalPointId();
            }
            input.ReadMessage(TerminalPointId);
            break;
          }
          case 26: {
            AccessPointId = input.ReadString();
            break;
          }
          case 34: {
            TripId = input.ReadString();
            break;
          }
          case 40: {
            TerminalLocationType = (global::Maps.Fleetengine.V1.WaypointType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (point_ == null) {
              Point = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Point);
            break;
          }
          case 18: {
            if (terminalPointId_ == null) {
              TerminalPointId = new global::Maps.Fleetengine.V1.TerminalPointId();
            }
            input.ReadMessage(TerminalPointId);
            break;
          }
          case 26: {
            AccessPointId = input.ReadString();
            break;
          }
          case 34: {
            TripId = input.ReadString();
            break;
          }
          case 40: {
            TerminalLocationType = (global::Maps.Fleetengine.V1.WaypointType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes a stopping point on a vehicle's route or an ending point on a
  /// vehicle's trip.
  /// </summary>
  public sealed partial class TripWaypoint : pb::IMessage<TripWaypoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TripWaypoint> _parser = new pb::MessageParser<TripWaypoint>(() => new TripWaypoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TripWaypoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripWaypoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripWaypoint(TripWaypoint other) : this() {
      location_ = other.location_ != null ? other.location_.Clone() : null;
      tripId_ = other.tripId_;
      waypointType_ = other.waypointType_;
      pathToWaypoint_ = other.pathToWaypoint_.Clone();
      DistanceMeters = other.DistanceMeters;
      eta_ = other.eta_ != null ? other.eta_.Clone() : null;
      duration_ = other.duration_ != null ? other.duration_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripWaypoint Clone() {
      return new TripWaypoint(this);
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 1;
    private global::Maps.Fleetengine.V1.TerminalLocation location_;
    /// <summary>
    /// The location where this waypoint is
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TerminalLocation Location {
      get { return location_; }
      set {
        location_ = value;
      }
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 2;
    private string tripId_ = "";
    /// <summary>
    /// The trip this waypoint is part of
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "waypoint_type" field.</summary>
    public const int WaypointTypeFieldNumber = 3;
    private global::Maps.Fleetengine.V1.WaypointType waypointType_ = global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType;
    /// <summary>
    /// The type described the role the waypoint plays for this trip such as a
    /// pickup or dropoff.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.WaypointType WaypointType {
      get { return waypointType_; }
      set {
        waypointType_ = value;
      }
    }

    /// <summary>Field number for the "path_to_waypoint" field.</summary>
    public const int PathToWaypointFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Google.Type.LatLng> _repeated_pathToWaypoint_codec
        = pb::FieldCodec.ForMessage(34, global::Google.Type.LatLng.Parser);
    private readonly pbc::RepeatedField<global::Google.Type.LatLng> pathToWaypoint_ = new pbc::RepeatedField<global::Google.Type.LatLng>();
    /// <summary>
    /// The path calculated by Fleet Engine from the previous waypoint to the
    /// current waypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Type.LatLng> PathToWaypoint {
      get { return pathToWaypoint_; }
    }

    /// <summary>Field number for the "distance_meters" field.</summary>
    public const int DistanceMetersFieldNumber = 6;
    private static readonly pb::FieldCodec<int?> _single_distanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(50);
    private int? distanceMeters_;
    /// <summary>
    /// The path distance calculated by Fleet Engine from the previous waypoint to
    /// the current waypoint.
    /// If the current waypoint is the first waypoint in the list (Vehicle.waypoint
    /// or Trip.remaining_waypoints), then the starting point is the vehicle's
    /// location recorded at the time this TripWaypoint was added to the list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? DistanceMeters {
      get { return distanceMeters_; }
      set {
        distanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "eta" field.</summary>
    public const int EtaFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Timestamp eta_;
    /// <summary>
    /// The arrival time to this waypoint calculated by Fleet Engine.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Eta {
      get { return eta_; }
      set {
        eta_ = value;
      }
    }

    /// <summary>Field number for the "duration" field.</summary>
    public const int DurationFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration duration_;
    /// <summary>
    /// The travel time from previous waypoint to this point.
    /// If the current waypoint is the first waypoint in the list (Vehicle.waypoint
    /// or Trip.remaining_waypoints), then the starting point is the vehicle's
    /// location recorded at the time that this waypoint was added to the list.
    /// This field is filled only when returning Trip/Vehicle data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Duration {
      get { return duration_; }
      set {
        duration_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TripWaypoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TripWaypoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Location, other.Location)) return false;
      if (TripId != other.TripId) return false;
      if (WaypointType != other.WaypointType) return false;
      if(!pathToWaypoint_.Equals(other.pathToWaypoint_)) return false;
      if (DistanceMeters != other.DistanceMeters) return false;
      if (!object.Equals(Eta, other.Eta)) return false;
      if (!object.Equals(Duration, other.Duration)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (location_ != null) hash ^= Location.GetHashCode();
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (WaypointType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) hash ^= WaypointType.GetHashCode();
      hash ^= pathToWaypoint_.GetHashCode();
      if (distanceMeters_ != null) hash ^= DistanceMeters.GetHashCode();
      if (eta_ != null) hash ^= Eta.GetHashCode();
      if (duration_ != null) hash ^= Duration.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (location_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Location);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(TripId);
      }
      if (WaypointType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        output.WriteRawTag(24);
        output.WriteEnum((int) WaypointType);
      }
      pathToWaypoint_.WriteTo(output, _repeated_pathToWaypoint_codec);
      if (distanceMeters_ != null) {
        _single_distanceMeters_codec.WriteTagAndValue(output, DistanceMeters);
      }
      if (eta_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Eta);
      }
      if (duration_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Duration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (location_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Location);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(TripId);
      }
      if (WaypointType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        output.WriteRawTag(24);
        output.WriteEnum((int) WaypointType);
      }
      pathToWaypoint_.WriteTo(ref output, _repeated_pathToWaypoint_codec);
      if (distanceMeters_ != null) {
        _single_distanceMeters_codec.WriteTagAndValue(ref output, DistanceMeters);
      }
      if (eta_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Eta);
      }
      if (duration_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Duration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (location_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Location);
      }
      if (TripId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (WaypointType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) WaypointType);
      }
      size += pathToWaypoint_.CalculateSize(_repeated_pathToWaypoint_codec);
      if (distanceMeters_ != null) {
        size += _single_distanceMeters_codec.CalculateSizeWithTag(DistanceMeters);
      }
      if (eta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Eta);
      }
      if (duration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TripWaypoint other) {
      if (other == null) {
        return;
      }
      if (other.location_ != null) {
        if (location_ == null) {
          Location = new global::Maps.Fleetengine.V1.TerminalLocation();
        }
        Location.MergeFrom(other.Location);
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      if (other.WaypointType != global::Maps.Fleetengine.V1.WaypointType.UnknownWaypointType) {
        WaypointType = other.WaypointType;
      }
      pathToWaypoint_.Add(other.pathToWaypoint_);
      if (other.distanceMeters_ != null) {
        if (distanceMeters_ == null || other.DistanceMeters != 0) {
          DistanceMeters = other.DistanceMeters;
        }
      }
      if (other.eta_ != null) {
        if (eta_ == null) {
          Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Eta.MergeFrom(other.Eta);
      }
      if (other.duration_ != null) {
        if (duration_ == null) {
          Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Duration.MergeFrom(other.Duration);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (location_ == null) {
              Location = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(Location);
            break;
          }
          case 18: {
            TripId = input.ReadString();
            break;
          }
          case 24: {
            WaypointType = (global::Maps.Fleetengine.V1.WaypointType) input.ReadEnum();
            break;
          }
          case 34: {
            pathToWaypoint_.AddEntriesFrom(input, _repeated_pathToWaypoint_codec);
            break;
          }
          case 50: {
            int? value = _single_distanceMeters_codec.Read(input);
            if (distanceMeters_ == null || value != 0) {
              DistanceMeters = value;
            }
            break;
          }
          case 58: {
            if (eta_ == null) {
              Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Eta);
            break;
          }
          case 66: {
            if (duration_ == null) {
              Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Duration);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (location_ == null) {
              Location = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(Location);
            break;
          }
          case 18: {
            TripId = input.ReadString();
            break;
          }
          case 24: {
            WaypointType = (global::Maps.Fleetengine.V1.WaypointType) input.ReadEnum();
            break;
          }
          case 34: {
            pathToWaypoint_.AddEntriesFrom(ref input, _repeated_pathToWaypoint_codec);
            break;
          }
          case 50: {
            int? value = _single_distanceMeters_codec.Read(ref input);
            if (distanceMeters_ == null || value != 0) {
              DistanceMeters = value;
            }
            break;
          }
          case 58: {
            if (eta_ == null) {
              Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Eta);
            break;
          }
          case 66: {
            if (duration_ == null) {
              Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Duration);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The 'Status' defines a FleetEngine custom logical error mode.
  /// </summary>
  public sealed partial class Status : pb::IMessage<Status>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Status> _parser = new pb::MessageParser<Status>(() => new Status());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Status> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status(Status other) : this() {
      code_ = other.code_;
      message_ = other.message_;
      details_ = other.details_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status Clone() {
      return new Status(this);
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 1;
    private global::Maps.Fleetengine.V1.Status.Types.Code code_ = global::Maps.Fleetengine.V1.Status.Types.Code.Unspecified;
    /// <summary>
    /// The error code. It is not possible to have a value as 0 if it is explicitly
    /// set by the server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.Status.Types.Code Code {
      get { return code_; }
      set {
        code_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 2;
    private string message_ = "";
    /// <summary>
    /// Detailed error message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Message {
      get { return message_; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "details" field.</summary>
    public const int DetailsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Any> _repeated_details_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Protobuf.WellKnownTypes.Any.Parser);
    private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> details_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// A list of messages that carry the error details.  There is a common set of
    /// message types for APIs to use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> Details {
      get { return details_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Status);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Status other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Code != other.Code) return false;
      if (Message != other.Message) return false;
      if(!details_.Equals(other.details_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Code != global::Maps.Fleetengine.V1.Status.Types.Code.Unspecified) hash ^= Code.GetHashCode();
      if (Message.Length != 0) hash ^= Message.GetHashCode();
      hash ^= details_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Code != global::Maps.Fleetengine.V1.Status.Types.Code.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Code);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      details_.WriteTo(output, _repeated_details_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Code != global::Maps.Fleetengine.V1.Status.Types.Code.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Code);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      details_.WriteTo(ref output, _repeated_details_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Code != global::Maps.Fleetengine.V1.Status.Types.Code.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Code);
      }
      if (Message.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      size += details_.CalculateSize(_repeated_details_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Status other) {
      if (other == null) {
        return;
      }
      if (other.Code != global::Maps.Fleetengine.V1.Status.Types.Code.Unspecified) {
        Code = other.Code;
      }
      if (other.Message.Length != 0) {
        Message = other.Message;
      }
      details_.Add(other.details_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Code = (global::Maps.Fleetengine.V1.Status.Types.Code) input.ReadEnum();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 26: {
            details_.AddEntriesFrom(input, _repeated_details_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Code = (global::Maps.Fleetengine.V1.Status.Types.Code) input.ReadEnum();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 26: {
            details_.AddEntriesFrom(ref input, _repeated_details_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Status message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The canonical error code.
      /// </summary>
      public enum Code {
        /// <summary>
        /// Unspecified status, not a valid value to set.
        /// </summary>
        [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Internal server error. Usually expect the client to retry in this case.
        /// </summary>
        [pbr::OriginalName("FAILURE")] Failure = 1,
        /// <summary>
        /// There is no possible route. Client should not retry.
        /// </summary>
        [pbr::OriginalName("ROUTE_NOT_POSSIBLE")] RouteNotPossible = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// A full, human-readable address for the entity containing this message.
  /// </summary>
  public sealed partial class FormattedAddress : pb::IMessage<FormattedAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FormattedAddress> _parser = new pb::MessageParser<FormattedAddress>(() => new FormattedAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FormattedAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FormattedAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FormattedAddress(FormattedAddress other) : this() {
      lines_ = other.lines_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FormattedAddress Clone() {
      return new FormattedAddress(this);
    }

    /// <summary>Field number for the "lines" field.</summary>
    public const int LinesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_lines_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> lines_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The lines of text that describe the address.
    /// At least one line must be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Lines {
      get { return lines_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FormattedAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FormattedAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!lines_.Equals(other.lines_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= lines_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      lines_.WriteTo(output, _repeated_lines_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      lines_.WriteTo(ref output, _repeated_lines_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += lines_.CalculateSize(_repeated_lines_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FormattedAddress other) {
      if (other == null) {
        return;
      }
      lines_.Add(other.lines_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            lines_.AddEntriesFrom(input, _repeated_lines_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            lines_.AddEntriesFrom(ref input, _repeated_lines_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Address of a place.
  /// </summary>
  public sealed partial class Address : pb::IMessage<Address>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Address> _parser = new pb::MessageParser<Address>(() => new Address());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Address> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address(Address other) : this() {
      formattedAddress_ = other.formattedAddress_ != null ? other.formattedAddress_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address Clone() {
      return new Address(this);
    }

    /// <summary>Field number for the "formatted_address" field.</summary>
    public const int FormattedAddressFieldNumber = 1;
    private global::Maps.Fleetengine.V1.FormattedAddress formattedAddress_;
    /// <summary>
    /// A full, human-readable address for this place.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.FormattedAddress FormattedAddress {
      get { return formattedAddress_; }
      set {
        formattedAddress_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Address);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Address other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FormattedAddress, other.FormattedAddress)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (formattedAddress_ != null) hash ^= FormattedAddress.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (formattedAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FormattedAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (formattedAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FormattedAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (formattedAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FormattedAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Address other) {
      if (other == null) {
        return;
      }
      if (other.formattedAddress_ != null) {
        if (formattedAddress_ == null) {
          FormattedAddress = new global::Maps.Fleetengine.V1.FormattedAddress();
        }
        FormattedAddress.MergeFrom(other.FormattedAddress);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (formattedAddress_ == null) {
              FormattedAddress = new global::Maps.Fleetengine.V1.FormattedAddress();
            }
            input.ReadMessage(FormattedAddress);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (formattedAddress_ == null) {
              FormattedAddress = new global::Maps.Fleetengine.V1.FormattedAddress();
            }
            input.ReadMessage(FormattedAddress);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes a vehicle attribute as a key-value pair.
  /// </summary>
  public sealed partial class VehicleAttribute : pb::IMessage<VehicleAttribute>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehicleAttribute> _parser = new pb::MessageParser<VehicleAttribute>(() => new VehicleAttribute());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VehicleAttribute> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleAttribute() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleAttribute(VehicleAttribute other) : this() {
      key_ = other.key_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleAttribute Clone() {
      return new VehicleAttribute(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private string key_ = "";
    /// <summary>
    /// The attribute's key. Keys may not contain the colon character (:).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Key {
      get { return key_; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private string value_ = "";
    /// <summary>
    /// The attribute's value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VehicleAttribute);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VehicleAttribute other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Key.Length != 0) hash ^= Key.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Key.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Key.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Key.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VehicleAttribute other) {
      if (other == null) {
        return;
      }
      if (other.Key.Length != 0) {
        Key = other.Key;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The location, speed, and heading of a vehicle at a point in time.
  /// </summary>
  public sealed partial class VehicleLocation : pb::IMessage<VehicleLocation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehicleLocation> _parser = new pb::MessageParser<VehicleLocation>(() => new VehicleLocation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VehicleLocation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleLocation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleLocation(VehicleLocation other) : this() {
      location_ = other.location_ != null ? other.location_.Clone() : null;
      HorizontalAccuracy = other.HorizontalAccuracy;
      LatlngAccuracy = other.LatlngAccuracy;
      Heading = other.Heading;
      BearingAccuracy = other.BearingAccuracy;
      HeadingAccuracy = other.HeadingAccuracy;
      Altitude = other.Altitude;
      VerticalAccuracy = other.VerticalAccuracy;
      AltitudeAccuracy = other.AltitudeAccuracy;
      SpeedKmph = other.SpeedKmph;
      Speed = other.Speed;
      SpeedAccuracy = other.SpeedAccuracy;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      serverTime_ = other.serverTime_ != null ? other.serverTime_.Clone() : null;
      locationSensor_ = other.locationSensor_;
      IsRoadSnapped = other.IsRoadSnapped;
      IsGpsSensorEnabled = other.IsGpsSensorEnabled;
      TimeSinceUpdate = other.TimeSinceUpdate;
      NumStaleUpdates = other.NumStaleUpdates;
      rawLocation_ = other.rawLocation_ != null ? other.rawLocation_.Clone() : null;
      rawLocationTime_ = other.rawLocationTime_ != null ? other.rawLocationTime_.Clone() : null;
      rawLocationSensor_ = other.rawLocationSensor_;
      RawLocationAccuracy = other.RawLocationAccuracy;
      supplementalLocation_ = other.supplementalLocation_ != null ? other.supplementalLocation_.Clone() : null;
      supplementalLocationTime_ = other.supplementalLocationTime_ != null ? other.supplementalLocationTime_.Clone() : null;
      supplementalLocationSensor_ = other.supplementalLocationSensor_;
      SupplementalLocationAccuracy = other.SupplementalLocationAccuracy;
      roadSnapped_ = other.roadSnapped_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleLocation Clone() {
      return new VehicleLocation(this);
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 1;
    private global::Google.Type.LatLng location_;
    /// <summary>
    /// The location of the vehicle.
    /// When it is sent to FleetEngine, the vehicle's location is a GPS location.
    /// When you receive it in a response, the vehicle's location can be either a
    /// GPS location or a supplemental location. The source is specified in the
    /// field 'location_sensor'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng Location {
      get { return location_; }
      set {
        location_ = value;
      }
    }

    /// <summary>Field number for the "horizontal_accuracy" field.</summary>
    public const int HorizontalAccuracyFieldNumber = 8;
    private static readonly pb::FieldCodec<double?> _single_horizontalAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(66);
    private double? horizontalAccuracy_;
    /// <summary>
    /// Deprecated. Use latlng_accuracy instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? HorizontalAccuracy {
      get { return horizontalAccuracy_; }
      set {
        horizontalAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "latlng_accuracy" field.</summary>
    public const int LatlngAccuracyFieldNumber = 22;
    private static readonly pb::FieldCodec<double?> _single_latlngAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(178);
    private double? latlngAccuracy_;
    /// <summary>
    /// Accuracy of horizontal measurements (lat/lng) in meters as a radius.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? LatlngAccuracy {
      get { return latlngAccuracy_; }
      set {
        latlngAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "heading" field.</summary>
    public const int HeadingFieldNumber = 2;
    private static readonly pb::FieldCodec<int?> _single_heading_codec = pb::FieldCodec.ForStructWrapper<int>(18);
    private int? heading_;
    /// <summary>
    /// Direction the vehicle is moving in degrees.  0 represents North.
    /// The valid range is [0,360).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? Heading {
      get { return heading_; }
      set {
        heading_ = value;
      }
    }


    /// <summary>Field number for the "bearing_accuracy" field.</summary>
    public const int BearingAccuracyFieldNumber = 10;
    private static readonly pb::FieldCodec<double?> _single_bearingAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(82);
    private double? bearingAccuracy_;
    /// <summary>
    /// Deprecated. Use heading_accuracy instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? BearingAccuracy {
      get { return bearingAccuracy_; }
      set {
        bearingAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "heading_accuracy" field.</summary>
    public const int HeadingAccuracyFieldNumber = 23;
    private static readonly pb::FieldCodec<double?> _single_headingAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(186);
    private double? headingAccuracy_;
    /// <summary>
    /// Accuracy of heading (bearing) in degrees.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? HeadingAccuracy {
      get { return headingAccuracy_; }
      set {
        headingAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "altitude" field.</summary>
    public const int AltitudeFieldNumber = 5;
    private static readonly pb::FieldCodec<double?> _single_altitude_codec = pb::FieldCodec.ForStructWrapper<double>(42);
    private double? altitude_;
    /// <summary>
    /// Altitude in meters above WGS84.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? Altitude {
      get { return altitude_; }
      set {
        altitude_ = value;
      }
    }


    /// <summary>Field number for the "vertical_accuracy" field.</summary>
    public const int VerticalAccuracyFieldNumber = 9;
    private static readonly pb::FieldCodec<double?> _single_verticalAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(74);
    private double? verticalAccuracy_;
    /// <summary>
    /// Deprecated. Use altitude_accurarcy instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? VerticalAccuracy {
      get { return verticalAccuracy_; }
      set {
        verticalAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "altitude_accuracy" field.</summary>
    public const int AltitudeAccuracyFieldNumber = 24;
    private static readonly pb::FieldCodec<double?> _single_altitudeAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(194);
    private double? altitudeAccuracy_;
    /// <summary>
    /// Accuracy of altitude measurement in meters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? AltitudeAccuracy {
      get { return altitudeAccuracy_; }
      set {
        altitudeAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "speed_kmph" field.</summary>
    public const int SpeedKmphFieldNumber = 3;
    private static readonly pb::FieldCodec<int?> _single_speedKmph_codec = pb::FieldCodec.ForStructWrapper<int>(26);
    private int? speedKmph_;
    /// <summary>
    /// Speed of the vehicle in kilometers per hour.
    /// Deprecated. Use speed instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? SpeedKmph {
      get { return speedKmph_; }
      set {
        speedKmph_ = value;
      }
    }


    /// <summary>Field number for the "speed" field.</summary>
    public const int SpeedFieldNumber = 6;
    private static readonly pb::FieldCodec<double?> _single_speed_codec = pb::FieldCodec.ForStructWrapper<double>(50);
    private double? speed_;
    /// <summary>
    /// Speed of the vehicle in meters/second
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? Speed {
      get { return speed_; }
      set {
        speed_ = value;
      }
    }


    /// <summary>Field number for the "speed_accuracy" field.</summary>
    public const int SpeedAccuracyFieldNumber = 7;
    private static readonly pb::FieldCodec<double?> _single_speedAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(58);
    private double? speedAccuracy_;
    /// <summary>
    /// Accuracy of speed in meters/second.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? SpeedAccuracy {
      get { return speedAccuracy_; }
      set {
        speedAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// The time when the location was recorded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "server_time" field.</summary>
    public const int ServerTimeFieldNumber = 13;
    private global::Google.Protobuf.WellKnownTypes.Timestamp serverTime_;
    /// <summary>
    /// Output only. The time when the server receives the location information, filled by
    /// FleetEngine.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ServerTime {
      get { return serverTime_; }
      set {
        serverTime_ = value;
      }
    }

    /// <summary>Field number for the "location_sensor" field.</summary>
    public const int LocationSensorFieldNumber = 11;
    private global::Maps.Fleetengine.V1.LocationSensor locationSensor_ = global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor;
    /// <summary>
    /// Provider of location data (for example, "gps").
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.LocationSensor LocationSensor {
      get { return locationSensor_; }
      set {
        locationSensor_ = value;
      }
    }

    /// <summary>Field number for the "is_road_snapped" field.</summary>
    public const int IsRoadSnappedFieldNumber = 27;
    private static readonly pb::FieldCodec<bool?> _single_isRoadSnapped_codec = pb::FieldCodec.ForStructWrapper<bool>(218);
    private bool? isRoadSnapped_;
    /// <summary>
    /// Whether the vehicle location given by "location" field is snapped to a road
    /// closest to the location given by "raw_location".
    /// Driver SDK 1.15.1/2.1.1 and up will always set this field.
    /// Unset value will be treated as true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? IsRoadSnapped {
      get { return isRoadSnapped_; }
      set {
        isRoadSnapped_ = value;
      }
    }


    /// <summary>Field number for the "is_gps_sensor_enabled" field.</summary>
    public const int IsGpsSensorEnabledFieldNumber = 12;
    private static readonly pb::FieldCodec<bool?> _single_isGpsSensorEnabled_codec = pb::FieldCodec.ForStructWrapper<bool>(98);
    private bool? isGpsSensorEnabled_;
    /// <summary>
    /// Input only. Indicates whether the GPS sensor is enabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? IsGpsSensorEnabled {
      get { return isGpsSensorEnabled_; }
      set {
        isGpsSensorEnabled_ = value;
      }
    }


    /// <summary>Field number for the "time_since_update" field.</summary>
    public const int TimeSinceUpdateFieldNumber = 14;
    private static readonly pb::FieldCodec<int?> _single_timeSinceUpdate_codec = pb::FieldCodec.ForStructWrapper<int>(114);
    private int? timeSinceUpdate_;
    /// <summary>
    /// Input only. Time (in seconds) since this location sample was first sent to the server.
    /// This will be zero for the first update. If the time is unknown
    /// (for example, when the app restarts), this value resets to zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? TimeSinceUpdate {
      get { return timeSinceUpdate_; }
      set {
        timeSinceUpdate_ = value;
      }
    }


    /// <summary>Field number for the "num_stale_updates" field.</summary>
    public const int NumStaleUpdatesFieldNumber = 15;
    private static readonly pb::FieldCodec<int?> _single_numStaleUpdates_codec = pb::FieldCodec.ForStructWrapper<int>(122);
    private int? numStaleUpdates_;
    /// <summary>
    /// Input only. Number of additional attempts to send the current location to the server.
    /// If this value is zero, then it is not stale.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? NumStaleUpdates {
      get { return numStaleUpdates_; }
      set {
        numStaleUpdates_ = value;
      }
    }


    /// <summary>Field number for the "raw_location" field.</summary>
    public const int RawLocationFieldNumber = 16;
    private global::Google.Type.LatLng rawLocation_;
    /// <summary>
    /// Raw vehicle location (unprocessed by road-snapper).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng RawLocation {
      get { return rawLocation_; }
      set {
        rawLocation_ = value;
      }
    }

    /// <summary>Field number for the "raw_location_time" field.</summary>
    public const int RawLocationTimeFieldNumber = 17;
    private global::Google.Protobuf.WellKnownTypes.Timestamp rawLocationTime_;
    /// <summary>
    /// Input only. Timestamp associated with the raw location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp RawLocationTime {
      get { return rawLocationTime_; }
      set {
        rawLocationTime_ = value;
      }
    }

    /// <summary>Field number for the "raw_location_sensor" field.</summary>
    public const int RawLocationSensorFieldNumber = 28;
    private global::Maps.Fleetengine.V1.LocationSensor rawLocationSensor_ = global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor;
    /// <summary>
    /// Input only. Source of the raw location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.LocationSensor RawLocationSensor {
      get { return rawLocationSensor_; }
      set {
        rawLocationSensor_ = value;
      }
    }

    /// <summary>Field number for the "raw_location_accuracy" field.</summary>
    public const int RawLocationAccuracyFieldNumber = 25;
    private static readonly pb::FieldCodec<double?> _single_rawLocationAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(202);
    private double? rawLocationAccuracy_;
    /// <summary>
    /// Input only. Accuracy of the raw location (lat/lng) as a radius, measured in meters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? RawLocationAccuracy {
      get { return rawLocationAccuracy_; }
      set {
        rawLocationAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "supplemental_location" field.</summary>
    public const int SupplementalLocationFieldNumber = 18;
    private global::Google.Type.LatLng supplementalLocation_;
    /// <summary>
    /// Input only. Supplemental location provided by the integrating app, such as the location
    /// provided by Fused Location Provider.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng SupplementalLocation {
      get { return supplementalLocation_; }
      set {
        supplementalLocation_ = value;
      }
    }

    /// <summary>Field number for the "supplemental_location_time" field.</summary>
    public const int SupplementalLocationTimeFieldNumber = 19;
    private global::Google.Protobuf.WellKnownTypes.Timestamp supplementalLocationTime_;
    /// <summary>
    /// Input only. Timestamp associated with the supplemental location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp SupplementalLocationTime {
      get { return supplementalLocationTime_; }
      set {
        supplementalLocationTime_ = value;
      }
    }

    /// <summary>Field number for the "supplemental_location_sensor" field.</summary>
    public const int SupplementalLocationSensorFieldNumber = 20;
    private global::Maps.Fleetengine.V1.LocationSensor supplementalLocationSensor_ = global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor;
    /// <summary>
    /// Input only. Source of the supplemental location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.LocationSensor SupplementalLocationSensor {
      get { return supplementalLocationSensor_; }
      set {
        supplementalLocationSensor_ = value;
      }
    }

    /// <summary>Field number for the "supplemental_location_accuracy" field.</summary>
    public const int SupplementalLocationAccuracyFieldNumber = 21;
    private static readonly pb::FieldCodec<double?> _single_supplementalLocationAccuracy_codec = pb::FieldCodec.ForStructWrapper<double>(170);
    private double? supplementalLocationAccuracy_;
    /// <summary>
    /// Input only. Accuracy of supplemental location (lat/lng) as a radius, measured in
    /// meters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? SupplementalLocationAccuracy {
      get { return supplementalLocationAccuracy_; }
      set {
        supplementalLocationAccuracy_ = value;
      }
    }


    /// <summary>Field number for the "road_snapped" field.</summary>
    public const int RoadSnappedFieldNumber = 26;
    private bool roadSnapped_;
    /// <summary>
    /// Deprecated, use is_road_snapped instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RoadSnapped {
      get { return roadSnapped_; }
      set {
        roadSnapped_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VehicleLocation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VehicleLocation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Location, other.Location)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(HorizontalAccuracy, other.HorizontalAccuracy)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(LatlngAccuracy, other.LatlngAccuracy)) return false;
      if (Heading != other.Heading) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(BearingAccuracy, other.BearingAccuracy)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(HeadingAccuracy, other.HeadingAccuracy)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(Altitude, other.Altitude)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(VerticalAccuracy, other.VerticalAccuracy)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(AltitudeAccuracy, other.AltitudeAccuracy)) return false;
      if (SpeedKmph != other.SpeedKmph) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(Speed, other.Speed)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(SpeedAccuracy, other.SpeedAccuracy)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!object.Equals(ServerTime, other.ServerTime)) return false;
      if (LocationSensor != other.LocationSensor) return false;
      if (IsRoadSnapped != other.IsRoadSnapped) return false;
      if (IsGpsSensorEnabled != other.IsGpsSensorEnabled) return false;
      if (TimeSinceUpdate != other.TimeSinceUpdate) return false;
      if (NumStaleUpdates != other.NumStaleUpdates) return false;
      if (!object.Equals(RawLocation, other.RawLocation)) return false;
      if (!object.Equals(RawLocationTime, other.RawLocationTime)) return false;
      if (RawLocationSensor != other.RawLocationSensor) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(RawLocationAccuracy, other.RawLocationAccuracy)) return false;
      if (!object.Equals(SupplementalLocation, other.SupplementalLocation)) return false;
      if (!object.Equals(SupplementalLocationTime, other.SupplementalLocationTime)) return false;
      if (SupplementalLocationSensor != other.SupplementalLocationSensor) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(SupplementalLocationAccuracy, other.SupplementalLocationAccuracy)) return false;
      if (RoadSnapped != other.RoadSnapped) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (location_ != null) hash ^= Location.GetHashCode();
      if (horizontalAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(HorizontalAccuracy);
      if (latlngAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(LatlngAccuracy);
      if (heading_ != null) hash ^= Heading.GetHashCode();
      if (bearingAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(BearingAccuracy);
      if (headingAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(HeadingAccuracy);
      if (altitude_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(Altitude);
      if (verticalAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(VerticalAccuracy);
      if (altitudeAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(AltitudeAccuracy);
      if (speedKmph_ != null) hash ^= SpeedKmph.GetHashCode();
      if (speed_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(Speed);
      if (speedAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(SpeedAccuracy);
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      if (serverTime_ != null) hash ^= ServerTime.GetHashCode();
      if (LocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) hash ^= LocationSensor.GetHashCode();
      if (isRoadSnapped_ != null) hash ^= IsRoadSnapped.GetHashCode();
      if (isGpsSensorEnabled_ != null) hash ^= IsGpsSensorEnabled.GetHashCode();
      if (timeSinceUpdate_ != null) hash ^= TimeSinceUpdate.GetHashCode();
      if (numStaleUpdates_ != null) hash ^= NumStaleUpdates.GetHashCode();
      if (rawLocation_ != null) hash ^= RawLocation.GetHashCode();
      if (rawLocationTime_ != null) hash ^= RawLocationTime.GetHashCode();
      if (RawLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) hash ^= RawLocationSensor.GetHashCode();
      if (rawLocationAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(RawLocationAccuracy);
      if (supplementalLocation_ != null) hash ^= SupplementalLocation.GetHashCode();
      if (supplementalLocationTime_ != null) hash ^= SupplementalLocationTime.GetHashCode();
      if (SupplementalLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) hash ^= SupplementalLocationSensor.GetHashCode();
      if (supplementalLocationAccuracy_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(SupplementalLocationAccuracy);
      if (RoadSnapped != false) hash ^= RoadSnapped.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (location_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Location);
      }
      if (heading_ != null) {
        _single_heading_codec.WriteTagAndValue(output, Heading);
      }
      if (speedKmph_ != null) {
        _single_speedKmph_codec.WriteTagAndValue(output, SpeedKmph);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(UpdateTime);
      }
      if (altitude_ != null) {
        _single_altitude_codec.WriteTagAndValue(output, Altitude);
      }
      if (speed_ != null) {
        _single_speed_codec.WriteTagAndValue(output, Speed);
      }
      if (speedAccuracy_ != null) {
        _single_speedAccuracy_codec.WriteTagAndValue(output, SpeedAccuracy);
      }
      if (horizontalAccuracy_ != null) {
        _single_horizontalAccuracy_codec.WriteTagAndValue(output, HorizontalAccuracy);
      }
      if (verticalAccuracy_ != null) {
        _single_verticalAccuracy_codec.WriteTagAndValue(output, VerticalAccuracy);
      }
      if (bearingAccuracy_ != null) {
        _single_bearingAccuracy_codec.WriteTagAndValue(output, BearingAccuracy);
      }
      if (LocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        output.WriteRawTag(88);
        output.WriteEnum((int) LocationSensor);
      }
      if (isGpsSensorEnabled_ != null) {
        _single_isGpsSensorEnabled_codec.WriteTagAndValue(output, IsGpsSensorEnabled);
      }
      if (serverTime_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(ServerTime);
      }
      if (timeSinceUpdate_ != null) {
        _single_timeSinceUpdate_codec.WriteTagAndValue(output, TimeSinceUpdate);
      }
      if (numStaleUpdates_ != null) {
        _single_numStaleUpdates_codec.WriteTagAndValue(output, NumStaleUpdates);
      }
      if (rawLocation_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RawLocation);
      }
      if (rawLocationTime_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(RawLocationTime);
      }
      if (supplementalLocation_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(SupplementalLocation);
      }
      if (supplementalLocationTime_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(SupplementalLocationTime);
      }
      if (SupplementalLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) SupplementalLocationSensor);
      }
      if (supplementalLocationAccuracy_ != null) {
        _single_supplementalLocationAccuracy_codec.WriteTagAndValue(output, SupplementalLocationAccuracy);
      }
      if (latlngAccuracy_ != null) {
        _single_latlngAccuracy_codec.WriteTagAndValue(output, LatlngAccuracy);
      }
      if (headingAccuracy_ != null) {
        _single_headingAccuracy_codec.WriteTagAndValue(output, HeadingAccuracy);
      }
      if (altitudeAccuracy_ != null) {
        _single_altitudeAccuracy_codec.WriteTagAndValue(output, AltitudeAccuracy);
      }
      if (rawLocationAccuracy_ != null) {
        _single_rawLocationAccuracy_codec.WriteTagAndValue(output, RawLocationAccuracy);
      }
      if (RoadSnapped != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(RoadSnapped);
      }
      if (isRoadSnapped_ != null) {
        _single_isRoadSnapped_codec.WriteTagAndValue(output, IsRoadSnapped);
      }
      if (RawLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        output.WriteRawTag(224, 1);
        output.WriteEnum((int) RawLocationSensor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (location_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Location);
      }
      if (heading_ != null) {
        _single_heading_codec.WriteTagAndValue(ref output, Heading);
      }
      if (speedKmph_ != null) {
        _single_speedKmph_codec.WriteTagAndValue(ref output, SpeedKmph);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(UpdateTime);
      }
      if (altitude_ != null) {
        _single_altitude_codec.WriteTagAndValue(ref output, Altitude);
      }
      if (speed_ != null) {
        _single_speed_codec.WriteTagAndValue(ref output, Speed);
      }
      if (speedAccuracy_ != null) {
        _single_speedAccuracy_codec.WriteTagAndValue(ref output, SpeedAccuracy);
      }
      if (horizontalAccuracy_ != null) {
        _single_horizontalAccuracy_codec.WriteTagAndValue(ref output, HorizontalAccuracy);
      }
      if (verticalAccuracy_ != null) {
        _single_verticalAccuracy_codec.WriteTagAndValue(ref output, VerticalAccuracy);
      }
      if (bearingAccuracy_ != null) {
        _single_bearingAccuracy_codec.WriteTagAndValue(ref output, BearingAccuracy);
      }
      if (LocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        output.WriteRawTag(88);
        output.WriteEnum((int) LocationSensor);
      }
      if (isGpsSensorEnabled_ != null) {
        _single_isGpsSensorEnabled_codec.WriteTagAndValue(ref output, IsGpsSensorEnabled);
      }
      if (serverTime_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(ServerTime);
      }
      if (timeSinceUpdate_ != null) {
        _single_timeSinceUpdate_codec.WriteTagAndValue(ref output, TimeSinceUpdate);
      }
      if (numStaleUpdates_ != null) {
        _single_numStaleUpdates_codec.WriteTagAndValue(ref output, NumStaleUpdates);
      }
      if (rawLocation_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RawLocation);
      }
      if (rawLocationTime_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(RawLocationTime);
      }
      if (supplementalLocation_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(SupplementalLocation);
      }
      if (supplementalLocationTime_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(SupplementalLocationTime);
      }
      if (SupplementalLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) SupplementalLocationSensor);
      }
      if (supplementalLocationAccuracy_ != null) {
        _single_supplementalLocationAccuracy_codec.WriteTagAndValue(ref output, SupplementalLocationAccuracy);
      }
      if (latlngAccuracy_ != null) {
        _single_latlngAccuracy_codec.WriteTagAndValue(ref output, LatlngAccuracy);
      }
      if (headingAccuracy_ != null) {
        _single_headingAccuracy_codec.WriteTagAndValue(ref output, HeadingAccuracy);
      }
      if (altitudeAccuracy_ != null) {
        _single_altitudeAccuracy_codec.WriteTagAndValue(ref output, AltitudeAccuracy);
      }
      if (rawLocationAccuracy_ != null) {
        _single_rawLocationAccuracy_codec.WriteTagAndValue(ref output, RawLocationAccuracy);
      }
      if (RoadSnapped != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(RoadSnapped);
      }
      if (isRoadSnapped_ != null) {
        _single_isRoadSnapped_codec.WriteTagAndValue(ref output, IsRoadSnapped);
      }
      if (RawLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        output.WriteRawTag(224, 1);
        output.WriteEnum((int) RawLocationSensor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (location_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Location);
      }
      if (horizontalAccuracy_ != null) {
        size += _single_horizontalAccuracy_codec.CalculateSizeWithTag(HorizontalAccuracy);
      }
      if (latlngAccuracy_ != null) {
        size += _single_latlngAccuracy_codec.CalculateSizeWithTag(LatlngAccuracy);
      }
      if (heading_ != null) {
        size += _single_heading_codec.CalculateSizeWithTag(Heading);
      }
      if (bearingAccuracy_ != null) {
        size += _single_bearingAccuracy_codec.CalculateSizeWithTag(BearingAccuracy);
      }
      if (headingAccuracy_ != null) {
        size += _single_headingAccuracy_codec.CalculateSizeWithTag(HeadingAccuracy);
      }
      if (altitude_ != null) {
        size += _single_altitude_codec.CalculateSizeWithTag(Altitude);
      }
      if (verticalAccuracy_ != null) {
        size += _single_verticalAccuracy_codec.CalculateSizeWithTag(VerticalAccuracy);
      }
      if (altitudeAccuracy_ != null) {
        size += _single_altitudeAccuracy_codec.CalculateSizeWithTag(AltitudeAccuracy);
      }
      if (speedKmph_ != null) {
        size += _single_speedKmph_codec.CalculateSizeWithTag(SpeedKmph);
      }
      if (speed_ != null) {
        size += _single_speed_codec.CalculateSizeWithTag(Speed);
      }
      if (speedAccuracy_ != null) {
        size += _single_speedAccuracy_codec.CalculateSizeWithTag(SpeedAccuracy);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      if (serverTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ServerTime);
      }
      if (LocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LocationSensor);
      }
      if (isRoadSnapped_ != null) {
        size += _single_isRoadSnapped_codec.CalculateSizeWithTag(IsRoadSnapped);
      }
      if (isGpsSensorEnabled_ != null) {
        size += _single_isGpsSensorEnabled_codec.CalculateSizeWithTag(IsGpsSensorEnabled);
      }
      if (timeSinceUpdate_ != null) {
        size += _single_timeSinceUpdate_codec.CalculateSizeWithTag(TimeSinceUpdate);
      }
      if (numStaleUpdates_ != null) {
        size += _single_numStaleUpdates_codec.CalculateSizeWithTag(NumStaleUpdates);
      }
      if (rawLocation_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RawLocation);
      }
      if (rawLocationTime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RawLocationTime);
      }
      if (RawLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) RawLocationSensor);
      }
      if (rawLocationAccuracy_ != null) {
        size += _single_rawLocationAccuracy_codec.CalculateSizeWithTag(RawLocationAccuracy);
      }
      if (supplementalLocation_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SupplementalLocation);
      }
      if (supplementalLocationTime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SupplementalLocationTime);
      }
      if (SupplementalLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) SupplementalLocationSensor);
      }
      if (supplementalLocationAccuracy_ != null) {
        size += _single_supplementalLocationAccuracy_codec.CalculateSizeWithTag(SupplementalLocationAccuracy);
      }
      if (RoadSnapped != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VehicleLocation other) {
      if (other == null) {
        return;
      }
      if (other.location_ != null) {
        if (location_ == null) {
          Location = new global::Google.Type.LatLng();
        }
        Location.MergeFrom(other.Location);
      }
      if (other.horizontalAccuracy_ != null) {
        if (horizontalAccuracy_ == null || other.HorizontalAccuracy != 0D) {
          HorizontalAccuracy = other.HorizontalAccuracy;
        }
      }
      if (other.latlngAccuracy_ != null) {
        if (latlngAccuracy_ == null || other.LatlngAccuracy != 0D) {
          LatlngAccuracy = other.LatlngAccuracy;
        }
      }
      if (other.heading_ != null) {
        if (heading_ == null || other.Heading != 0) {
          Heading = other.Heading;
        }
      }
      if (other.bearingAccuracy_ != null) {
        if (bearingAccuracy_ == null || other.BearingAccuracy != 0D) {
          BearingAccuracy = other.BearingAccuracy;
        }
      }
      if (other.headingAccuracy_ != null) {
        if (headingAccuracy_ == null || other.HeadingAccuracy != 0D) {
          HeadingAccuracy = other.HeadingAccuracy;
        }
      }
      if (other.altitude_ != null) {
        if (altitude_ == null || other.Altitude != 0D) {
          Altitude = other.Altitude;
        }
      }
      if (other.verticalAccuracy_ != null) {
        if (verticalAccuracy_ == null || other.VerticalAccuracy != 0D) {
          VerticalAccuracy = other.VerticalAccuracy;
        }
      }
      if (other.altitudeAccuracy_ != null) {
        if (altitudeAccuracy_ == null || other.AltitudeAccuracy != 0D) {
          AltitudeAccuracy = other.AltitudeAccuracy;
        }
      }
      if (other.speedKmph_ != null) {
        if (speedKmph_ == null || other.SpeedKmph != 0) {
          SpeedKmph = other.SpeedKmph;
        }
      }
      if (other.speed_ != null) {
        if (speed_ == null || other.Speed != 0D) {
          Speed = other.Speed;
        }
      }
      if (other.speedAccuracy_ != null) {
        if (speedAccuracy_ == null || other.SpeedAccuracy != 0D) {
          SpeedAccuracy = other.SpeedAccuracy;
        }
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      if (other.serverTime_ != null) {
        if (serverTime_ == null) {
          ServerTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ServerTime.MergeFrom(other.ServerTime);
      }
      if (other.LocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        LocationSensor = other.LocationSensor;
      }
      if (other.isRoadSnapped_ != null) {
        if (isRoadSnapped_ == null || other.IsRoadSnapped != false) {
          IsRoadSnapped = other.IsRoadSnapped;
        }
      }
      if (other.isGpsSensorEnabled_ != null) {
        if (isGpsSensorEnabled_ == null || other.IsGpsSensorEnabled != false) {
          IsGpsSensorEnabled = other.IsGpsSensorEnabled;
        }
      }
      if (other.timeSinceUpdate_ != null) {
        if (timeSinceUpdate_ == null || other.TimeSinceUpdate != 0) {
          TimeSinceUpdate = other.TimeSinceUpdate;
        }
      }
      if (other.numStaleUpdates_ != null) {
        if (numStaleUpdates_ == null || other.NumStaleUpdates != 0) {
          NumStaleUpdates = other.NumStaleUpdates;
        }
      }
      if (other.rawLocation_ != null) {
        if (rawLocation_ == null) {
          RawLocation = new global::Google.Type.LatLng();
        }
        RawLocation.MergeFrom(other.RawLocation);
      }
      if (other.rawLocationTime_ != null) {
        if (rawLocationTime_ == null) {
          RawLocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        RawLocationTime.MergeFrom(other.RawLocationTime);
      }
      if (other.RawLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        RawLocationSensor = other.RawLocationSensor;
      }
      if (other.rawLocationAccuracy_ != null) {
        if (rawLocationAccuracy_ == null || other.RawLocationAccuracy != 0D) {
          RawLocationAccuracy = other.RawLocationAccuracy;
        }
      }
      if (other.supplementalLocation_ != null) {
        if (supplementalLocation_ == null) {
          SupplementalLocation = new global::Google.Type.LatLng();
        }
        SupplementalLocation.MergeFrom(other.SupplementalLocation);
      }
      if (other.supplementalLocationTime_ != null) {
        if (supplementalLocationTime_ == null) {
          SupplementalLocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        SupplementalLocationTime.MergeFrom(other.SupplementalLocationTime);
      }
      if (other.SupplementalLocationSensor != global::Maps.Fleetengine.V1.LocationSensor.UnknownSensor) {
        SupplementalLocationSensor = other.SupplementalLocationSensor;
      }
      if (other.supplementalLocationAccuracy_ != null) {
        if (supplementalLocationAccuracy_ == null || other.SupplementalLocationAccuracy != 0D) {
          SupplementalLocationAccuracy = other.SupplementalLocationAccuracy;
        }
      }
      if (other.RoadSnapped != false) {
        RoadSnapped = other.RoadSnapped;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (location_ == null) {
              Location = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Location);
            break;
          }
          case 18: {
            int? value = _single_heading_codec.Read(input);
            if (heading_ == null || value != 0) {
              Heading = value;
            }
            break;
          }
          case 26: {
            int? value = _single_speedKmph_codec.Read(input);
            if (speedKmph_ == null || value != 0) {
              SpeedKmph = value;
            }
            break;
          }
          case 34: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 42: {
            double? value = _single_altitude_codec.Read(input);
            if (altitude_ == null || value != 0D) {
              Altitude = value;
            }
            break;
          }
          case 50: {
            double? value = _single_speed_codec.Read(input);
            if (speed_ == null || value != 0D) {
              Speed = value;
            }
            break;
          }
          case 58: {
            double? value = _single_speedAccuracy_codec.Read(input);
            if (speedAccuracy_ == null || value != 0D) {
              SpeedAccuracy = value;
            }
            break;
          }
          case 66: {
            double? value = _single_horizontalAccuracy_codec.Read(input);
            if (horizontalAccuracy_ == null || value != 0D) {
              HorizontalAccuracy = value;
            }
            break;
          }
          case 74: {
            double? value = _single_verticalAccuracy_codec.Read(input);
            if (verticalAccuracy_ == null || value != 0D) {
              VerticalAccuracy = value;
            }
            break;
          }
          case 82: {
            double? value = _single_bearingAccuracy_codec.Read(input);
            if (bearingAccuracy_ == null || value != 0D) {
              BearingAccuracy = value;
            }
            break;
          }
          case 88: {
            LocationSensor = (global::Maps.Fleetengine.V1.LocationSensor) input.ReadEnum();
            break;
          }
          case 98: {
            bool? value = _single_isGpsSensorEnabled_codec.Read(input);
            if (isGpsSensorEnabled_ == null || value != false) {
              IsGpsSensorEnabled = value;
            }
            break;
          }
          case 106: {
            if (serverTime_ == null) {
              ServerTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ServerTime);
            break;
          }
          case 114: {
            int? value = _single_timeSinceUpdate_codec.Read(input);
            if (timeSinceUpdate_ == null || value != 0) {
              TimeSinceUpdate = value;
            }
            break;
          }
          case 122: {
            int? value = _single_numStaleUpdates_codec.Read(input);
            if (numStaleUpdates_ == null || value != 0) {
              NumStaleUpdates = value;
            }
            break;
          }
          case 130: {
            if (rawLocation_ == null) {
              RawLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(RawLocation);
            break;
          }
          case 138: {
            if (rawLocationTime_ == null) {
              RawLocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RawLocationTime);
            break;
          }
          case 146: {
            if (supplementalLocation_ == null) {
              SupplementalLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(SupplementalLocation);
            break;
          }
          case 154: {
            if (supplementalLocationTime_ == null) {
              SupplementalLocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(SupplementalLocationTime);
            break;
          }
          case 160: {
            SupplementalLocationSensor = (global::Maps.Fleetengine.V1.LocationSensor) input.ReadEnum();
            break;
          }
          case 170: {
            double? value = _single_supplementalLocationAccuracy_codec.Read(input);
            if (supplementalLocationAccuracy_ == null || value != 0D) {
              SupplementalLocationAccuracy = value;
            }
            break;
          }
          case 178: {
            double? value = _single_latlngAccuracy_codec.Read(input);
            if (latlngAccuracy_ == null || value != 0D) {
              LatlngAccuracy = value;
            }
            break;
          }
          case 186: {
            double? value = _single_headingAccuracy_codec.Read(input);
            if (headingAccuracy_ == null || value != 0D) {
              HeadingAccuracy = value;
            }
            break;
          }
          case 194: {
            double? value = _single_altitudeAccuracy_codec.Read(input);
            if (altitudeAccuracy_ == null || value != 0D) {
              AltitudeAccuracy = value;
            }
            break;
          }
          case 202: {
            double? value = _single_rawLocationAccuracy_codec.Read(input);
            if (rawLocationAccuracy_ == null || value != 0D) {
              RawLocationAccuracy = value;
            }
            break;
          }
          case 208: {
            RoadSnapped = input.ReadBool();
            break;
          }
          case 218: {
            bool? value = _single_isRoadSnapped_codec.Read(input);
            if (isRoadSnapped_ == null || value != false) {
              IsRoadSnapped = value;
            }
            break;
          }
          case 224: {
            RawLocationSensor = (global::Maps.Fleetengine.V1.LocationSensor) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (location_ == null) {
              Location = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Location);
            break;
          }
          case 18: {
            int? value = _single_heading_codec.Read(ref input);
            if (heading_ == null || value != 0) {
              Heading = value;
            }
            break;
          }
          case 26: {
            int? value = _single_speedKmph_codec.Read(ref input);
            if (speedKmph_ == null || value != 0) {
              SpeedKmph = value;
            }
            break;
          }
          case 34: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 42: {
            double? value = _single_altitude_codec.Read(ref input);
            if (altitude_ == null || value != 0D) {
              Altitude = value;
            }
            break;
          }
          case 50: {
            double? value = _single_speed_codec.Read(ref input);
            if (speed_ == null || value != 0D) {
              Speed = value;
            }
            break;
          }
          case 58: {
            double? value = _single_speedAccuracy_codec.Read(ref input);
            if (speedAccuracy_ == null || value != 0D) {
              SpeedAccuracy = value;
            }
            break;
          }
          case 66: {
            double? value = _single_horizontalAccuracy_codec.Read(ref input);
            if (horizontalAccuracy_ == null || value != 0D) {
              HorizontalAccuracy = value;
            }
            break;
          }
          case 74: {
            double? value = _single_verticalAccuracy_codec.Read(ref input);
            if (verticalAccuracy_ == null || value != 0D) {
              VerticalAccuracy = value;
            }
            break;
          }
          case 82: {
            double? value = _single_bearingAccuracy_codec.Read(ref input);
            if (bearingAccuracy_ == null || value != 0D) {
              BearingAccuracy = value;
            }
            break;
          }
          case 88: {
            LocationSensor = (global::Maps.Fleetengine.V1.LocationSensor) input.ReadEnum();
            break;
          }
          case 98: {
            bool? value = _single_isGpsSensorEnabled_codec.Read(ref input);
            if (isGpsSensorEnabled_ == null || value != false) {
              IsGpsSensorEnabled = value;
            }
            break;
          }
          case 106: {
            if (serverTime_ == null) {
              ServerTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ServerTime);
            break;
          }
          case 114: {
            int? value = _single_timeSinceUpdate_codec.Read(ref input);
            if (timeSinceUpdate_ == null || value != 0) {
              TimeSinceUpdate = value;
            }
            break;
          }
          case 122: {
            int? value = _single_numStaleUpdates_codec.Read(ref input);
            if (numStaleUpdates_ == null || value != 0) {
              NumStaleUpdates = value;
            }
            break;
          }
          case 130: {
            if (rawLocation_ == null) {
              RawLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(RawLocation);
            break;
          }
          case 138: {
            if (rawLocationTime_ == null) {
              RawLocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RawLocationTime);
            break;
          }
          case 146: {
            if (supplementalLocation_ == null) {
              SupplementalLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(SupplementalLocation);
            break;
          }
          case 154: {
            if (supplementalLocationTime_ == null) {
              SupplementalLocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(SupplementalLocationTime);
            break;
          }
          case 160: {
            SupplementalLocationSensor = (global::Maps.Fleetengine.V1.LocationSensor) input.ReadEnum();
            break;
          }
          case 170: {
            double? value = _single_supplementalLocationAccuracy_codec.Read(ref input);
            if (supplementalLocationAccuracy_ == null || value != 0D) {
              SupplementalLocationAccuracy = value;
            }
            break;
          }
          case 178: {
            double? value = _single_latlngAccuracy_codec.Read(ref input);
            if (latlngAccuracy_ == null || value != 0D) {
              LatlngAccuracy = value;
            }
            break;
          }
          case 186: {
            double? value = _single_headingAccuracy_codec.Read(ref input);
            if (headingAccuracy_ == null || value != 0D) {
              HeadingAccuracy = value;
            }
            break;
          }
          case 194: {
            double? value = _single_altitudeAccuracy_codec.Read(ref input);
            if (altitudeAccuracy_ == null || value != 0D) {
              AltitudeAccuracy = value;
            }
            break;
          }
          case 202: {
            double? value = _single_rawLocationAccuracy_codec.Read(ref input);
            if (rawLocationAccuracy_ == null || value != 0D) {
              RawLocationAccuracy = value;
            }
            break;
          }
          case 208: {
            RoadSnapped = input.ReadBool();
            break;
          }
          case 218: {
            bool? value = _single_isRoadSnapped_codec.Read(ref input);
            if (isRoadSnapped_ == null || value != false) {
              IsRoadSnapped = value;
            }
            break;
          }
          case 224: {
            RawLocationSensor = (global::Maps.Fleetengine.V1.LocationSensor) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
