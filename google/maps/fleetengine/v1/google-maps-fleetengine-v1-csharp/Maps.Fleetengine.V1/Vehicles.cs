// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/fleetengine/v1/vehicles.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Maps.Fleetengine.V1 {

  /// <summary>Holder for reflection information generated from google/maps/fleetengine/v1/vehicles.proto</summary>
  public static partial class VehiclesReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/fleetengine/v1/vehicles.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static VehiclesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cilnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS92ZWhpY2xlcy5wcm90bxIT",
            "bWFwcy5mbGVldGVuZ2luZS52MRofZ29vZ2xlL2FwaS9maWVsZF9iZWhhdmlv",
            "ci5wcm90bxoZZ29vZ2xlL2FwaS9yZXNvdXJjZS5wcm90bxosZ29vZ2xlL21h",
            "cHMvZmxlZXRlbmdpbmUvdjEvZmxlZXRlbmdpbmUucHJvdG8aH2dvb2dsZS9w",
            "cm90b2J1Zi90aW1lc3RhbXAucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93cmFw",
            "cGVycy5wcm90byLoCgoHVmVoaWNsZRIMCgRuYW1lGAEgASgJEjgKDXZlaGlj",
            "bGVfc3RhdGUYAiABKA4yIS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGVT",
            "dGF0ZRI7ChRzdXBwb3J0ZWRfdHJpcF90eXBlcxgDIAMoDjIdLm1hcHMuZmxl",
            "ZXRlbmdpbmUudjEuVHJpcFR5cGUSFQoNY3VycmVudF90cmlwcxgEIAMoCRI7",
            "Cg1sYXN0X2xvY2F0aW9uGAUgASgLMiQubWFwcy5mbGVldGVuZ2luZS52MS5W",
            "ZWhpY2xlTG9jYXRpb24SGAoQbWF4aW11bV9jYXBhY2l0eRgGIAEoBRIaChJh",
            "dmFpbGFibGVfY2FwYWNpdHkYByABKAUSOQoKYXR0cmlidXRlcxgIIAMoCzIl",
            "Lm1hcHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZUF0dHJpYnV0ZRI+Cgx2ZWhp",
            "Y2xlX3R5cGUYCSABKAsyKC5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGUu",
            "VmVoaWNsZVR5cGUSOAoNbGljZW5zZV9wbGF0ZRgKIAEoCzIhLm1hcHMuZmxl",
            "ZXRlbmdpbmUudjEuTGljZW5zZVBsYXRlEjgKBXJvdXRlGAwgAygLMiUubWFw",
            "cy5mbGVldGVuZ2luZS52MS5UZXJtaW5hbExvY2F0aW9uQgIYARIdChVjdXJy",
            "ZW50X3JvdXRlX3NlZ21lbnQYFCABKAkSQQodY3VycmVudF9yb3V0ZV9zZWdt",
            "ZW50X3ZlcnNpb24YDyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1w",
            "EkoKH2N1cnJlbnRfcm91dGVfc2VnbWVudF9lbmRfcG9pbnQYGCABKAsyIS5t",
            "YXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBXYXlwb2ludBI+ChlyZW1haW5pbmdf",
            "ZGlzdGFuY2VfbWV0ZXJzGBIgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDMy",
            "VmFsdWUSOQoVZXRhX3RvX2ZpcnN0X3dheXBvaW50GBMgASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLlRpbWVzdGFtcBI7ChZyZW1haW5pbmdfdGltZV9zZWNvbmRz",
            "GBkgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUSNAoJd2F5cG9p",
            "bnRzGBYgAygLMiEubWFwcy5mbGVldGVuZ2luZS52MS5UcmlwV2F5cG9pbnQS",
            "NQoRd2F5cG9pbnRzX3ZlcnNpb24YECABKAsyGi5nb29nbGUucHJvdG9idWYu",
            "VGltZXN0YW1wEhwKFGJhY2tfdG9fYmFja19lbmFibGVkGBcgASgIEkAKEW5h",
            "dmlnYXRpb25fc3RhdHVzGBogASgOMiUubWFwcy5mbGVldGVuZ2luZS52MS5O",
            "YXZpZ2F0aW9uU3RhdHVzEjwKD2RldmljZV9zZXR0aW5ncxgbIAEoCzIjLm1h",
            "cHMuZmxlZXRlbmdpbmUudjEuRGV2aWNlU2V0dGluZ3MamwEKC1ZlaGljbGVU",
            "eXBlEkMKCGNhdGVnb3J5GAEgASgOMjEubWFwcy5mbGVldGVuZ2luZS52MS5W",
            "ZWhpY2xlLlZlaGljbGVUeXBlLkNhdGVnb3J5IkcKCENhdGVnb3J5EgsKB1VO",
            "S05PV04QABIICgRBVVRPEAESCAoEVEFYSRACEgkKBVRSVUNLEAMSDwoLVFdP",
            "X1dIRUVMRVIQBDpQ6kFNCiJmbGVldGVuZ2luZS5nb29nbGVhcGlzLmNvbS9W",
            "ZWhpY2xlEidwcm92aWRlcnMve3Byb3ZpZGVyfS92ZWhpY2xlcy97dmVoaWNs",
            "ZX0inQEKC0JhdHRlcnlJbmZvEjoKDmJhdHRlcnlfc3RhdHVzGAEgASgOMiIu",
            "bWFwcy5mbGVldGVuZ2luZS52MS5CYXR0ZXJ5U3RhdHVzEjYKDHBvd2VyX3Nv",
            "dXJjZRgCIAEoDjIgLm1hcHMuZmxlZXRlbmdpbmUudjEuUG93ZXJTb3VyY2US",
            "GgoSYmF0dGVyeV9wZXJjZW50YWdlGAMgASgCIsoBCg5EZXZpY2VTZXR0aW5n",
            "cxJMChhsb2NhdGlvbl9wb3dlcl9zYXZlX21vZGUYASABKA4yKi5tYXBzLmZs",
            "ZWV0ZW5naW5lLnYxLkxvY2F0aW9uUG93ZXJTYXZlTW9kZRIaChJpc19wb3dl",
            "cl9zYXZlX21vZGUYAiABKAgSFgoOaXNfaW50ZXJhY3RpdmUYAyABKAgSNgoM",
            "YmF0dGVyeV9pbmZvGAQgASgLMiAubWFwcy5mbGVldGVuZ2luZS52MS5CYXR0",
            "ZXJ5SW5mbyJBCgxMaWNlbnNlUGxhdGUSGQoMY291bnRyeV9jb2RlGAEgASgJ",
            "QgPgQQISFgoObGFzdF9jaGFyYWN0ZXIYAiABKAkqQgoMVmVoaWNsZVN0YXRl",
            "EhkKFVVOS05PV05fVkVISUNMRV9TVEFURRAAEgsKB09GRkxJTkUQARIKCgZP",
            "TkxJTkUQAiqSAgoVTG9jYXRpb25Qb3dlclNhdmVNb2RlEiQKIFVOS05PV05f",
            "TE9DQVRJT05fUE9XRVJfU0FWRV9NT0RFEAASGwoXTE9DQVRJT05fTU9ERV9O",
            "T19DSEFOR0UQARIuCipMT0NBVElPTl9NT0RFX0dQU19ESVNBQkxFRF9XSEVO",
            "X1NDUkVFTl9PRkYQAhIuCipMT0NBVElPTl9NT0RFX0FMTF9ESVNBQkxFRF9X",
            "SEVOX1NDUkVFTl9PRkYQAxIhCh1MT0NBVElPTl9NT0RFX0ZPUkVHUk9VTkRf",
            "T05MWRAEEjMKL0xPQ0FUSU9OX01PREVfVEhST1RUTEVfUkVRVUVTVFNfV0hF",
            "Tl9TQ1JFRU5fT0ZGEAUqwAEKDUJhdHRlcnlTdGF0dXMSGgoWVU5LTk9XTl9C",
            "QVRURVJZX1NUQVRVUxAAEhsKF0JBVFRFUllfU1RBVFVTX0NIQVJHSU5HEAES",
            "HgoaQkFUVEVSWV9TVEFUVVNfRElTQ0hBUkdJTkcQAhIXChNCQVRURVJZX1NU",
            "QVRVU19GVUxMEAMSHwobQkFUVEVSWV9TVEFUVVNfTk9UX0NIQVJHSU5HEAQS",
            "HAoYQkFUVEVSWV9TVEFUVVNfUE9XRVJfTE9XEAUqiQEKC1Bvd2VyU291cmNl",
            "EhgKFFVOS05PV05fUE9XRVJfU09VUkNFEAASEwoPUE9XRVJfU09VUkNFX0FD",
            "EAESFAoQUE9XRVJfU09VUkNFX1VTQhACEhkKFVBPV0VSX1NPVVJDRV9XSVJF",
            "TEVTUxADEhoKFlBPV0VSX1NPVVJDRV9VTlBMVUdHRUQQBEJ1Chpnb29nbGUu",
            "bWFwcy5mbGVldGVuZ2luZS52MUIIVmVoaWNsZXNQAVpFZ29vZ2xlLmdvbGFu",
            "Zy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9tYXBzL2ZsZWV0ZW5naW5lL3Yx",
            "O2ZsZWV0ZW5naW5logIDQ0ZFYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Maps.Fleetengine.V1.VehicleState), typeof(global::Maps.Fleetengine.V1.LocationPowerSaveMode), typeof(global::Maps.Fleetengine.V1.BatteryStatus), typeof(global::Maps.Fleetengine.V1.PowerSource), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.Vehicle), global::Maps.Fleetengine.V1.Vehicle.Parser, new[]{ "Name", "VehicleState", "SupportedTripTypes", "CurrentTrips", "LastLocation", "MaximumCapacity", "AvailableCapacity", "Attributes", "VehicleType", "LicensePlate", "Route", "CurrentRouteSegment", "CurrentRouteSegmentVersion", "CurrentRouteSegmentEndPoint", "RemainingDistanceMeters", "EtaToFirstWaypoint", "RemainingTimeSeconds", "Waypoints", "WaypointsVersion", "BackToBackEnabled", "NavigationStatus", "DeviceSettings" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType), global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Parser, new[]{ "Category" }, null, new[]{ typeof(global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.BatteryInfo), global::Maps.Fleetengine.V1.BatteryInfo.Parser, new[]{ "BatteryStatus", "PowerSource", "BatteryPercentage" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.DeviceSettings), global::Maps.Fleetengine.V1.DeviceSettings.Parser, new[]{ "LocationPowerSaveMode", "IsPowerSaveMode", "IsInteractive", "BatteryInfo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.LicensePlate), global::Maps.Fleetengine.V1.LicensePlate.Parser, new[]{ "CountryCode", "LastCharacter" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// The state of a Vehicle.
  /// </summary>
  public enum VehicleState {
    /// <summary>
    /// Default, used for unspecified or unrecognized vehicle states.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_VEHICLE_STATE")] UnknownVehicleState = 0,
    /// <summary>
    /// The vehicle is not accepting new trips.
    /// </summary>
    [pbr::OriginalName("OFFLINE")] Offline = 1,
    /// <summary>
    /// The vehicle is accepting new trips.
    /// </summary>
    [pbr::OriginalName("ONLINE")] Online = 2,
  }

  /// <summary>
  /// How location features are set to behave on the device when battery saver is
  /// on.
  /// (https://developer.android.com/reference/android/os/PowerManager#getLocationPowerSaveMode())
  /// </summary>
  public enum LocationPowerSaveMode {
    /// <summary>
    /// Undefined LocationPowerSaveMode
    /// </summary>
    [pbr::OriginalName("UNKNOWN_LOCATION_POWER_SAVE_MODE")] UnknownLocationPowerSaveMode = 0,
    /// <summary>
    /// Either the location providers shouldn't be affected by battery saver, or
    /// battery saver is off.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_NO_CHANGE")] LocationModeNoChange = 1,
    /// <summary>
    /// The GPS based location provider should be disabled when battery saver is on
    /// and the device is non-interactive.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF")] LocationModeGpsDisabledWhenScreenOff = 2,
    /// <summary>
    /// All location providers should be disabled when battery saver is on and the
    /// device is non-interactive.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF")] LocationModeAllDisabledWhenScreenOff = 3,
    /// <summary>
    /// All the location providers will be kept available, but location fixes
    /// should only be provided to foreground apps.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_FOREGROUND_ONLY")] LocationModeForegroundOnly = 4,
    /// <summary>
    /// Location will not be turned off, but LocationManager will throttle all
    /// requests to providers when the device is non-interactive.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF")] LocationModeThrottleRequestsWhenScreenOff = 5,
  }

  /// <summary>
  /// Status of the battery, whether full or charging etc.
  /// </summary>
  public enum BatteryStatus {
    /// <summary>
    /// Battery status unknown.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_BATTERY_STATUS")] UnknownBatteryStatus = 0,
    /// <summary>
    /// Battery is being charged.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_CHARGING")] Charging = 1,
    /// <summary>
    /// Battery is discharging.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_DISCHARGING")] Discharging = 2,
    /// <summary>
    /// Battery is full.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_FULL")] Full = 3,
    /// <summary>
    /// Battery is not charging.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_NOT_CHARGING")] NotCharging = 4,
    /// <summary>
    /// Battery is low on power.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_POWER_LOW")] PowerLow = 5,
  }

  /// <summary>
  /// Type of the charger being used to charge the battery.
  /// </summary>
  public enum PowerSource {
    /// <summary>
    /// Power source unknown.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_POWER_SOURCE")] UnknownPowerSource = 0,
    /// <summary>
    /// Power source is an AC charger.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_AC")] Ac = 1,
    /// <summary>
    /// Power source is a USB port.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_USB")] Usb = 2,
    /// <summary>
    /// Power source is wireless.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_WIRELESS")] Wireless = 3,
    /// <summary>
    /// Battery is unplugged.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_UNPLUGGED")] Unplugged = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Vehicle metadata.
  /// </summary>
  public sealed partial class Vehicle : pb::IMessage<Vehicle>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Vehicle> _parser = new pb::MessageParser<Vehicle>(() => new Vehicle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Vehicle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehiclesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vehicle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vehicle(Vehicle other) : this() {
      name_ = other.name_;
      vehicleState_ = other.vehicleState_;
      supportedTripTypes_ = other.supportedTripTypes_.Clone();
      currentTrips_ = other.currentTrips_.Clone();
      lastLocation_ = other.lastLocation_ != null ? other.lastLocation_.Clone() : null;
      maximumCapacity_ = other.maximumCapacity_;
      availableCapacity_ = other.availableCapacity_;
      attributes_ = other.attributes_.Clone();
      vehicleType_ = other.vehicleType_ != null ? other.vehicleType_.Clone() : null;
      licensePlate_ = other.licensePlate_ != null ? other.licensePlate_.Clone() : null;
      route_ = other.route_.Clone();
      currentRouteSegment_ = other.currentRouteSegment_;
      currentRouteSegmentVersion_ = other.currentRouteSegmentVersion_ != null ? other.currentRouteSegmentVersion_.Clone() : null;
      currentRouteSegmentEndPoint_ = other.currentRouteSegmentEndPoint_ != null ? other.currentRouteSegmentEndPoint_.Clone() : null;
      RemainingDistanceMeters = other.RemainingDistanceMeters;
      etaToFirstWaypoint_ = other.etaToFirstWaypoint_ != null ? other.etaToFirstWaypoint_.Clone() : null;
      RemainingTimeSeconds = other.RemainingTimeSeconds;
      waypoints_ = other.waypoints_.Clone();
      waypointsVersion_ = other.waypointsVersion_ != null ? other.waypointsVersion_.Clone() : null;
      backToBackEnabled_ = other.backToBackEnabled_;
      navigationStatus_ = other.navigationStatus_;
      deviceSettings_ = other.deviceSettings_ != null ? other.deviceSettings_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vehicle Clone() {
      return new Vehicle(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The unique name for this vehicle.
    /// The format is providers/{provider}/vehicles/{vehicle}
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle_state" field.</summary>
    public const int VehicleStateFieldNumber = 2;
    private global::Maps.Fleetengine.V1.VehicleState vehicleState_ = global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState;
    /// <summary>
    /// The vehicle state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.VehicleState VehicleState {
      get { return vehicleState_; }
      set {
        vehicleState_ = value;
      }
    }

    /// <summary>Field number for the "supported_trip_types" field.</summary>
    public const int SupportedTripTypesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TripType> _repeated_supportedTripTypes_codec
        = pb::FieldCodec.ForEnum(26, x => (int) x, x => (global::Maps.Fleetengine.V1.TripType) x);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType> supportedTripTypes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType>();
    /// <summary>
    /// Supported trip types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType> SupportedTripTypes {
      get { return supportedTripTypes_; }
    }

    /// <summary>Field number for the "current_trips" field.</summary>
    public const int CurrentTripsFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_currentTrips_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> currentTrips_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of IDs for trips in progress.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CurrentTrips {
      get { return currentTrips_; }
    }

    /// <summary>Field number for the "last_location" field.</summary>
    public const int LastLocationFieldNumber = 5;
    private global::Maps.Fleetengine.V1.VehicleLocation lastLocation_;
    /// <summary>
    /// Last reported location of the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.VehicleLocation LastLocation {
      get { return lastLocation_; }
      set {
        lastLocation_ = value;
      }
    }

    /// <summary>Field number for the "maximum_capacity" field.</summary>
    public const int MaximumCapacityFieldNumber = 6;
    private int maximumCapacity_;
    /// <summary>
    /// Maximum capacity of the vehicle.  This is the total numbers of riders
    /// on trips this vehicle can contain.  The driver is not considered in
    /// this value.  This value must be greater than or equal to one.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaximumCapacity {
      get { return maximumCapacity_; }
      set {
        maximumCapacity_ = value;
      }
    }

    /// <summary>Field number for the "available_capacity" field.</summary>
    public const int AvailableCapacityFieldNumber = 7;
    private int availableCapacity_;
    /// <summary>
    /// The current available capacity of the vehicle.  This is the
    /// maximum_capacity minus the current number of riders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int AvailableCapacity {
      get { return availableCapacity_; }
      set {
        availableCapacity_ = value;
      }
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(66, global::Maps.Fleetengine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute>();
    /// <summary>
    /// List of vehicle service attributes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "vehicle_type" field.</summary>
    public const int VehicleTypeFieldNumber = 9;
    private global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType vehicleType_;
    /// <summary>
    /// The type of this Vehicle.  Can be filtered during SearchVehicles.  Also
    /// influences ETA and route calculations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType VehicleType {
      get { return vehicleType_; }
      set {
        vehicleType_ = value;
      }
    }

    /// <summary>Field number for the "license_plate" field.</summary>
    public const int LicensePlateFieldNumber = 10;
    private global::Maps.Fleetengine.V1.LicensePlate licensePlate_;
    /// <summary>
    /// License plate information for the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.LicensePlate LicensePlate {
      get { return licensePlate_; }
      set {
        licensePlate_ = value;
      }
    }

    /// <summary>Field number for the "route" field.</summary>
    public const int RouteFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TerminalLocation> _repeated_route_codec
        = pb::FieldCodec.ForMessage(98, global::Maps.Fleetengine.V1.TerminalLocation.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TerminalLocation> route_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TerminalLocation>();
    /// <summary>
    /// Deprecated. Use vehicle.waypoint instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TerminalLocation> Route {
      get { return route_; }
    }

    /// <summary>Field number for the "current_route_segment" field.</summary>
    public const int CurrentRouteSegmentFieldNumber = 20;
    private string currentRouteSegment_ = "";
    /// <summary>
    /// The polyline specifying the route the driver app intends to take to
    /// the next waypoint. Your driver app updates this every time a waypoint is
    /// passed or the driver reroutes. This list is also returned in
    /// Trip.current_route_segment for all active trips assigned to the vehicle.
    /// Note: This field is intended only for use by the Driver SDK.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CurrentRouteSegment {
      get { return currentRouteSegment_; }
      set {
        currentRouteSegment_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "current_route_segment_version" field.</summary>
    public const int CurrentRouteSegmentVersionFieldNumber = 15;
    private global::Google.Protobuf.WellKnownTypes.Timestamp currentRouteSegmentVersion_;
    /// <summary>
    /// Time when current_route_segment was set. This field is ignored in
    /// UpdateVehicleRequests as it is calculated by the server. It should be
    /// stored by client and passed in to future requests to prevent returning
    /// routes to first way point that haven't changed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CurrentRouteSegmentVersion {
      get { return currentRouteSegmentVersion_; }
      set {
        currentRouteSegmentVersion_ = value;
      }
    }

    /// <summary>Field number for the "current_route_segment_end_point" field.</summary>
    public const int CurrentRouteSegmentEndPointFieldNumber = 24;
    private global::Maps.Fleetengine.V1.TripWaypoint currentRouteSegmentEndPoint_;
    /// <summary>
    /// The waypoint where current_route_segment ends. This can be supplied by
    /// drivers on UpdateVehicle calls either as a full trip waypoint, a waypoint
    /// latlnt, or as a the last latlng of the current_route_segment. FleetEngine
    /// will then do its best to interpolate to an actual waypoint if it is not
    /// fully specified. This field is ignored in UpdateVehicle calls unless
    /// current_route_segment is also specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TripWaypoint CurrentRouteSegmentEndPoint {
      get { return currentRouteSegmentEndPoint_; }
      set {
        currentRouteSegmentEndPoint_ = value;
      }
    }

    /// <summary>Field number for the "remaining_distance_meters" field.</summary>
    public const int RemainingDistanceMetersFieldNumber = 18;
    private static readonly pb::FieldCodec<int?> _single_remainingDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(146);
    private int? remainingDistanceMeters_;
    /// <summary>
    /// The remaining driving distance for the 'current_route_segment'. This field
    /// facilitates journey sharing between the Driver app and the Consumer app.
    /// This value is updated by the Driver SDK. Fleet Engine does not update it.
    /// This field is also returned in Trip.remaining_distance_meters for all
    /// active trips assigned to the vehicle. The value is unspecified if the
    /// `Vehicle.current_route_segment` field is empty, or if the Driver app has
    /// not updated its value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? RemainingDistanceMeters {
      get { return remainingDistanceMeters_; }
      set {
        remainingDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "eta_to_first_waypoint" field.</summary>
    public const int EtaToFirstWaypointFieldNumber = 19;
    private global::Google.Protobuf.WellKnownTypes.Timestamp etaToFirstWaypoint_;
    /// <summary>
    /// The ETA to the next waypoint that is the first entry in Vehicle.waypoint
    /// field. This field facilitates journey sharing between a Driver app and a
    /// Consumer app and is updated by the Driver SDK, and Fleet Engine does not
    /// update it. This field is also returned in Trip.eta_to_first_waypoint for
    /// all active trips assigned to the vehicle. The value is unspecified if the
    /// Vehicle.waypoint field is empty, or the Driver app has not updated its
    /// value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EtaToFirstWaypoint {
      get { return etaToFirstWaypoint_; }
      set {
        etaToFirstWaypoint_ = value;
      }
    }

    /// <summary>Field number for the "remaining_time_seconds" field.</summary>
    public const int RemainingTimeSecondsFieldNumber = 25;
    private static readonly pb::FieldCodec<int?> _single_remainingTimeSeconds_codec = pb::FieldCodec.ForStructWrapper<int>(202);
    private int? remainingTimeSeconds_;
    /// <summary>
    /// The remaining driving time for the 'current_route_segment'. This field
    /// facilitates journey sharing between the Driver app and the Consumer app.
    /// This value is updated by the Driver SDK. Fleet Engine does not update it.
    /// The value is unspecified if the `Vehicle.current_route_segment` field is
    /// empty, or if the Driver app has not updated its value. This value should
    /// match eta_to_first_waypoint - current_time if all parties are using the
    /// same clock. This field is currently write-only and will not yet be
    /// populated in Vehicle's get/update/search operations. When updating a
    /// vehicle, if you update both eta_to_first_waypoint and
    /// remaining_time_seconds in the same request, then only
    /// remaining_time_seconds is considered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? RemainingTimeSeconds {
      get { return remainingTimeSeconds_; }
      set {
        remainingTimeSeconds_ = value;
      }
    }


    /// <summary>Field number for the "waypoints" field.</summary>
    public const int WaypointsFieldNumber = 22;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TripWaypoint> _repeated_waypoints_codec
        = pb::FieldCodec.ForMessage(178, global::Maps.Fleetengine.V1.TripWaypoint.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint> waypoints_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint>();
    /// <summary>
    /// The remaining set of waypoints assigned to this Vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TripWaypoint> Waypoints {
      get { return waypoints_; }
    }

    /// <summary>Field number for the "waypoints_version" field.</summary>
    public const int WaypointsVersionFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Timestamp waypointsVersion_;
    /// <summary>
    /// Last time the waypoints was updated. Client should cache
    /// this value and pass it in GetVehicleRequest to ensure the
    /// waypoints.path_to_waypoint is only returned if it is updated
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp WaypointsVersion {
      get { return waypointsVersion_; }
      set {
        waypointsVersion_ = value;
      }
    }

    /// <summary>Field number for the "back_to_back_enabled" field.</summary>
    public const int BackToBackEnabledFieldNumber = 23;
    private bool backToBackEnabled_;
    /// <summary>
    /// Indicates if the driver accepts back-to-back rides. If
    /// `true`, services include the vehicle for back-to-back matches.
    /// If `false`, services exclude the vehicle from back-to-back matches.
    /// Default value is `false`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BackToBackEnabled {
      get { return backToBackEnabled_; }
      set {
        backToBackEnabled_ = value;
      }
    }

    /// <summary>Field number for the "navigation_status" field.</summary>
    public const int NavigationStatusFieldNumber = 26;
    private global::Maps.Fleetengine.V1.NavigationStatus navigationStatus_ = global::Maps.Fleetengine.V1.NavigationStatus.UnknownNavigationStatus;
    /// <summary>
    /// Vehicle's navigation status.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.NavigationStatus NavigationStatus {
      get { return navigationStatus_; }
      set {
        navigationStatus_ = value;
      }
    }

    /// <summary>Field number for the "device_settings" field.</summary>
    public const int DeviceSettingsFieldNumber = 27;
    private global::Maps.Fleetengine.V1.DeviceSettings deviceSettings_;
    /// <summary>
    /// Information about various device settings. This is internal debug only
    /// field, not included in the response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.DeviceSettings DeviceSettings {
      get { return deviceSettings_; }
      set {
        deviceSettings_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Vehicle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Vehicle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (VehicleState != other.VehicleState) return false;
      if(!supportedTripTypes_.Equals(other.supportedTripTypes_)) return false;
      if(!currentTrips_.Equals(other.currentTrips_)) return false;
      if (!object.Equals(LastLocation, other.LastLocation)) return false;
      if (MaximumCapacity != other.MaximumCapacity) return false;
      if (AvailableCapacity != other.AvailableCapacity) return false;
      if(!attributes_.Equals(other.attributes_)) return false;
      if (!object.Equals(VehicleType, other.VehicleType)) return false;
      if (!object.Equals(LicensePlate, other.LicensePlate)) return false;
      if(!route_.Equals(other.route_)) return false;
      if (CurrentRouteSegment != other.CurrentRouteSegment) return false;
      if (!object.Equals(CurrentRouteSegmentVersion, other.CurrentRouteSegmentVersion)) return false;
      if (!object.Equals(CurrentRouteSegmentEndPoint, other.CurrentRouteSegmentEndPoint)) return false;
      if (RemainingDistanceMeters != other.RemainingDistanceMeters) return false;
      if (!object.Equals(EtaToFirstWaypoint, other.EtaToFirstWaypoint)) return false;
      if (RemainingTimeSeconds != other.RemainingTimeSeconds) return false;
      if(!waypoints_.Equals(other.waypoints_)) return false;
      if (!object.Equals(WaypointsVersion, other.WaypointsVersion)) return false;
      if (BackToBackEnabled != other.BackToBackEnabled) return false;
      if (NavigationStatus != other.NavigationStatus) return false;
      if (!object.Equals(DeviceSettings, other.DeviceSettings)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) hash ^= VehicleState.GetHashCode();
      hash ^= supportedTripTypes_.GetHashCode();
      hash ^= currentTrips_.GetHashCode();
      if (lastLocation_ != null) hash ^= LastLocation.GetHashCode();
      if (MaximumCapacity != 0) hash ^= MaximumCapacity.GetHashCode();
      if (AvailableCapacity != 0) hash ^= AvailableCapacity.GetHashCode();
      hash ^= attributes_.GetHashCode();
      if (vehicleType_ != null) hash ^= VehicleType.GetHashCode();
      if (licensePlate_ != null) hash ^= LicensePlate.GetHashCode();
      hash ^= route_.GetHashCode();
      if (CurrentRouteSegment.Length != 0) hash ^= CurrentRouteSegment.GetHashCode();
      if (currentRouteSegmentVersion_ != null) hash ^= CurrentRouteSegmentVersion.GetHashCode();
      if (currentRouteSegmentEndPoint_ != null) hash ^= CurrentRouteSegmentEndPoint.GetHashCode();
      if (remainingDistanceMeters_ != null) hash ^= RemainingDistanceMeters.GetHashCode();
      if (etaToFirstWaypoint_ != null) hash ^= EtaToFirstWaypoint.GetHashCode();
      if (remainingTimeSeconds_ != null) hash ^= RemainingTimeSeconds.GetHashCode();
      hash ^= waypoints_.GetHashCode();
      if (waypointsVersion_ != null) hash ^= WaypointsVersion.GetHashCode();
      if (BackToBackEnabled != false) hash ^= BackToBackEnabled.GetHashCode();
      if (NavigationStatus != global::Maps.Fleetengine.V1.NavigationStatus.UnknownNavigationStatus) hash ^= NavigationStatus.GetHashCode();
      if (deviceSettings_ != null) hash ^= DeviceSettings.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(16);
        output.WriteEnum((int) VehicleState);
      }
      supportedTripTypes_.WriteTo(output, _repeated_supportedTripTypes_codec);
      currentTrips_.WriteTo(output, _repeated_currentTrips_codec);
      if (lastLocation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(LastLocation);
      }
      if (MaximumCapacity != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(MaximumCapacity);
      }
      if (AvailableCapacity != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(AvailableCapacity);
      }
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (vehicleType_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(VehicleType);
      }
      if (licensePlate_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LicensePlate);
      }
      route_.WriteTo(output, _repeated_route_codec);
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(WaypointsVersion);
      }
      if (remainingDistanceMeters_ != null) {
        _single_remainingDistanceMeters_codec.WriteTagAndValue(output, RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(EtaToFirstWaypoint);
      }
      if (CurrentRouteSegment.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteString(CurrentRouteSegment);
      }
      waypoints_.WriteTo(output, _repeated_waypoints_codec);
      if (BackToBackEnabled != false) {
        output.WriteRawTag(184, 1);
        output.WriteBool(BackToBackEnabled);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(CurrentRouteSegmentEndPoint);
      }
      if (remainingTimeSeconds_ != null) {
        _single_remainingTimeSeconds_codec.WriteTagAndValue(output, RemainingTimeSeconds);
      }
      if (NavigationStatus != global::Maps.Fleetengine.V1.NavigationStatus.UnknownNavigationStatus) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) NavigationStatus);
      }
      if (deviceSettings_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(DeviceSettings);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(16);
        output.WriteEnum((int) VehicleState);
      }
      supportedTripTypes_.WriteTo(ref output, _repeated_supportedTripTypes_codec);
      currentTrips_.WriteTo(ref output, _repeated_currentTrips_codec);
      if (lastLocation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(LastLocation);
      }
      if (MaximumCapacity != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(MaximumCapacity);
      }
      if (AvailableCapacity != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(AvailableCapacity);
      }
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (vehicleType_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(VehicleType);
      }
      if (licensePlate_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LicensePlate);
      }
      route_.WriteTo(ref output, _repeated_route_codec);
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(WaypointsVersion);
      }
      if (remainingDistanceMeters_ != null) {
        _single_remainingDistanceMeters_codec.WriteTagAndValue(ref output, RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(EtaToFirstWaypoint);
      }
      if (CurrentRouteSegment.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteString(CurrentRouteSegment);
      }
      waypoints_.WriteTo(ref output, _repeated_waypoints_codec);
      if (BackToBackEnabled != false) {
        output.WriteRawTag(184, 1);
        output.WriteBool(BackToBackEnabled);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(CurrentRouteSegmentEndPoint);
      }
      if (remainingTimeSeconds_ != null) {
        _single_remainingTimeSeconds_codec.WriteTagAndValue(ref output, RemainingTimeSeconds);
      }
      if (NavigationStatus != global::Maps.Fleetengine.V1.NavigationStatus.UnknownNavigationStatus) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) NavigationStatus);
      }
      if (deviceSettings_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(DeviceSettings);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) VehicleState);
      }
      size += supportedTripTypes_.CalculateSize(_repeated_supportedTripTypes_codec);
      size += currentTrips_.CalculateSize(_repeated_currentTrips_codec);
      if (lastLocation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastLocation);
      }
      if (MaximumCapacity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaximumCapacity);
      }
      if (AvailableCapacity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(AvailableCapacity);
      }
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (vehicleType_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleType);
      }
      if (licensePlate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LicensePlate);
      }
      size += route_.CalculateSize(_repeated_route_codec);
      if (CurrentRouteSegment.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CurrentRouteSegment);
      }
      if (currentRouteSegmentVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentVersion);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentEndPoint);
      }
      if (remainingDistanceMeters_ != null) {
        size += _single_remainingDistanceMeters_codec.CalculateSizeWithTag(RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(EtaToFirstWaypoint);
      }
      if (remainingTimeSeconds_ != null) {
        size += _single_remainingTimeSeconds_codec.CalculateSizeWithTag(RemainingTimeSeconds);
      }
      size += waypoints_.CalculateSize(_repeated_waypoints_codec);
      if (waypointsVersion_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(WaypointsVersion);
      }
      if (BackToBackEnabled != false) {
        size += 2 + 1;
      }
      if (NavigationStatus != global::Maps.Fleetengine.V1.NavigationStatus.UnknownNavigationStatus) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) NavigationStatus);
      }
      if (deviceSettings_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DeviceSettings);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Vehicle other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        VehicleState = other.VehicleState;
      }
      supportedTripTypes_.Add(other.supportedTripTypes_);
      currentTrips_.Add(other.currentTrips_);
      if (other.lastLocation_ != null) {
        if (lastLocation_ == null) {
          LastLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
        }
        LastLocation.MergeFrom(other.LastLocation);
      }
      if (other.MaximumCapacity != 0) {
        MaximumCapacity = other.MaximumCapacity;
      }
      if (other.AvailableCapacity != 0) {
        AvailableCapacity = other.AvailableCapacity;
      }
      attributes_.Add(other.attributes_);
      if (other.vehicleType_ != null) {
        if (vehicleType_ == null) {
          VehicleType = new global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType();
        }
        VehicleType.MergeFrom(other.VehicleType);
      }
      if (other.licensePlate_ != null) {
        if (licensePlate_ == null) {
          LicensePlate = new global::Maps.Fleetengine.V1.LicensePlate();
        }
        LicensePlate.MergeFrom(other.LicensePlate);
      }
      route_.Add(other.route_);
      if (other.CurrentRouteSegment.Length != 0) {
        CurrentRouteSegment = other.CurrentRouteSegment;
      }
      if (other.currentRouteSegmentVersion_ != null) {
        if (currentRouteSegmentVersion_ == null) {
          CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CurrentRouteSegmentVersion.MergeFrom(other.CurrentRouteSegmentVersion);
      }
      if (other.currentRouteSegmentEndPoint_ != null) {
        if (currentRouteSegmentEndPoint_ == null) {
          CurrentRouteSegmentEndPoint = new global::Maps.Fleetengine.V1.TripWaypoint();
        }
        CurrentRouteSegmentEndPoint.MergeFrom(other.CurrentRouteSegmentEndPoint);
      }
      if (other.remainingDistanceMeters_ != null) {
        if (remainingDistanceMeters_ == null || other.RemainingDistanceMeters != 0) {
          RemainingDistanceMeters = other.RemainingDistanceMeters;
        }
      }
      if (other.etaToFirstWaypoint_ != null) {
        if (etaToFirstWaypoint_ == null) {
          EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EtaToFirstWaypoint.MergeFrom(other.EtaToFirstWaypoint);
      }
      if (other.remainingTimeSeconds_ != null) {
        if (remainingTimeSeconds_ == null || other.RemainingTimeSeconds != 0) {
          RemainingTimeSeconds = other.RemainingTimeSeconds;
        }
      }
      waypoints_.Add(other.waypoints_);
      if (other.waypointsVersion_ != null) {
        if (waypointsVersion_ == null) {
          WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        WaypointsVersion.MergeFrom(other.WaypointsVersion);
      }
      if (other.BackToBackEnabled != false) {
        BackToBackEnabled = other.BackToBackEnabled;
      }
      if (other.NavigationStatus != global::Maps.Fleetengine.V1.NavigationStatus.UnknownNavigationStatus) {
        NavigationStatus = other.NavigationStatus;
      }
      if (other.deviceSettings_ != null) {
        if (deviceSettings_ == null) {
          DeviceSettings = new global::Maps.Fleetengine.V1.DeviceSettings();
        }
        DeviceSettings.MergeFrom(other.DeviceSettings);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            VehicleState = (global::Maps.Fleetengine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            supportedTripTypes_.AddEntriesFrom(input, _repeated_supportedTripTypes_codec);
            break;
          }
          case 34: {
            currentTrips_.AddEntriesFrom(input, _repeated_currentTrips_codec);
            break;
          }
          case 42: {
            if (lastLocation_ == null) {
              LastLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
            }
            input.ReadMessage(LastLocation);
            break;
          }
          case 48: {
            MaximumCapacity = input.ReadInt32();
            break;
          }
          case 56: {
            AvailableCapacity = input.ReadInt32();
            break;
          }
          case 66: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 74: {
            if (vehicleType_ == null) {
              VehicleType = new global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType();
            }
            input.ReadMessage(VehicleType);
            break;
          }
          case 82: {
            if (licensePlate_ == null) {
              LicensePlate = new global::Maps.Fleetengine.V1.LicensePlate();
            }
            input.ReadMessage(LicensePlate);
            break;
          }
          case 98: {
            route_.AddEntriesFrom(input, _repeated_route_codec);
            break;
          }
          case 122: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 130: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
          case 146: {
            int? value = _single_remainingDistanceMeters_codec.Read(input);
            if (remainingDistanceMeters_ == null || value != 0) {
              RemainingDistanceMeters = value;
            }
            break;
          }
          case 154: {
            if (etaToFirstWaypoint_ == null) {
              EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EtaToFirstWaypoint);
            break;
          }
          case 162: {
            CurrentRouteSegment = input.ReadString();
            break;
          }
          case 178: {
            waypoints_.AddEntriesFrom(input, _repeated_waypoints_codec);
            break;
          }
          case 184: {
            BackToBackEnabled = input.ReadBool();
            break;
          }
          case 194: {
            if (currentRouteSegmentEndPoint_ == null) {
              CurrentRouteSegmentEndPoint = new global::Maps.Fleetengine.V1.TripWaypoint();
            }
            input.ReadMessage(CurrentRouteSegmentEndPoint);
            break;
          }
          case 202: {
            int? value = _single_remainingTimeSeconds_codec.Read(input);
            if (remainingTimeSeconds_ == null || value != 0) {
              RemainingTimeSeconds = value;
            }
            break;
          }
          case 208: {
            NavigationStatus = (global::Maps.Fleetengine.V1.NavigationStatus) input.ReadEnum();
            break;
          }
          case 218: {
            if (deviceSettings_ == null) {
              DeviceSettings = new global::Maps.Fleetengine.V1.DeviceSettings();
            }
            input.ReadMessage(DeviceSettings);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            VehicleState = (global::Maps.Fleetengine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            supportedTripTypes_.AddEntriesFrom(ref input, _repeated_supportedTripTypes_codec);
            break;
          }
          case 34: {
            currentTrips_.AddEntriesFrom(ref input, _repeated_currentTrips_codec);
            break;
          }
          case 42: {
            if (lastLocation_ == null) {
              LastLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
            }
            input.ReadMessage(LastLocation);
            break;
          }
          case 48: {
            MaximumCapacity = input.ReadInt32();
            break;
          }
          case 56: {
            AvailableCapacity = input.ReadInt32();
            break;
          }
          case 66: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
          case 74: {
            if (vehicleType_ == null) {
              VehicleType = new global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType();
            }
            input.ReadMessage(VehicleType);
            break;
          }
          case 82: {
            if (licensePlate_ == null) {
              LicensePlate = new global::Maps.Fleetengine.V1.LicensePlate();
            }
            input.ReadMessage(LicensePlate);
            break;
          }
          case 98: {
            route_.AddEntriesFrom(ref input, _repeated_route_codec);
            break;
          }
          case 122: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 130: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
          case 146: {
            int? value = _single_remainingDistanceMeters_codec.Read(ref input);
            if (remainingDistanceMeters_ == null || value != 0) {
              RemainingDistanceMeters = value;
            }
            break;
          }
          case 154: {
            if (etaToFirstWaypoint_ == null) {
              EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EtaToFirstWaypoint);
            break;
          }
          case 162: {
            CurrentRouteSegment = input.ReadString();
            break;
          }
          case 178: {
            waypoints_.AddEntriesFrom(ref input, _repeated_waypoints_codec);
            break;
          }
          case 184: {
            BackToBackEnabled = input.ReadBool();
            break;
          }
          case 194: {
            if (currentRouteSegmentEndPoint_ == null) {
              CurrentRouteSegmentEndPoint = new global::Maps.Fleetengine.V1.TripWaypoint();
            }
            input.ReadMessage(CurrentRouteSegmentEndPoint);
            break;
          }
          case 202: {
            int? value = _single_remainingTimeSeconds_codec.Read(ref input);
            if (remainingTimeSeconds_ == null || value != 0) {
              RemainingTimeSeconds = value;
            }
            break;
          }
          case 208: {
            NavigationStatus = (global::Maps.Fleetengine.V1.NavigationStatus) input.ReadEnum();
            break;
          }
          case 218: {
            if (deviceSettings_ == null) {
              DeviceSettings = new global::Maps.Fleetengine.V1.DeviceSettings();
            }
            input.ReadMessage(DeviceSettings);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Vehicle message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Types of vehicles that may be filtered for in SearchVehicles.
      /// </summary>
      public sealed partial class VehicleType : pb::IMessage<VehicleType>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VehicleType> _parser = new pb::MessageParser<VehicleType>(() => new VehicleType());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<VehicleType> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Maps.Fleetengine.V1.Vehicle.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleType() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleType(VehicleType other) : this() {
          category_ = other.category_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleType Clone() {
          return new VehicleType(this);
        }

        /// <summary>Field number for the "category" field.</summary>
        public const int CategoryFieldNumber = 1;
        private global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category category_ = global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown;
        /// <summary>
        /// Vehicle type category
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category Category {
          get { return category_; }
          set {
            category_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as VehicleType);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(VehicleType other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Category != other.Category) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Category != global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) hash ^= Category.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Category != global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Category);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Category != global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Category);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Category != global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Category);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(VehicleType other) {
          if (other == null) {
            return;
          }
          if (other.Category != global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            Category = other.Category;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Category = (global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Category = (global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the VehicleType message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Vehicle type categories
          /// </summary>
          public enum Category {
            /// <summary>
            /// Default, used for unspecified or unrecognized vehicle types.
            /// </summary>
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            /// <summary>
            /// An automobile.
            /// </summary>
            [pbr::OriginalName("AUTO")] Auto = 1,
            /// <summary>
            /// Any vehicle that acts as a taxi.
            /// </summary>
            [pbr::OriginalName("TAXI")] Taxi = 2,
            /// <summary>
            /// Generally, a vehicle with a large storage capacity.
            /// </summary>
            [pbr::OriginalName("TRUCK")] Truck = 3,
            /// <summary>
            /// A motorcycle, moped, or other two-wheeled vehicle
            /// </summary>
            [pbr::OriginalName("TWO_WHEELER")] TwoWheeler = 4,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Information about the device's battery.
  /// </summary>
  public sealed partial class BatteryInfo : pb::IMessage<BatteryInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BatteryInfo> _parser = new pb::MessageParser<BatteryInfo>(() => new BatteryInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BatteryInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehiclesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatteryInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatteryInfo(BatteryInfo other) : this() {
      batteryStatus_ = other.batteryStatus_;
      powerSource_ = other.powerSource_;
      batteryPercentage_ = other.batteryPercentage_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatteryInfo Clone() {
      return new BatteryInfo(this);
    }

    /// <summary>Field number for the "battery_status" field.</summary>
    public const int BatteryStatusFieldNumber = 1;
    private global::Maps.Fleetengine.V1.BatteryStatus batteryStatus_ = global::Maps.Fleetengine.V1.BatteryStatus.UnknownBatteryStatus;
    /// <summary>
    /// Status of the battery, whether full or charging etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.BatteryStatus BatteryStatus {
      get { return batteryStatus_; }
      set {
        batteryStatus_ = value;
      }
    }

    /// <summary>Field number for the "power_source" field.</summary>
    public const int PowerSourceFieldNumber = 2;
    private global::Maps.Fleetengine.V1.PowerSource powerSource_ = global::Maps.Fleetengine.V1.PowerSource.UnknownPowerSource;
    /// <summary>
    /// Status of battery power source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.PowerSource PowerSource {
      get { return powerSource_; }
      set {
        powerSource_ = value;
      }
    }

    /// <summary>Field number for the "battery_percentage" field.</summary>
    public const int BatteryPercentageFieldNumber = 3;
    private float batteryPercentage_;
    /// <summary>
    /// Current battery percentage [0-100].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float BatteryPercentage {
      get { return batteryPercentage_; }
      set {
        batteryPercentage_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BatteryInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BatteryInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BatteryStatus != other.BatteryStatus) return false;
      if (PowerSource != other.PowerSource) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BatteryPercentage, other.BatteryPercentage)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BatteryStatus != global::Maps.Fleetengine.V1.BatteryStatus.UnknownBatteryStatus) hash ^= BatteryStatus.GetHashCode();
      if (PowerSource != global::Maps.Fleetengine.V1.PowerSource.UnknownPowerSource) hash ^= PowerSource.GetHashCode();
      if (BatteryPercentage != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BatteryPercentage);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BatteryStatus != global::Maps.Fleetengine.V1.BatteryStatus.UnknownBatteryStatus) {
        output.WriteRawTag(8);
        output.WriteEnum((int) BatteryStatus);
      }
      if (PowerSource != global::Maps.Fleetengine.V1.PowerSource.UnknownPowerSource) {
        output.WriteRawTag(16);
        output.WriteEnum((int) PowerSource);
      }
      if (BatteryPercentage != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(BatteryPercentage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BatteryStatus != global::Maps.Fleetengine.V1.BatteryStatus.UnknownBatteryStatus) {
        output.WriteRawTag(8);
        output.WriteEnum((int) BatteryStatus);
      }
      if (PowerSource != global::Maps.Fleetengine.V1.PowerSource.UnknownPowerSource) {
        output.WriteRawTag(16);
        output.WriteEnum((int) PowerSource);
      }
      if (BatteryPercentage != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(BatteryPercentage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BatteryStatus != global::Maps.Fleetengine.V1.BatteryStatus.UnknownBatteryStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BatteryStatus);
      }
      if (PowerSource != global::Maps.Fleetengine.V1.PowerSource.UnknownPowerSource) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PowerSource);
      }
      if (BatteryPercentage != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BatteryInfo other) {
      if (other == null) {
        return;
      }
      if (other.BatteryStatus != global::Maps.Fleetengine.V1.BatteryStatus.UnknownBatteryStatus) {
        BatteryStatus = other.BatteryStatus;
      }
      if (other.PowerSource != global::Maps.Fleetengine.V1.PowerSource.UnknownPowerSource) {
        PowerSource = other.PowerSource;
      }
      if (other.BatteryPercentage != 0F) {
        BatteryPercentage = other.BatteryPercentage;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            BatteryStatus = (global::Maps.Fleetengine.V1.BatteryStatus) input.ReadEnum();
            break;
          }
          case 16: {
            PowerSource = (global::Maps.Fleetengine.V1.PowerSource) input.ReadEnum();
            break;
          }
          case 29: {
            BatteryPercentage = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            BatteryStatus = (global::Maps.Fleetengine.V1.BatteryStatus) input.ReadEnum();
            break;
          }
          case 16: {
            PowerSource = (global::Maps.Fleetengine.V1.PowerSource) input.ReadEnum();
            break;
          }
          case 29: {
            BatteryPercentage = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Information about various settings on the device.
  /// </summary>
  public sealed partial class DeviceSettings : pb::IMessage<DeviceSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DeviceSettings> _parser = new pb::MessageParser<DeviceSettings>(() => new DeviceSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeviceSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehiclesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceSettings(DeviceSettings other) : this() {
      locationPowerSaveMode_ = other.locationPowerSaveMode_;
      isPowerSaveMode_ = other.isPowerSaveMode_;
      isInteractive_ = other.isInteractive_;
      batteryInfo_ = other.batteryInfo_ != null ? other.batteryInfo_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceSettings Clone() {
      return new DeviceSettings(this);
    }

    /// <summary>Field number for the "location_power_save_mode" field.</summary>
    public const int LocationPowerSaveModeFieldNumber = 1;
    private global::Maps.Fleetengine.V1.LocationPowerSaveMode locationPowerSaveMode_ = global::Maps.Fleetengine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode;
    /// <summary>
    /// How location features are set to behave on the device when battery saver is
    /// on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.LocationPowerSaveMode LocationPowerSaveMode {
      get { return locationPowerSaveMode_; }
      set {
        locationPowerSaveMode_ = value;
      }
    }

    /// <summary>Field number for the "is_power_save_mode" field.</summary>
    public const int IsPowerSaveModeFieldNumber = 2;
    private bool isPowerSaveMode_;
    /// <summary>
    /// Whether the device is currently in power save mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPowerSaveMode {
      get { return isPowerSaveMode_; }
      set {
        isPowerSaveMode_ = value;
      }
    }

    /// <summary>Field number for the "is_interactive" field.</summary>
    public const int IsInteractiveFieldNumber = 3;
    private bool isInteractive_;
    /// <summary>
    /// Whether the device is in an interactive state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsInteractive {
      get { return isInteractive_; }
      set {
        isInteractive_ = value;
      }
    }

    /// <summary>Field number for the "battery_info" field.</summary>
    public const int BatteryInfoFieldNumber = 4;
    private global::Maps.Fleetengine.V1.BatteryInfo batteryInfo_;
    /// <summary>
    /// Information about the battery state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.BatteryInfo BatteryInfo {
      get { return batteryInfo_; }
      set {
        batteryInfo_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeviceSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeviceSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LocationPowerSaveMode != other.LocationPowerSaveMode) return false;
      if (IsPowerSaveMode != other.IsPowerSaveMode) return false;
      if (IsInteractive != other.IsInteractive) return false;
      if (!object.Equals(BatteryInfo, other.BatteryInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LocationPowerSaveMode != global::Maps.Fleetengine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) hash ^= LocationPowerSaveMode.GetHashCode();
      if (IsPowerSaveMode != false) hash ^= IsPowerSaveMode.GetHashCode();
      if (IsInteractive != false) hash ^= IsInteractive.GetHashCode();
      if (batteryInfo_ != null) hash ^= BatteryInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (LocationPowerSaveMode != global::Maps.Fleetengine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LocationPowerSaveMode);
      }
      if (IsPowerSaveMode != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsPowerSaveMode);
      }
      if (IsInteractive != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsInteractive);
      }
      if (batteryInfo_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BatteryInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (LocationPowerSaveMode != global::Maps.Fleetengine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LocationPowerSaveMode);
      }
      if (IsPowerSaveMode != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsPowerSaveMode);
      }
      if (IsInteractive != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsInteractive);
      }
      if (batteryInfo_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BatteryInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LocationPowerSaveMode != global::Maps.Fleetengine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LocationPowerSaveMode);
      }
      if (IsPowerSaveMode != false) {
        size += 1 + 1;
      }
      if (IsInteractive != false) {
        size += 1 + 1;
      }
      if (batteryInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BatteryInfo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeviceSettings other) {
      if (other == null) {
        return;
      }
      if (other.LocationPowerSaveMode != global::Maps.Fleetengine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        LocationPowerSaveMode = other.LocationPowerSaveMode;
      }
      if (other.IsPowerSaveMode != false) {
        IsPowerSaveMode = other.IsPowerSaveMode;
      }
      if (other.IsInteractive != false) {
        IsInteractive = other.IsInteractive;
      }
      if (other.batteryInfo_ != null) {
        if (batteryInfo_ == null) {
          BatteryInfo = new global::Maps.Fleetengine.V1.BatteryInfo();
        }
        BatteryInfo.MergeFrom(other.BatteryInfo);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LocationPowerSaveMode = (global::Maps.Fleetengine.V1.LocationPowerSaveMode) input.ReadEnum();
            break;
          }
          case 16: {
            IsPowerSaveMode = input.ReadBool();
            break;
          }
          case 24: {
            IsInteractive = input.ReadBool();
            break;
          }
          case 34: {
            if (batteryInfo_ == null) {
              BatteryInfo = new global::Maps.Fleetengine.V1.BatteryInfo();
            }
            input.ReadMessage(BatteryInfo);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            LocationPowerSaveMode = (global::Maps.Fleetengine.V1.LocationPowerSaveMode) input.ReadEnum();
            break;
          }
          case 16: {
            IsPowerSaveMode = input.ReadBool();
            break;
          }
          case 24: {
            IsInteractive = input.ReadBool();
            break;
          }
          case 34: {
            if (batteryInfo_ == null) {
              BatteryInfo = new global::Maps.Fleetengine.V1.BatteryInfo();
            }
            input.ReadMessage(BatteryInfo);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The license plate information of the Vehicle.  This is used to support
  /// congestion pricing restrictions in certain areas.  To avoid storing
  /// personally-identifiable information, only the minimum information
  /// about the license plate is stored as part of the entity.
  /// </summary>
  public sealed partial class LicensePlate : pb::IMessage<LicensePlate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LicensePlate> _parser = new pb::MessageParser<LicensePlate>(() => new LicensePlate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LicensePlate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehiclesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LicensePlate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LicensePlate(LicensePlate other) : this() {
      countryCode_ = other.countryCode_;
      lastCharacter_ = other.lastCharacter_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LicensePlate Clone() {
      return new LicensePlate(this);
    }

    /// <summary>Field number for the "country_code" field.</summary>
    public const int CountryCodeFieldNumber = 1;
    private string countryCode_ = "";
    /// <summary>
    /// Required. CLDR Country/Region Code.  For example, "US" for United States,
    /// or "IN" for India.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CountryCode {
      get { return countryCode_; }
      set {
        countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "last_character" field.</summary>
    public const int LastCharacterFieldNumber = 2;
    private string lastCharacter_ = "";
    /// <summary>
    /// The last digit of the license plate or "-1" to denote no numeric value
    /// present in the license plate.
    ///
    /// * "ABC 1234" -> "4"
    /// * "AB 123 CD" -> "3"
    /// * "ABCDEF" -> "-1"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string LastCharacter {
      get { return lastCharacter_; }
      set {
        lastCharacter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LicensePlate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LicensePlate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CountryCode != other.CountryCode) return false;
      if (LastCharacter != other.LastCharacter) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CountryCode.Length != 0) hash ^= CountryCode.GetHashCode();
      if (LastCharacter.Length != 0) hash ^= LastCharacter.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CountryCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CountryCode);
      }
      if (LastCharacter.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LastCharacter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CountryCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CountryCode);
      }
      if (LastCharacter.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LastCharacter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CountryCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryCode);
      }
      if (LastCharacter.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LastCharacter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LicensePlate other) {
      if (other == null) {
        return;
      }
      if (other.CountryCode.Length != 0) {
        CountryCode = other.CountryCode;
      }
      if (other.LastCharacter.Length != 0) {
        LastCharacter = other.LastCharacter;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CountryCode = input.ReadString();
            break;
          }
          case 18: {
            LastCharacter = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CountryCode = input.ReadString();
            break;
          }
          case 18: {
            LastCharacter = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
