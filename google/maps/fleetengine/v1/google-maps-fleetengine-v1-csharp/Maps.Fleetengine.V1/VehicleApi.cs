// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/fleetengine/v1/vehicle_api.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Maps.Fleetengine.V1 {

  /// <summary>Holder for reflection information generated from google/maps/fleetengine/v1/vehicle_api.proto</summary>
  public static partial class VehicleApiReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/fleetengine/v1/vehicle_api.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static VehicleApiReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cixnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS92ZWhpY2xlX2FwaS5wcm90",
            "bxITbWFwcy5mbGVldGVuZ2luZS52MRocZ29vZ2xlL2FwaS9hbm5vdGF0aW9u",
            "cy5wcm90bxofZ29vZ2xlL2FwaS9maWVsZF9iZWhhdmlvci5wcm90bxoZZ29v",
            "Z2xlL2FwaS9yZXNvdXJjZS5wcm90bxosZ29vZ2xlL21hcHMvZmxlZXRlbmdp",
            "bmUvdjEvZmxlZXRlbmdpbmUucHJvdG8aJ2dvb2dsZS9tYXBzL2ZsZWV0ZW5n",
            "aW5lL3YxL2hlYWRlci5wcm90bxopZ29vZ2xlL21hcHMvZmxlZXRlbmdpbmUv",
            "djEvdmVoaWNsZXMucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5w",
            "cm90bxogZ29vZ2xlL3Byb3RvYnVmL2ZpZWxkX21hc2sucHJvdG8aH2dvb2ds",
            "ZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93",
            "cmFwcGVycy5wcm90bxoYZ29vZ2xlL3R5cGUvbGF0bG5nLnByb3RvGhdnb29n",
            "bGUvYXBpL2NsaWVudC5wcm90byKsAQoUQ3JlYXRlVmVoaWNsZVJlcXVlc3QS",
            "MgoGaGVhZGVyGAEgASgLMiIubWFwcy5mbGVldGVuZ2luZS52MS5SZXF1ZXN0",
            "SGVhZGVyEhMKBnBhcmVudBgDIAEoCUID4EECEhcKCnZlaGljbGVfaWQYBCAB",
            "KAlCA+BBAhIyCgd2ZWhpY2xlGAUgASgLMhwubWFwcy5mbGVldGVuZ2luZS52",
            "MS5WZWhpY2xlQgPgQQIi+wEKEUdldFZlaGljbGVSZXF1ZXN0EjIKBmhlYWRl",
            "chgBIAEoCzIiLm1hcHMuZmxlZXRlbmdpbmUudjEuUmVxdWVzdEhlYWRlchI4",
            "CgRuYW1lGAMgASgJQirgQQL6QSQKImZsZWV0ZW5naW5lLmdvb2dsZWFwaXMu",
            "Y29tL1ZlaGljbGUSQQodY3VycmVudF9yb3V0ZV9zZWdtZW50X3ZlcnNpb24Y",
            "BCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjUKEXdheXBvaW50",
            "c192ZXJzaW9uGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCLH",
            "AQoUVXBkYXRlVmVoaWNsZVJlcXVlc3QSMgoGaGVhZGVyGAEgASgLMiIubWFw",
            "cy5mbGVldGVuZ2luZS52MS5SZXF1ZXN0SGVhZGVyEhEKBG5hbWUYAyABKAlC",
            "A+BBAhIyCgd2ZWhpY2xlGAQgASgLMhwubWFwcy5mbGVldGVuZ2luZS52MS5W",
            "ZWhpY2xlQgPgQQISNAoLdXBkYXRlX21hc2sYBSABKAsyGi5nb29nbGUucHJv",
            "dG9idWYuRmllbGRNYXNrQgPgQQIi6AEKHFVwZGF0ZVZlaGljbGVMb2NhdGlv",
            "blJlcXVlc3QSMgoGaGVhZGVyGAEgASgLMiIubWFwcy5mbGVldGVuZ2luZS52",
            "MS5SZXF1ZXN0SGVhZGVyEhEKBG5hbWUYAyABKAlCA+BBAhJDChBjdXJyZW50",
            "X2xvY2F0aW9uGAQgASgLMiQubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xl",
            "TG9jYXRpb25CA+BBAhI4Cg1jdXJyZW50X3N0YXRlGAUgASgOMiEubWFwcy5m",
            "bGVldGVuZ2luZS52MS5WZWhpY2xlU3RhdGU6AhgBIqcBCh5VcGRhdGVWZWhp",
            "Y2xlQXR0cmlidXRlc1JlcXVlc3QSMgoGaGVhZGVyGAEgASgLMiIubWFwcy5m",
            "bGVldGVuZ2luZS52MS5SZXF1ZXN0SGVhZGVyEhEKBG5hbWUYAyABKAlCA+BB",
            "AhI+CgphdHRyaWJ1dGVzGAQgAygLMiUubWFwcy5mbGVldGVuZ2luZS52MS5W",
            "ZWhpY2xlQXR0cmlidXRlQgPgQQIiYQofVXBkYXRlVmVoaWNsZUF0dHJpYnV0",
            "ZXNSZXNwb25zZRI+CgphdHRyaWJ1dGVzGAEgAygLMiUubWFwcy5mbGVldGVu",
            "Z2luZS52MS5WZWhpY2xlQXR0cmlidXRlQgPgQQIigQgKFVNlYXJjaFZlaGlj",
            "bGVzUmVxdWVzdBIyCgZoZWFkZXIYASABKAsyIi5tYXBzLmZsZWV0ZW5naW5l",
            "LnYxLlJlcXVlc3RIZWFkZXISEwoGcGFyZW50GAMgASgJQgPgQQISQAoMcGlj",
            "a3VwX3BvaW50GAQgASgLMiUubWFwcy5mbGVldGVuZ2luZS52MS5UZXJtaW5h",
            "bExvY2F0aW9uQgPgQQISPAoNZHJvcG9mZl9wb2ludBgFIAEoCzIlLm1hcHMu",
            "ZmxlZXRlbmdpbmUudjEuVGVybWluYWxMb2NhdGlvbhIhChRwaWNrdXBfcmFk",
            "aXVzX21ldGVycxgGIAEoBUID4EECEhIKBWNvdW50GAcgASgFQgPgQQISHQoQ",
            "bWluaW11bV9jYXBhY2l0eRgIIAEoBUID4EECEjYKCnRyaXBfdHlwZXMYCSAD",
            "KA4yHS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBUeXBlQgPgQQISNAoRbWF4",
            "aW11bV9zdGFsZW5lc3MYCiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRp",
            "b24SRAoNdmVoaWNsZV90eXBlcxgOIAMoCzIoLm1hcHMuZmxlZXRlbmdpbmUu",
            "djEuVmVoaWNsZS5WZWhpY2xlVHlwZUID4EECEkIKE3JlcXVpcmVkX2F0dHJp",
            "YnV0ZXMYDCADKAsyJS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGVBdHRy",
            "aWJ1dGUSTQoacmVxdWlyZWRfb25lX29mX2F0dHJpYnV0ZXMYDyADKAsyKS5t",
            "YXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGVBdHRyaWJ1dGVMaXN0ElEKHnJl",
            "cXVpcmVkX29uZV9vZl9hdHRyaWJ1dGVfc2V0cxgUIAMoCzIpLm1hcHMuZmxl",
            "ZXRlbmdpbmUudjEuVmVoaWNsZUF0dHJpYnV0ZUxpc3QSUwoIb3JkZXJfYnkY",
            "DSABKA4yPC5tYXBzLmZsZWV0ZW5naW5lLnYxLlNlYXJjaFZlaGljbGVzUmVx",
            "dWVzdC5WZWhpY2xlTWF0Y2hPcmRlckID4EECEhwKFGluY2x1ZGVfYmFja190",
            "b19iYWNrGBIgASgIEg8KB3RyaXBfaWQYEyABKAkiqgEKEVZlaGljbGVNYXRj",
            "aE9yZGVyEh8KG1VOS05PV05fVkVISUNMRV9NQVRDSF9PUkRFUhAAEhQKEFBJ",
            "Q0tVUF9QT0lOVF9FVEEQARIZChVQSUNLVVBfUE9JTlRfRElTVEFOQ0UQAhIV",
            "ChFEUk9QT0ZGX1BPSU5UX0VUQRADEiIKHlBJQ0tVUF9QT0lOVF9TVFJBSUdI",
            "VF9ESVNUQU5DRRAEEggKBENPU1QQBSJMChZTZWFyY2hWZWhpY2xlc1Jlc3Bv",
            "bnNlEjIKB21hdGNoZXMYASADKAsyIS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZl",
            "aGljbGVNYXRjaCK3BAoTTGlzdFZlaGljbGVzUmVxdWVzdBIyCgZoZWFkZXIY",
            "DCABKAsyIi5tYXBzLmZsZWV0ZW5naW5lLnYxLlJlcXVlc3RIZWFkZXISEwoG",
            "cGFyZW50GAEgASgJQgPgQQISEQoJcGFnZV9zaXplGAMgASgFEhIKCnBhZ2Vf",
            "dG9rZW4YBCABKAkSNQoQbWluaW11bV9jYXBhY2l0eRgGIAEoCzIbLmdvb2ds",
            "ZS5wcm90b2J1Zi5JbnQzMlZhbHVlEjEKCnRyaXBfdHlwZXMYByADKA4yHS5t",
            "YXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBUeXBlEjQKEW1heGltdW1fc3RhbGVu",
            "ZXNzGAggASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uElcKF3ZlaGlj",
            "bGVfdHlwZV9jYXRlZ29yaWVzGAkgAygOMjEubWFwcy5mbGVldGVuZ2luZS52",
            "MS5WZWhpY2xlLlZlaGljbGVUeXBlLkNhdGVnb3J5QgPgQQISGwoTcmVxdWly",
            "ZWRfYXR0cmlidXRlcxgKIAMoCRIiChpyZXF1aXJlZF9vbmVfb2ZfYXR0cmli",
            "dXRlcxgNIAMoCRImCh5yZXF1aXJlZF9vbmVfb2ZfYXR0cmlidXRlX3NldHMY",
            "DyADKAkSOAoNdmVoaWNsZV9zdGF0ZRgLIAEoDjIhLm1hcHMuZmxlZXRlbmdp",
            "bmUudjEuVmVoaWNsZVN0YXRlEhQKDG9uX3RyaXBfb25seRgOIAEoCCJ4ChRM",
            "aXN0VmVoaWNsZXNSZXNwb25zZRIuCgh2ZWhpY2xlcxgBIAMoCzIcLm1hcHMu",
            "ZmxlZXRlbmdpbmUudjEuVmVoaWNsZRIXCg9uZXh0X3BhZ2VfdG9rZW4YAiAB",
            "KAkSFwoKdG90YWxfc2l6ZRgDIAEoA0ID4EECIlkKCFdheXBvaW50EiQKB2xh",
            "dF9sbmcYASABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcSJwoDZXRhGAIgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCL+BgoMVmVoaWNsZU1hdGNo",
            "EjIKB3ZlaGljbGUYASABKAsyHC5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGlj",
            "bGVCA+BBAhI2ChJ2ZWhpY2xlX3BpY2t1cF9ldGEYAiABKAsyGi5nb29nbGUu",
            "cHJvdG9idWYuVGltZXN0YW1wEkMKHnZlaGljbGVfcGlja3VwX2Rpc3RhbmNl",
            "X21ldGVycxgDIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlElYK",
            "LHZlaGljbGVfcGlja3VwX3N0cmFpZ2h0X2xpbmVfZGlzdGFuY2VfbWV0ZXJz",
            "GAsgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVCA+BBAhI3ChN2",
            "ZWhpY2xlX2Ryb3BvZmZfZXRhGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRp",
            "bWVzdGFtcBJOCil2ZWhpY2xlX3BpY2t1cF90b19kcm9wb2ZmX2Rpc3RhbmNl",
            "X21ldGVycxgFIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlEjUK",
            "CXRyaXBfdHlwZRgGIAEoDjIdLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcFR5",
            "cGVCA+BBAhI+Chd2ZWhpY2xlX3RyaXBzX3dheXBvaW50cxgHIAMoCzIdLm1h",
            "cHMuZmxlZXRlbmdpbmUudjEuV2F5cG9pbnQSTgoSdmVoaWNsZV9tYXRjaF90",
            "eXBlGAggASgOMjIubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xlTWF0Y2gu",
            "VmVoaWNsZU1hdGNoVHlwZRJaChRyZXF1ZXN0ZWRfb3JkZXJlZF9ieRgJIAEo",
            "DjI8Lm1hcHMuZmxlZXRlbmdpbmUudjEuU2VhcmNoVmVoaWNsZXNSZXF1ZXN0",
            "LlZlaGljbGVNYXRjaE9yZGVyElAKCm9yZGVyZWRfYnkYCiABKA4yPC5tYXBz",
            "LmZsZWV0ZW5naW5lLnYxLlNlYXJjaFZlaGljbGVzUmVxdWVzdC5WZWhpY2xl",
            "TWF0Y2hPcmRlciJnChBWZWhpY2xlTWF0Y2hUeXBlEgsKB1VOS05PV04QABIN",
            "CglFWENMVVNJVkUQARIQCgxCQUNLX1RPX0JBQ0sQAhILCgdDQVJQT09MEAMS",
            "GAoUQ0FSUE9PTF9CQUNLX1RPX0JBQ0sQBCJRChRWZWhpY2xlQXR0cmlidXRl",
            "TGlzdBI5CgphdHRyaWJ1dGVzGAEgAygLMiUubWFwcy5mbGVldGVuZ2luZS52",
            "MS5WZWhpY2xlQXR0cmlidXRlMqQKCg5WZWhpY2xlU2VydmljZRKMAQoNQ3Jl",
            "YXRlVmVoaWNsZRIpLm1hcHMuZmxlZXRlbmdpbmUudjEuQ3JlYXRlVmVoaWNs",
            "ZVJlcXVlc3QaHC5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGUiMoLT5JMC",
            "LCIhL3YxL3twYXJlbnQ9cHJvdmlkZXJzLyp9L3ZlaGljbGVzOgd2ZWhpY2xl",
            "En0KCkdldFZlaGljbGUSJi5tYXBzLmZsZWV0ZW5naW5lLnYxLkdldFZlaGlj",
            "bGVSZXF1ZXN0GhwubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xlIimC0+ST",
            "AiMSIS92MS97bmFtZT1wcm92aWRlcnMvKi92ZWhpY2xlcy8qfRKMAQoNVXBk",
            "YXRlVmVoaWNsZRIpLm1hcHMuZmxlZXRlbmdpbmUudjEuVXBkYXRlVmVoaWNs",
            "ZVJlcXVlc3QaHC5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGUiMoLT5JMC",
            "LBohL3YxL3tuYW1lPXByb3ZpZGVycy8qL3ZlaGljbGVzLyp9Ogd2ZWhpY2xl",
            "ErABChVVcGRhdGVWZWhpY2xlTG9jYXRpb24SMS5tYXBzLmZsZWV0ZW5naW5l",
            "LnYxLlVwZGF0ZVZlaGljbGVMb2NhdGlvblJlcXVlc3QaJC5tYXBzLmZsZWV0",
            "ZW5naW5lLnYxLlZlaGljbGVMb2NhdGlvbiI+iAIBgtPkkwI1GjAvdjEve25h",
            "bWU9cHJvdmlkZXJzLyovdmVoaWNsZXMvKn06dXBkYXRlTG9jYXRpb246ASoS",
            "wwEKF1VwZGF0ZVZlaGljbGVBdHRyaWJ1dGVzEjMubWFwcy5mbGVldGVuZ2lu",
            "ZS52MS5VcGRhdGVWZWhpY2xlQXR0cmlidXRlc1JlcXVlc3QaNC5tYXBzLmZs",
            "ZWV0ZW5naW5lLnYxLlVwZGF0ZVZlaGljbGVBdHRyaWJ1dGVzUmVzcG9uc2Ui",
            "PYLT5JMCNyIyL3YxL3tuYW1lPXByb3ZpZGVycy8qL3ZlaGljbGVzLyp9OnVw",
            "ZGF0ZUF0dHJpYnV0ZXM6ASoSjgEKDExpc3RWZWhpY2xlcxIoLm1hcHMuZmxl",
            "ZXRlbmdpbmUudjEuTGlzdFZlaGljbGVzUmVxdWVzdBopLm1hcHMuZmxlZXRl",
            "bmdpbmUudjEuTGlzdFZlaGljbGVzUmVzcG9uc2UiKYLT5JMCIxIhL3YxL3tw",
            "YXJlbnQ9cHJvdmlkZXJzLyp9L3ZlaGljbGVzEp4BCg5TZWFyY2hWZWhpY2xl",
            "cxIqLm1hcHMuZmxlZXRlbmdpbmUudjEuU2VhcmNoVmVoaWNsZXNSZXF1ZXN0",
            "GisubWFwcy5mbGVldGVuZ2luZS52MS5TZWFyY2hWZWhpY2xlc1Jlc3BvbnNl",
            "IjOC0+STAi0iKC92MS97cGFyZW50PXByb3ZpZGVycy8qfS92ZWhpY2xlczpz",
            "ZWFyY2g6ASoSqgEKFFNlYXJjaEZ1enplZFZlaGljbGVzEioubWFwcy5mbGVl",
            "dGVuZ2luZS52MS5TZWFyY2hWZWhpY2xlc1JlcXVlc3QaKy5tYXBzLmZsZWV0",
            "ZW5naW5lLnYxLlNlYXJjaFZlaGljbGVzUmVzcG9uc2UiOYLT5JMCMyIuL3Yx",
            "L3twYXJlbnQ9cHJvdmlkZXJzLyp9L3ZlaGljbGVzOnNlYXJjaEZ1enplZDoB",
            "KhodykEaZmxlZXRlbmdpbmUuZ29vZ2xlYXBpcy5jb21CdwoaZ29vZ2xlLm1h",
            "cHMuZmxlZXRlbmdpbmUudjFCClZlaGljbGVBcGlQAVpFZ29vZ2xlLmdvbGFu",
            "Zy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9tYXBzL2ZsZWV0ZW5naW5lL3Yx",
            "O2ZsZWV0ZW5naW5logIDQ0ZFYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor, global::Maps.Fleetengine.V1.HeaderReflection.Descriptor, global::Maps.Fleetengine.V1.VehiclesReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.FieldMaskReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Type.LatlngReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.CreateVehicleRequest), global::Maps.Fleetengine.V1.CreateVehicleRequest.Parser, new[]{ "Header", "Parent", "VehicleId", "Vehicle" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.GetVehicleRequest), global::Maps.Fleetengine.V1.GetVehicleRequest.Parser, new[]{ "Header", "Name", "CurrentRouteSegmentVersion", "WaypointsVersion" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.UpdateVehicleRequest), global::Maps.Fleetengine.V1.UpdateVehicleRequest.Parser, new[]{ "Header", "Name", "Vehicle", "UpdateMask" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.UpdateVehicleLocationRequest), global::Maps.Fleetengine.V1.UpdateVehicleLocationRequest.Parser, new[]{ "Header", "Name", "CurrentLocation", "CurrentState" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.UpdateVehicleAttributesRequest), global::Maps.Fleetengine.V1.UpdateVehicleAttributesRequest.Parser, new[]{ "Header", "Name", "Attributes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.UpdateVehicleAttributesResponse), global::Maps.Fleetengine.V1.UpdateVehicleAttributesResponse.Parser, new[]{ "Attributes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.SearchVehiclesRequest), global::Maps.Fleetengine.V1.SearchVehiclesRequest.Parser, new[]{ "Header", "Parent", "PickupPoint", "DropoffPoint", "PickupRadiusMeters", "Count", "MinimumCapacity", "TripTypes", "MaximumStaleness", "VehicleTypes", "RequiredAttributes", "RequiredOneOfAttributes", "RequiredOneOfAttributeSets", "OrderBy", "IncludeBackToBack", "TripId" }, null, new[]{ typeof(global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.SearchVehiclesResponse), global::Maps.Fleetengine.V1.SearchVehiclesResponse.Parser, new[]{ "Matches" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.ListVehiclesRequest), global::Maps.Fleetengine.V1.ListVehiclesRequest.Parser, new[]{ "Header", "Parent", "PageSize", "PageToken", "MinimumCapacity", "TripTypes", "MaximumStaleness", "VehicleTypeCategories", "RequiredAttributes", "RequiredOneOfAttributes", "RequiredOneOfAttributeSets", "VehicleState", "OnTripOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.ListVehiclesResponse), global::Maps.Fleetengine.V1.ListVehiclesResponse.Parser, new[]{ "Vehicles", "NextPageToken", "TotalSize" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.Waypoint), global::Maps.Fleetengine.V1.Waypoint.Parser, new[]{ "LatLng", "Eta" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.VehicleMatch), global::Maps.Fleetengine.V1.VehicleMatch.Parser, new[]{ "Vehicle", "VehiclePickupEta", "VehiclePickupDistanceMeters", "VehiclePickupStraightLineDistanceMeters", "VehicleDropoffEta", "VehiclePickupToDropoffDistanceMeters", "TripType", "VehicleTripsWaypoints", "VehicleMatchType", "RequestedOrderedBy", "OrderedBy" }, null, new[]{ typeof(global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.VehicleAttributeList), global::Maps.Fleetengine.V1.VehicleAttributeList.Parser, new[]{ "Attributes" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// CreateVehicle request message.
  /// </summary>
  public sealed partial class CreateVehicleRequest : pb::IMessage<CreateVehicleRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CreateVehicleRequest> _parser = new pb::MessageParser<CreateVehicleRequest>(() => new CreateVehicleRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreateVehicleRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVehicleRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVehicleRequest(CreateVehicleRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      vehicleId_ = other.vehicleId_;
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVehicleRequest Clone() {
      return new CreateVehicleRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 3;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format "providers/{provider}".
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle_id" field.</summary>
    public const int VehicleIdFieldNumber = 4;
    private string vehicleId_ = "";
    /// <summary>
    /// Required. Unique Vehicle ID; must be unique per provider.  The actual
    /// format and value is opaque to the Fleet Engine and is determined
    /// by the provider.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VehicleId {
      get { return vehicleId_; }
      set {
        vehicleId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 5;
    private global::Maps.Fleetengine.V1.Vehicle vehicle_;
    /// <summary>
    /// Required. The Vehicle entity to create. When creating a Vehicle, the following
    /// fields are required:
    ///
    /// * vehicle_state
    /// * supported_trip_types
    /// * maximum_capacity
    /// * vehicle_type
    ///
    /// When creating a Vehicle, the following fields are ignored:
    ///
    /// * name
    /// * current_trips
    /// * available_capacity
    /// * current_route_segment
    /// * current_route_segment_version
    /// * waypoints
    /// * waypoints_version
    /// * remaining_distance_meters
    /// * eta_to_next_waypoint
    /// * navigation_status
    ///
    /// All other fields will be used if provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.Vehicle Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreateVehicleRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreateVehicleRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (VehicleId != other.VehicleId) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (VehicleId.Length != 0) hash ^= VehicleId.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(VehicleId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Vehicle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(VehicleId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Vehicle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (VehicleId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VehicleId);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreateVehicleRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.VehicleId.Length != 0) {
        VehicleId = other.VehicleId;
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            VehicleId = input.ReadString();
            break;
          }
          case 42: {
            if (vehicle_ == null) {
              Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            VehicleId = input.ReadString();
            break;
          }
          case 42: {
            if (vehicle_ == null) {
              Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// GetVehicle request message.
  /// </summary>
  public sealed partial class GetVehicleRequest : pb::IMessage<GetVehicleRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetVehicleRequest> _parser = new pb::MessageParser<GetVehicleRequest>(() => new GetVehicleRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetVehicleRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVehicleRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVehicleRequest(GetVehicleRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      currentRouteSegmentVersion_ = other.currentRouteSegmentVersion_ != null ? other.currentRouteSegmentVersion_.Clone() : null;
      waypointsVersion_ = other.waypointsVersion_ != null ? other.waypointsVersion_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVehicleRequest Clone() {
      return new GetVehicleRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// "providers/{provider}/vehicles/{vehicle}".
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "current_route_segment_version" field.</summary>
    public const int CurrentRouteSegmentVersionFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp currentRouteSegmentVersion_;
    /// <summary>
    /// Indicates the minimum timestamp (exclusive) for which
    /// vehicle.current_route_segment is retrieved.
    /// If route is unchanged since this timestamp, the current_route_segment
    /// field is not set in the response. If a minimum is unspecified, the
    /// current_route_segment is always retrieved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CurrentRouteSegmentVersion {
      get { return currentRouteSegmentVersion_; }
      set {
        currentRouteSegmentVersion_ = value;
      }
    }

    /// <summary>Field number for the "waypoints_version" field.</summary>
    public const int WaypointsVersionFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp waypointsVersion_;
    /// <summary>
    /// Indicates the minimum timestamp (exclusive) for which vehicle.waypoints
    /// data is retrieved. If data is unchanged since this timestamp, the
    /// vehicle.waypoints data is not set in the response. If this field is
    /// unspecified, vehicle.waypoints is always retrieved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp WaypointsVersion {
      get { return waypointsVersion_; }
      set {
        waypointsVersion_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetVehicleRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetVehicleRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if (!object.Equals(CurrentRouteSegmentVersion, other.CurrentRouteSegmentVersion)) return false;
      if (!object.Equals(WaypointsVersion, other.WaypointsVersion)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (currentRouteSegmentVersion_ != null) hash ^= CurrentRouteSegmentVersion.GetHashCode();
      if (waypointsVersion_ != null) hash ^= WaypointsVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WaypointsVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WaypointsVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WaypointsVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetVehicleRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.currentRouteSegmentVersion_ != null) {
        if (currentRouteSegmentVersion_ == null) {
          CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CurrentRouteSegmentVersion.MergeFrom(other.CurrentRouteSegmentVersion);
      }
      if (other.waypointsVersion_ != null) {
        if (waypointsVersion_ == null) {
          WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        WaypointsVersion.MergeFrom(other.WaypointsVersion);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 42: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 42: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// UpdateVehicle request message.
  /// </summary>
  public sealed partial class UpdateVehicleRequest : pb::IMessage<UpdateVehicleRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateVehicleRequest> _parser = new pb::MessageParser<UpdateVehicleRequest>(() => new UpdateVehicleRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateVehicleRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleRequest(UpdateVehicleRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      updateMask_ = other.updateMask_ != null ? other.updateMask_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleRequest Clone() {
      return new UpdateVehicleRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// "providers/{provider}/vehicles/{vehicle}".
    /// The {provider} must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    ///
    /// Note that if the name is also specified in the name field of the
    /// vehicle and name is set in the update_mask, both names must be the
    /// same.  Otherwise it is an Error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 4;
    private global::Maps.Fleetengine.V1.Vehicle vehicle_;
    /// <summary>
    /// Required. The Vehicle entity update to apply.  When updating a Vehicle,
    /// the following fields may not be updated as they are managed by the
    /// Fleet Engine.
    ///   current_trips
    ///   available_capacity
    ///   current_route_segment_version
    ///   waypoints_version
    /// Furthermore, the name of the vehicle cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.Vehicle Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "update_mask" field.</summary>
    public const int UpdateMaskFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.FieldMask updateMask_;
    /// <summary>
    /// Required. A field mask indicating which fields of the Vehicle to update.
    /// The update_mask must contain at least one field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.FieldMask UpdateMask {
      get { return updateMask_; }
      set {
        updateMask_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateVehicleRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateVehicleRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(UpdateMask, other.UpdateMask)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (updateMask_ != null) hash ^= UpdateMask.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (updateMask_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateMask);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateVehicleRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.updateMask_ != null) {
        if (updateMask_ == null) {
          UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
        }
        UpdateMask.MergeFrom(other.UpdateMask);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 42: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 42: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// UpdateVehicleLocation request message.
  /// </summary>
  [global::System.ObsoleteAttribute]
  public sealed partial class UpdateVehicleLocationRequest : pb::IMessage<UpdateVehicleLocationRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateVehicleLocationRequest> _parser = new pb::MessageParser<UpdateVehicleLocationRequest>(() => new UpdateVehicleLocationRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateVehicleLocationRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleLocationRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleLocationRequest(UpdateVehicleLocationRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      currentLocation_ = other.currentLocation_ != null ? other.currentLocation_.Clone() : null;
      currentState_ = other.currentState_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleLocationRequest Clone() {
      return new UpdateVehicleLocationRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// "providers/{provider}/vehicles/{vehicle}.
    /// The {provider} must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "current_location" field.</summary>
    public const int CurrentLocationFieldNumber = 4;
    private global::Maps.Fleetengine.V1.VehicleLocation currentLocation_;
    /// <summary>
    /// Required. The location to update to.  The last_location and update_time
    /// subfields are required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.VehicleLocation CurrentLocation {
      get { return currentLocation_; }
      set {
        currentLocation_ = value;
      }
    }

    /// <summary>Field number for the "current_state" field.</summary>
    public const int CurrentStateFieldNumber = 5;
    private global::Maps.Fleetengine.V1.VehicleState currentState_ = global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState;
    /// <summary>
    /// Set current vehicle state to either ONLINE or OFFLINE;
    /// if set to UNKNOWN_VEHICLE_STATE, vehicle state will not be altered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.VehicleState CurrentState {
      get { return currentState_; }
      set {
        currentState_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateVehicleLocationRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateVehicleLocationRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if (!object.Equals(CurrentLocation, other.CurrentLocation)) return false;
      if (CurrentState != other.CurrentState) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (currentLocation_ != null) hash ^= CurrentLocation.GetHashCode();
      if (CurrentState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) hash ^= CurrentState.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentLocation_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CurrentLocation);
      }
      if (CurrentState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(40);
        output.WriteEnum((int) CurrentState);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentLocation_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CurrentLocation);
      }
      if (CurrentState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(40);
        output.WriteEnum((int) CurrentState);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (currentLocation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentLocation);
      }
      if (CurrentState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CurrentState);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateVehicleLocationRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.currentLocation_ != null) {
        if (currentLocation_ == null) {
          CurrentLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
        }
        CurrentLocation.MergeFrom(other.CurrentLocation);
      }
      if (other.CurrentState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        CurrentState = other.CurrentState;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (currentLocation_ == null) {
              CurrentLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
            }
            input.ReadMessage(CurrentLocation);
            break;
          }
          case 40: {
            CurrentState = (global::Maps.Fleetengine.V1.VehicleState) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (currentLocation_ == null) {
              CurrentLocation = new global::Maps.Fleetengine.V1.VehicleLocation();
            }
            input.ReadMessage(CurrentLocation);
            break;
          }
          case 40: {
            CurrentState = (global::Maps.Fleetengine.V1.VehicleState) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// UpdateVehicleAttributes request message.
  /// </summary>
  public sealed partial class UpdateVehicleAttributesRequest : pb::IMessage<UpdateVehicleAttributesRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateVehicleAttributesRequest> _parser = new pb::MessageParser<UpdateVehicleAttributesRequest>(() => new UpdateVehicleAttributesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateVehicleAttributesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleAttributesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleAttributesRequest(UpdateVehicleAttributesRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      attributes_ = other.attributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleAttributesRequest Clone() {
      return new UpdateVehicleAttributesRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// "providers/{provider}/vehicles/{vehicle}.
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(34, global::Maps.Fleetengine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute>();
    /// <summary>
    /// Required. The attributes to update;
    /// unmentioned attributes will not be altered or removed.
    /// At most 20 attributes; the combined "key:value" string length cannot
    /// exceed 256.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateVehicleAttributesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateVehicleAttributesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if(!attributes_.Equals(other.attributes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= attributes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateVehicleAttributesRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      attributes_.Add(other.attributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// UpdateVehicleAttributes response message.
  /// </summary>
  public sealed partial class UpdateVehicleAttributesResponse : pb::IMessage<UpdateVehicleAttributesResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateVehicleAttributesResponse> _parser = new pb::MessageParser<UpdateVehicleAttributesResponse>(() => new UpdateVehicleAttributesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateVehicleAttributesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleAttributesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleAttributesResponse(UpdateVehicleAttributesResponse other) : this() {
      attributes_ = other.attributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateVehicleAttributesResponse Clone() {
      return new UpdateVehicleAttributesResponse(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(10, global::Maps.Fleetengine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute>();
    /// <summary>
    /// Required. The updated full list of vehicle attributes, including new,
    /// altered and untouched attributes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateVehicleAttributesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateVehicleAttributesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateVehicleAttributesResponse other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SearchVehicles request message.
  /// </summary>
  public sealed partial class SearchVehiclesRequest : pb::IMessage<SearchVehiclesRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchVehiclesRequest> _parser = new pb::MessageParser<SearchVehiclesRequest>(() => new SearchVehiclesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SearchVehiclesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchVehiclesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchVehiclesRequest(SearchVehiclesRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      pickupPoint_ = other.pickupPoint_ != null ? other.pickupPoint_.Clone() : null;
      dropoffPoint_ = other.dropoffPoint_ != null ? other.dropoffPoint_.Clone() : null;
      pickupRadiusMeters_ = other.pickupRadiusMeters_;
      count_ = other.count_;
      minimumCapacity_ = other.minimumCapacity_;
      tripTypes_ = other.tripTypes_.Clone();
      maximumStaleness_ = other.maximumStaleness_ != null ? other.maximumStaleness_.Clone() : null;
      vehicleTypes_ = other.vehicleTypes_.Clone();
      requiredAttributes_ = other.requiredAttributes_.Clone();
      requiredOneOfAttributes_ = other.requiredOneOfAttributes_.Clone();
      requiredOneOfAttributeSets_ = other.requiredOneOfAttributeSets_.Clone();
      orderBy_ = other.orderBy_;
      includeBackToBack_ = other.includeBackToBack_;
      tripId_ = other.tripId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchVehiclesRequest Clone() {
      return new SearchVehiclesRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 3;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format "providers/{provider}".
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "pickup_point" field.</summary>
    public const int PickupPointFieldNumber = 4;
    private global::Maps.Fleetengine.V1.TerminalLocation pickupPoint_;
    /// <summary>
    /// Required. The pickup point to search near.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TerminalLocation PickupPoint {
      get { return pickupPoint_; }
      set {
        pickupPoint_ = value;
      }
    }

    /// <summary>Field number for the "dropoff_point" field.</summary>
    public const int DropoffPointFieldNumber = 5;
    private global::Maps.Fleetengine.V1.TerminalLocation dropoffPoint_;
    /// <summary>
    /// The customer's intended dropoff location. The field is required if
    /// trip_types contains TripType.SHARED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TerminalLocation DropoffPoint {
      get { return dropoffPoint_; }
      set {
        dropoffPoint_ = value;
      }
    }

    /// <summary>Field number for the "pickup_radius_meters" field.</summary>
    public const int PickupRadiusMetersFieldNumber = 6;
    private int pickupRadiusMeters_;
    /// <summary>
    /// Required. Defines the vehicle search radius around the pickup point. Only
    /// vehicles within the search radius will be returned. Value must be between
    /// 400 and 10000 meters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PickupRadiusMeters {
      get { return pickupRadiusMeters_; }
      set {
        pickupRadiusMeters_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 7;
    private int count_;
    /// <summary>
    /// Required. Specifies the maximum number of available vehicles to return. By
    /// default, the Fleet Engine limits the number to  50.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "minimum_capacity" field.</summary>
    public const int MinimumCapacityFieldNumber = 8;
    private int minimumCapacity_;
    /// <summary>
    /// Required. Specifies the minimum number of passengers allowed in the
    /// vehicle. Must number must be greater than or equal to one. The driver is
    /// not considered in the capacity search. This number indicates the number of
    /// passengers being considered for a trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinimumCapacity {
      get { return minimumCapacity_; }
      set {
        minimumCapacity_ = value;
      }
    }

    /// <summary>Field number for the "trip_types" field.</summary>
    public const int TripTypesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TripType> _repeated_tripTypes_codec
        = pb::FieldCodec.ForEnum(74, x => (int) x, x => (global::Maps.Fleetengine.V1.TripType) x);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType> tripTypes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType>();
    /// <summary>
    /// Required. Restricts the search to only those vehicles that support at least
    /// one of the specified trip types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType> TripTypes {
      get { return tripTypes_; }
    }

    /// <summary>Field number for the "maximum_staleness" field.</summary>
    public const int MaximumStalenessFieldNumber = 10;
    private global::Google.Protobuf.WellKnownTypes.Duration maximumStaleness_;
    /// <summary>
    /// Restricts the search to only those vehicles that have updated their
    /// locations within the specified duration back from now. If this field is not
    /// set, the server uses five minutes as the default value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MaximumStaleness {
      get { return maximumStaleness_; }
      set {
        maximumStaleness_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_types" field.</summary>
    public const int VehicleTypesFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType> _repeated_vehicleTypes_codec
        = pb::FieldCodec.ForMessage(114, global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType> vehicleTypes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType>();
    /// <summary>
    /// Required. Restricts the search to those vehicles with the specified types.
    /// At least one vehicle type must be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType> VehicleTypes {
      get { return vehicleTypes_; }
    }

    /// <summary>Field number for the "required_attributes" field.</summary>
    public const int RequiredAttributesFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleAttribute> _repeated_requiredAttributes_codec
        = pb::FieldCodec.ForMessage(98, global::Maps.Fleetengine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> requiredAttributes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute>();
    /// <summary>
    /// Callers can form complex logical operations using the
    /// requiredAttributes and requiredOneOfAttributes fields.
    ///
    /// requiredAttributes is a list; requiredOneOfAttributes uses a message which
    /// allows a list of lists. In combination, the two fields allow the
    /// composition of this expression:
    ///
    /// ```
    /// (required_attribute[0] AND required_attribute[1] AND ...)
    /// AND
    /// (required_one_of_attribute[0][0] OR required_one_of_attribute[0][1] OR ...)
    /// AND
    /// (required_one_of_attribute[1][0] OR required_one_of_attribute[1][1] OR ...)
    /// ```
    ///
    /// Restricts the search to only those vehicles with the specified attributes.
    /// This field is a conjunction/AND operation. Your app can specify up to 100
    /// attributes; however, the combined key:value string length cannot exceed
    /// 1024 characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> RequiredAttributes {
      get { return requiredAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attributes" field.</summary>
    public const int RequiredOneOfAttributesFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleAttributeList> _repeated_requiredOneOfAttributes_codec
        = pb::FieldCodec.ForMessage(122, global::Maps.Fleetengine.V1.VehicleAttributeList.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttributeList> requiredOneOfAttributes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttributeList>();
    /// <summary>
    /// Restricts the search to only those vehicles with at least one of
    /// the specified attributes applied to each VehicleAttributeList. Within each
    /// list, a vehicle must match at least one of the attributes. This field is an
    /// inclusive disjunction/OR operation in each VehicleAttributeList and a
    /// conjunction/AND operation across the collection of VehicleAttributeList.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttributeList> RequiredOneOfAttributes {
      get { return requiredOneOfAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attribute_sets" field.</summary>
    public const int RequiredOneOfAttributeSetsFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleAttributeList> _repeated_requiredOneOfAttributeSets_codec
        = pb::FieldCodec.ForMessage(162, global::Maps.Fleetengine.V1.VehicleAttributeList.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttributeList> requiredOneOfAttributeSets_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttributeList>();
    /// <summary>
    /// Restricts the search to only those vehicles with at least one set of the
    /// specified attributes in the VehicleAttributeList. Within each list, a
    /// vehicle must match all of the attributes. This field is a conjunction/AND
    /// operation in each VehicleAttributeList and inclusive disjunction/OR
    /// operation across the collection of VehicleAttributeList.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttributeList> RequiredOneOfAttributeSets {
      get { return requiredOneOfAttributeSets_; }
    }

    /// <summary>Field number for the "order_by" field.</summary>
    public const int OrderByFieldNumber = 13;
    private global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder orderBy_ = global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder;
    /// <summary>
    /// Required. Specifies ordering criterion for results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder OrderBy {
      get { return orderBy_; }
      set {
        orderBy_ = value;
      }
    }

    /// <summary>Field number for the "include_back_to_back" field.</summary>
    public const int IncludeBackToBackFieldNumber = 18;
    private bool includeBackToBack_;
    /// <summary>
    /// Indicates if a vehicle with an active trip is eligible for
    /// another match. If `false`, a vehicle is excluded from search results.
    /// If `true`, search results include vehicles with `TripStatus` of
    /// `ENROUTE_TO_DROPOFF`. The services only use this field if
    /// the `SearchVehicles` request has `TripType` set to EXCLUSIVE.
    /// Default value is `false`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeBackToBack {
      get { return includeBackToBack_; }
      set {
        includeBackToBack_ = value;
      }
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 19;
    private string tripId_ = "";
    /// <summary>
    /// Indicates the ID of the trip the searchVehicleRequest is
    /// associated with.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SearchVehiclesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SearchVehiclesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (!object.Equals(PickupPoint, other.PickupPoint)) return false;
      if (!object.Equals(DropoffPoint, other.DropoffPoint)) return false;
      if (PickupRadiusMeters != other.PickupRadiusMeters) return false;
      if (Count != other.Count) return false;
      if (MinimumCapacity != other.MinimumCapacity) return false;
      if(!tripTypes_.Equals(other.tripTypes_)) return false;
      if (!object.Equals(MaximumStaleness, other.MaximumStaleness)) return false;
      if(!vehicleTypes_.Equals(other.vehicleTypes_)) return false;
      if(!requiredAttributes_.Equals(other.requiredAttributes_)) return false;
      if(!requiredOneOfAttributes_.Equals(other.requiredOneOfAttributes_)) return false;
      if(!requiredOneOfAttributeSets_.Equals(other.requiredOneOfAttributeSets_)) return false;
      if (OrderBy != other.OrderBy) return false;
      if (IncludeBackToBack != other.IncludeBackToBack) return false;
      if (TripId != other.TripId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (pickupPoint_ != null) hash ^= PickupPoint.GetHashCode();
      if (dropoffPoint_ != null) hash ^= DropoffPoint.GetHashCode();
      if (PickupRadiusMeters != 0) hash ^= PickupRadiusMeters.GetHashCode();
      if (Count != 0) hash ^= Count.GetHashCode();
      if (MinimumCapacity != 0) hash ^= MinimumCapacity.GetHashCode();
      hash ^= tripTypes_.GetHashCode();
      if (maximumStaleness_ != null) hash ^= MaximumStaleness.GetHashCode();
      hash ^= vehicleTypes_.GetHashCode();
      hash ^= requiredAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributeSets_.GetHashCode();
      if (OrderBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) hash ^= OrderBy.GetHashCode();
      if (IncludeBackToBack != false) hash ^= IncludeBackToBack.GetHashCode();
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (pickupPoint_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PickupPoint);
      }
      if (dropoffPoint_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DropoffPoint);
      }
      if (PickupRadiusMeters != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(PickupRadiusMeters);
      }
      if (Count != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(Count);
      }
      if (MinimumCapacity != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(MinimumCapacity);
      }
      tripTypes_.WriteTo(output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(MaximumStaleness);
      }
      requiredAttributes_.WriteTo(output, _repeated_requiredAttributes_codec);
      if (OrderBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(104);
        output.WriteEnum((int) OrderBy);
      }
      vehicleTypes_.WriteTo(output, _repeated_vehicleTypes_codec);
      requiredOneOfAttributes_.WriteTo(output, _repeated_requiredOneOfAttributes_codec);
      if (IncludeBackToBack != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(IncludeBackToBack);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(TripId);
      }
      requiredOneOfAttributeSets_.WriteTo(output, _repeated_requiredOneOfAttributeSets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (pickupPoint_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PickupPoint);
      }
      if (dropoffPoint_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DropoffPoint);
      }
      if (PickupRadiusMeters != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(PickupRadiusMeters);
      }
      if (Count != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(Count);
      }
      if (MinimumCapacity != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(MinimumCapacity);
      }
      tripTypes_.WriteTo(ref output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(MaximumStaleness);
      }
      requiredAttributes_.WriteTo(ref output, _repeated_requiredAttributes_codec);
      if (OrderBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(104);
        output.WriteEnum((int) OrderBy);
      }
      vehicleTypes_.WriteTo(ref output, _repeated_vehicleTypes_codec);
      requiredOneOfAttributes_.WriteTo(ref output, _repeated_requiredOneOfAttributes_codec);
      if (IncludeBackToBack != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(IncludeBackToBack);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(TripId);
      }
      requiredOneOfAttributeSets_.WriteTo(ref output, _repeated_requiredOneOfAttributeSets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (pickupPoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickupPoint);
      }
      if (dropoffPoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DropoffPoint);
      }
      if (PickupRadiusMeters != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PickupRadiusMeters);
      }
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      if (MinimumCapacity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinimumCapacity);
      }
      size += tripTypes_.CalculateSize(_repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaximumStaleness);
      }
      size += vehicleTypes_.CalculateSize(_repeated_vehicleTypes_codec);
      size += requiredAttributes_.CalculateSize(_repeated_requiredAttributes_codec);
      size += requiredOneOfAttributes_.CalculateSize(_repeated_requiredOneOfAttributes_codec);
      size += requiredOneOfAttributeSets_.CalculateSize(_repeated_requiredOneOfAttributeSets_codec);
      if (OrderBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OrderBy);
      }
      if (IncludeBackToBack != false) {
        size += 2 + 1;
      }
      if (TripId.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SearchVehiclesRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.pickupPoint_ != null) {
        if (pickupPoint_ == null) {
          PickupPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
        }
        PickupPoint.MergeFrom(other.PickupPoint);
      }
      if (other.dropoffPoint_ != null) {
        if (dropoffPoint_ == null) {
          DropoffPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
        }
        DropoffPoint.MergeFrom(other.DropoffPoint);
      }
      if (other.PickupRadiusMeters != 0) {
        PickupRadiusMeters = other.PickupRadiusMeters;
      }
      if (other.Count != 0) {
        Count = other.Count;
      }
      if (other.MinimumCapacity != 0) {
        MinimumCapacity = other.MinimumCapacity;
      }
      tripTypes_.Add(other.tripTypes_);
      if (other.maximumStaleness_ != null) {
        if (maximumStaleness_ == null) {
          MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaximumStaleness.MergeFrom(other.MaximumStaleness);
      }
      vehicleTypes_.Add(other.vehicleTypes_);
      requiredAttributes_.Add(other.requiredAttributes_);
      requiredOneOfAttributes_.Add(other.requiredOneOfAttributes_);
      requiredOneOfAttributeSets_.Add(other.requiredOneOfAttributeSets_);
      if (other.OrderBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        OrderBy = other.OrderBy;
      }
      if (other.IncludeBackToBack != false) {
        IncludeBackToBack = other.IncludeBackToBack;
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            if (pickupPoint_ == null) {
              PickupPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(PickupPoint);
            break;
          }
          case 42: {
            if (dropoffPoint_ == null) {
              DropoffPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(DropoffPoint);
            break;
          }
          case 48: {
            PickupRadiusMeters = input.ReadInt32();
            break;
          }
          case 56: {
            Count = input.ReadInt32();
            break;
          }
          case 64: {
            MinimumCapacity = input.ReadInt32();
            break;
          }
          case 74:
          case 72: {
            tripTypes_.AddEntriesFrom(input, _repeated_tripTypes_codec);
            break;
          }
          case 82: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 98: {
            requiredAttributes_.AddEntriesFrom(input, _repeated_requiredAttributes_codec);
            break;
          }
          case 104: {
            OrderBy = (global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 114: {
            vehicleTypes_.AddEntriesFrom(input, _repeated_vehicleTypes_codec);
            break;
          }
          case 122: {
            requiredOneOfAttributes_.AddEntriesFrom(input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 144: {
            IncludeBackToBack = input.ReadBool();
            break;
          }
          case 154: {
            TripId = input.ReadString();
            break;
          }
          case 162: {
            requiredOneOfAttributeSets_.AddEntriesFrom(input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            if (pickupPoint_ == null) {
              PickupPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(PickupPoint);
            break;
          }
          case 42: {
            if (dropoffPoint_ == null) {
              DropoffPoint = new global::Maps.Fleetengine.V1.TerminalLocation();
            }
            input.ReadMessage(DropoffPoint);
            break;
          }
          case 48: {
            PickupRadiusMeters = input.ReadInt32();
            break;
          }
          case 56: {
            Count = input.ReadInt32();
            break;
          }
          case 64: {
            MinimumCapacity = input.ReadInt32();
            break;
          }
          case 74:
          case 72: {
            tripTypes_.AddEntriesFrom(ref input, _repeated_tripTypes_codec);
            break;
          }
          case 82: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 98: {
            requiredAttributes_.AddEntriesFrom(ref input, _repeated_requiredAttributes_codec);
            break;
          }
          case 104: {
            OrderBy = (global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 114: {
            vehicleTypes_.AddEntriesFrom(ref input, _repeated_vehicleTypes_codec);
            break;
          }
          case 122: {
            requiredOneOfAttributes_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 144: {
            IncludeBackToBack = input.ReadBool();
            break;
          }
          case 154: {
            TripId = input.ReadString();
            break;
          }
          case 162: {
            requiredOneOfAttributeSets_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SearchVehiclesRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Specifies the sort order of the vehicle matches in the response.
      /// </summary>
      public enum VehicleMatchOrder {
        /// <summary>
        /// Default, used for unspecified or unrecognized vehicle matches order.
        /// </summary>
        [pbr::OriginalName("UNKNOWN_VEHICLE_MATCH_ORDER")] UnknownVehicleMatchOrder = 0,
        /// <summary>
        /// Ascending order by vehicle driving time to the pickup point.
        /// </summary>
        [pbr::OriginalName("PICKUP_POINT_ETA")] PickupPointEta = 1,
        /// <summary>
        /// Ascending order by the vehicle driving distance to the pickup point.
        /// </summary>
        [pbr::OriginalName("PICKUP_POINT_DISTANCE")] PickupPointDistance = 2,
        /// <summary>
        /// Ascending order by vehicle driving time to the dropoff point. This order
        /// can only be used if the dropoff_point is specified in the request.
        /// </summary>
        [pbr::OriginalName("DROPOFF_POINT_ETA")] DropoffPointEta = 3,
        /// <summary>
        /// Ascending order by straightline distance from vehicle location to pickup
        /// location. This is used primarily as a backup if the maps backend is not
        /// reachable.
        /// </summary>
        [pbr::OriginalName("PICKUP_POINT_STRAIGHT_DISTANCE")] PickupPointStraightDistance = 4,
        /// <summary>
        /// Ascending order by the match cost.
        /// </summary>
        [pbr::OriginalName("COST")] Cost = 5,
      }

    }
    #endregion

  }

  /// <summary>
  /// SearchVehicles response message.
  /// </summary>
  public sealed partial class SearchVehiclesResponse : pb::IMessage<SearchVehiclesResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchVehiclesResponse> _parser = new pb::MessageParser<SearchVehiclesResponse>(() => new SearchVehiclesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SearchVehiclesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchVehiclesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchVehiclesResponse(SearchVehiclesResponse other) : this() {
      matches_ = other.matches_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchVehiclesResponse Clone() {
      return new SearchVehiclesResponse(this);
    }

    /// <summary>Field number for the "matches" field.</summary>
    public const int MatchesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleMatch> _repeated_matches_codec
        = pb::FieldCodec.ForMessage(10, global::Maps.Fleetengine.V1.VehicleMatch.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleMatch> matches_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleMatch>();
    /// <summary>
    /// List of vehicles that match the request options.
    ///
    /// Ordered by ascending vehicle_pickup_eta, with ties broken by ascending
    /// trip_type enum value, followed by matches that don't have
    /// vehicle_pickup_eta set.
    ///
    /// Example response: (Logically represented, not actual response fields):
    ///
    /// * (VehicleId: Vehicle1, ETA: 10 AM, TripType: SHARED),
    /// * (VehicleId: Vehicle2, ETA: 10 AM, TripType: EXCLUSIVE),
    /// * (VehicleId: Vehicle3, ETA: 11 AM, TripType: EXCLUSIVE),
    /// * (VehicleId: Vehicle4, ETA: Not set, TripType: SHARED),
    /// * (VehicleId: Vehicle5, ETA: Not set, TripType: EXCLUSIVE)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleMatch> Matches {
      get { return matches_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SearchVehiclesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SearchVehiclesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!matches_.Equals(other.matches_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= matches_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      matches_.WriteTo(output, _repeated_matches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      matches_.WriteTo(ref output, _repeated_matches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += matches_.CalculateSize(_repeated_matches_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SearchVehiclesResponse other) {
      if (other == null) {
        return;
      }
      matches_.Add(other.matches_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            matches_.AddEntriesFrom(input, _repeated_matches_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            matches_.AddEntriesFrom(ref input, _repeated_matches_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ListVehicles request message.
  /// </summary>
  public sealed partial class ListVehiclesRequest : pb::IMessage<ListVehiclesRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ListVehiclesRequest> _parser = new pb::MessageParser<ListVehiclesRequest>(() => new ListVehiclesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListVehiclesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVehiclesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVehiclesRequest(ListVehiclesRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      pageSize_ = other.pageSize_;
      pageToken_ = other.pageToken_;
      MinimumCapacity = other.MinimumCapacity;
      tripTypes_ = other.tripTypes_.Clone();
      maximumStaleness_ = other.maximumStaleness_ != null ? other.maximumStaleness_.Clone() : null;
      vehicleTypeCategories_ = other.vehicleTypeCategories_.Clone();
      requiredAttributes_ = other.requiredAttributes_.Clone();
      requiredOneOfAttributes_ = other.requiredOneOfAttributes_.Clone();
      requiredOneOfAttributeSets_ = other.requiredOneOfAttributeSets_.Clone();
      vehicleState_ = other.vehicleState_;
      onTripOnly_ = other.onTripOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVehiclesRequest Clone() {
      return new ListVehiclesRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 12;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format "providers/{provider}".
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "page_size" field.</summary>
    public const int PageSizeFieldNumber = 3;
    private int pageSize_;
    /// <summary>
    /// The maximum number of vehicles to return.
    /// Default value: 100.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PageSize {
      get { return pageSize_; }
      set {
        pageSize_ = value;
      }
    }

    /// <summary>Field number for the "page_token" field.</summary>
    public const int PageTokenFieldNumber = 4;
    private string pageToken_ = "";
    /// <summary>
    /// The next_page_token value returned from a previous response, if any.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PageToken {
      get { return pageToken_; }
      set {
        pageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "minimum_capacity" field.</summary>
    public const int MinimumCapacityFieldNumber = 6;
    private static readonly pb::FieldCodec<int?> _single_minimumCapacity_codec = pb::FieldCodec.ForStructWrapper<int>(50);
    private int? minimumCapacity_;
    /// <summary>
    /// Specifies the required minimum capacity of the vehicle.
    /// The driver is not considered in the capacity search.
    /// This is just the number of passengers being considered for a trip.
    /// If set, must be greater or equal to 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? MinimumCapacity {
      get { return minimumCapacity_; }
      set {
        minimumCapacity_ = value;
      }
    }


    /// <summary>Field number for the "trip_types" field.</summary>
    public const int TripTypesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.TripType> _repeated_tripTypes_codec
        = pb::FieldCodec.ForEnum(58, x => (int) x, x => (global::Maps.Fleetengine.V1.TripType) x);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType> tripTypes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType>();
    /// <summary>
    /// Restrict the search to only those vehicles that support at least
    /// one of the specified trip types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.TripType> TripTypes {
      get { return tripTypes_; }
    }

    /// <summary>Field number for the "maximum_staleness" field.</summary>
    public const int MaximumStalenessFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration maximumStaleness_;
    /// <summary>
    /// Restrict the search to only those vehicles that have updated
    /// their locations within the specified duration back from now.
    /// If present, must be a valid positive duration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MaximumStaleness {
      get { return maximumStaleness_; }
      set {
        maximumStaleness_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_type_categories" field.</summary>
    public const int VehicleTypeCategoriesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category> _repeated_vehicleTypeCategories_codec
        = pb::FieldCodec.ForEnum(74, x => (int) x, x => (global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category) x);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category> vehicleTypeCategories_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category>();
    /// <summary>
    /// Required. Restrict the search to those vehicles with the specified type categories.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle.Types.VehicleType.Types.Category> VehicleTypeCategories {
      get { return vehicleTypeCategories_; }
    }

    /// <summary>Field number for the "required_attributes" field.</summary>
    public const int RequiredAttributesFieldNumber = 10;
    private static readonly pb::FieldCodec<string> _repeated_requiredAttributes_codec
        = pb::FieldCodec.ForString(82);
    private readonly pbc::RepeatedField<string> requiredAttributes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Callers can form complex logical operations using the
    /// requiredAttributes and requiredOneOfAttributes fields.
    ///
    /// requiredAttributes is a list; requiredOneOfAttributes uses a message which
    /// allows a list of lists. In combination, the two fields allow the
    /// composition of this expression:
    ///
    /// ```
    /// (required_attribute[0] AND required_attribute[1] AND ...)
    /// AND
    /// (required_one_of_attribute[0][0] OR required_one_of_attribute[0][1] OR ...)
    /// AND
    /// (required_one_of_attribute[1][0] OR required_one_of_attribute[1][1] OR ...)
    /// ```
    ///
    /// Restrict the search to only those vehicles
    /// with the specified attributes. This field is a conjunction/AND operation.
    /// Your app can specify up to 100 attributes; however, the combined
    /// key:value string length cannot exceed 1024 characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> RequiredAttributes {
      get { return requiredAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attributes" field.</summary>
    public const int RequiredOneOfAttributesFieldNumber = 13;
    private static readonly pb::FieldCodec<string> _repeated_requiredOneOfAttributes_codec
        = pb::FieldCodec.ForString(106);
    private readonly pbc::RepeatedField<string> requiredOneOfAttributes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Restrict the search to only those vehicles with at least one
    /// of the specified attributes applied to each VehicleAttributeList.
    /// Within each list, a vehicle must match at least one of the attributes.
    /// This field is an inclusive disjunction/OR operation in each
    /// VehicleAttributeList and a conjunction/AND operation across the collection
    /// of VehicleAttributeList.
    /// Format: key1:value1|key2:value2|key3:value3...
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> RequiredOneOfAttributes {
      get { return requiredOneOfAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attribute_sets" field.</summary>
    public const int RequiredOneOfAttributeSetsFieldNumber = 15;
    private static readonly pb::FieldCodec<string> _repeated_requiredOneOfAttributeSets_codec
        = pb::FieldCodec.ForString(122);
    private readonly pbc::RepeatedField<string> requiredOneOfAttributeSets_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Restrict the search to only those vehicles with at least one set of the
    /// specified attributes in the VehicleAttributeList. Within each list, a
    /// vehicle must match all of the attributes. This field is a conjunction/AND
    /// operation in each VehicleAttributeList and inclusive disjunction/OR
    /// operation across the collection of VehicleAttributeList.
    /// Format: key1:value1|key2:value2|key3:value3...
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> RequiredOneOfAttributeSets {
      get { return requiredOneOfAttributeSets_; }
    }

    /// <summary>Field number for the "vehicle_state" field.</summary>
    public const int VehicleStateFieldNumber = 11;
    private global::Maps.Fleetengine.V1.VehicleState vehicleState_ = global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState;
    /// <summary>
    /// Restrict the search to only those vehicles that have this vehicle state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.VehicleState VehicleState {
      get { return vehicleState_; }
      set {
        vehicleState_ = value;
      }
    }

    /// <summary>Field number for the "on_trip_only" field.</summary>
    public const int OnTripOnlyFieldNumber = 14;
    private bool onTripOnly_;
    /// <summary>
    /// Only return the vehicles with current trip(s).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OnTripOnly {
      get { return onTripOnly_; }
      set {
        onTripOnly_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListVehiclesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListVehiclesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (PageSize != other.PageSize) return false;
      if (PageToken != other.PageToken) return false;
      if (MinimumCapacity != other.MinimumCapacity) return false;
      if(!tripTypes_.Equals(other.tripTypes_)) return false;
      if (!object.Equals(MaximumStaleness, other.MaximumStaleness)) return false;
      if(!vehicleTypeCategories_.Equals(other.vehicleTypeCategories_)) return false;
      if(!requiredAttributes_.Equals(other.requiredAttributes_)) return false;
      if(!requiredOneOfAttributes_.Equals(other.requiredOneOfAttributes_)) return false;
      if(!requiredOneOfAttributeSets_.Equals(other.requiredOneOfAttributeSets_)) return false;
      if (VehicleState != other.VehicleState) return false;
      if (OnTripOnly != other.OnTripOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (PageSize != 0) hash ^= PageSize.GetHashCode();
      if (PageToken.Length != 0) hash ^= PageToken.GetHashCode();
      if (minimumCapacity_ != null) hash ^= MinimumCapacity.GetHashCode();
      hash ^= tripTypes_.GetHashCode();
      if (maximumStaleness_ != null) hash ^= MaximumStaleness.GetHashCode();
      hash ^= vehicleTypeCategories_.GetHashCode();
      hash ^= requiredAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributeSets_.GetHashCode();
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) hash ^= VehicleState.GetHashCode();
      if (OnTripOnly != false) hash ^= OnTripOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (PageSize != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PageToken);
      }
      if (minimumCapacity_ != null) {
        _single_minimumCapacity_codec.WriteTagAndValue(output, MinimumCapacity);
      }
      tripTypes_.WriteTo(output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MaximumStaleness);
      }
      vehicleTypeCategories_.WriteTo(output, _repeated_vehicleTypeCategories_codec);
      requiredAttributes_.WriteTo(output, _repeated_requiredAttributes_codec);
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(88);
        output.WriteEnum((int) VehicleState);
      }
      if (header_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Header);
      }
      requiredOneOfAttributes_.WriteTo(output, _repeated_requiredOneOfAttributes_codec);
      if (OnTripOnly != false) {
        output.WriteRawTag(112);
        output.WriteBool(OnTripOnly);
      }
      requiredOneOfAttributeSets_.WriteTo(output, _repeated_requiredOneOfAttributeSets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (PageSize != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PageToken);
      }
      if (minimumCapacity_ != null) {
        _single_minimumCapacity_codec.WriteTagAndValue(ref output, MinimumCapacity);
      }
      tripTypes_.WriteTo(ref output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MaximumStaleness);
      }
      vehicleTypeCategories_.WriteTo(ref output, _repeated_vehicleTypeCategories_codec);
      requiredAttributes_.WriteTo(ref output, _repeated_requiredAttributes_codec);
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(88);
        output.WriteEnum((int) VehicleState);
      }
      if (header_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Header);
      }
      requiredOneOfAttributes_.WriteTo(ref output, _repeated_requiredOneOfAttributes_codec);
      if (OnTripOnly != false) {
        output.WriteRawTag(112);
        output.WriteBool(OnTripOnly);
      }
      requiredOneOfAttributeSets_.WriteTo(ref output, _repeated_requiredOneOfAttributeSets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (PageSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PageSize);
      }
      if (PageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PageToken);
      }
      if (minimumCapacity_ != null) {
        size += _single_minimumCapacity_codec.CalculateSizeWithTag(MinimumCapacity);
      }
      size += tripTypes_.CalculateSize(_repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaximumStaleness);
      }
      size += vehicleTypeCategories_.CalculateSize(_repeated_vehicleTypeCategories_codec);
      size += requiredAttributes_.CalculateSize(_repeated_requiredAttributes_codec);
      size += requiredOneOfAttributes_.CalculateSize(_repeated_requiredOneOfAttributes_codec);
      size += requiredOneOfAttributeSets_.CalculateSize(_repeated_requiredOneOfAttributeSets_codec);
      if (VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) VehicleState);
      }
      if (OnTripOnly != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListVehiclesRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.PageSize != 0) {
        PageSize = other.PageSize;
      }
      if (other.PageToken.Length != 0) {
        PageToken = other.PageToken;
      }
      if (other.minimumCapacity_ != null) {
        if (minimumCapacity_ == null || other.MinimumCapacity != 0) {
          MinimumCapacity = other.MinimumCapacity;
        }
      }
      tripTypes_.Add(other.tripTypes_);
      if (other.maximumStaleness_ != null) {
        if (maximumStaleness_ == null) {
          MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaximumStaleness.MergeFrom(other.MaximumStaleness);
      }
      vehicleTypeCategories_.Add(other.vehicleTypeCategories_);
      requiredAttributes_.Add(other.requiredAttributes_);
      requiredOneOfAttributes_.Add(other.requiredOneOfAttributes_);
      requiredOneOfAttributeSets_.Add(other.requiredOneOfAttributeSets_);
      if (other.VehicleState != global::Maps.Fleetengine.V1.VehicleState.UnknownVehicleState) {
        VehicleState = other.VehicleState;
      }
      if (other.OnTripOnly != false) {
        OnTripOnly = other.OnTripOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 24: {
            PageSize = input.ReadInt32();
            break;
          }
          case 34: {
            PageToken = input.ReadString();
            break;
          }
          case 50: {
            int? value = _single_minimumCapacity_codec.Read(input);
            if (minimumCapacity_ == null || value != 0) {
              MinimumCapacity = value;
            }
            break;
          }
          case 58:
          case 56: {
            tripTypes_.AddEntriesFrom(input, _repeated_tripTypes_codec);
            break;
          }
          case 66: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 74:
          case 72: {
            vehicleTypeCategories_.AddEntriesFrom(input, _repeated_vehicleTypeCategories_codec);
            break;
          }
          case 82: {
            requiredAttributes_.AddEntriesFrom(input, _repeated_requiredAttributes_codec);
            break;
          }
          case 88: {
            VehicleState = (global::Maps.Fleetengine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 98: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 106: {
            requiredOneOfAttributes_.AddEntriesFrom(input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 112: {
            OnTripOnly = input.ReadBool();
            break;
          }
          case 122: {
            requiredOneOfAttributeSets_.AddEntriesFrom(input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 24: {
            PageSize = input.ReadInt32();
            break;
          }
          case 34: {
            PageToken = input.ReadString();
            break;
          }
          case 50: {
            int? value = _single_minimumCapacity_codec.Read(ref input);
            if (minimumCapacity_ == null || value != 0) {
              MinimumCapacity = value;
            }
            break;
          }
          case 58:
          case 56: {
            tripTypes_.AddEntriesFrom(ref input, _repeated_tripTypes_codec);
            break;
          }
          case 66: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 74:
          case 72: {
            vehicleTypeCategories_.AddEntriesFrom(ref input, _repeated_vehicleTypeCategories_codec);
            break;
          }
          case 82: {
            requiredAttributes_.AddEntriesFrom(ref input, _repeated_requiredAttributes_codec);
            break;
          }
          case 88: {
            VehicleState = (global::Maps.Fleetengine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 98: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 106: {
            requiredOneOfAttributes_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 112: {
            OnTripOnly = input.ReadBool();
            break;
          }
          case 122: {
            requiredOneOfAttributeSets_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ListVehicles response message.
  /// </summary>
  public sealed partial class ListVehiclesResponse : pb::IMessage<ListVehiclesResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ListVehiclesResponse> _parser = new pb::MessageParser<ListVehiclesResponse>(() => new ListVehiclesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListVehiclesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVehiclesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVehiclesResponse(ListVehiclesResponse other) : this() {
      vehicles_ = other.vehicles_.Clone();
      nextPageToken_ = other.nextPageToken_;
      totalSize_ = other.totalSize_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVehiclesResponse Clone() {
      return new ListVehiclesResponse(this);
    }

    /// <summary>Field number for the "vehicles" field.</summary>
    public const int VehiclesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.Vehicle> _repeated_vehicles_codec
        = pb::FieldCodec.ForMessage(10, global::Maps.Fleetengine.V1.Vehicle.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle> vehicles_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle>();
    /// <summary>
    /// Depends on vehicles matching request criteria.
    /// There will be a maximum number of vehicles returned based on the page_size
    /// field in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.Vehicle> Vehicles {
      get { return vehicles_; }
    }

    /// <summary>Field number for the "next_page_token" field.</summary>
    public const int NextPageTokenFieldNumber = 2;
    private string nextPageToken_ = "";
    /// <summary>
    /// Token to retrieve the next page of vehicles, or empty if there are no
    /// more vehicles in the list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NextPageToken {
      get { return nextPageToken_; }
      set {
        nextPageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "total_size" field.</summary>
    public const int TotalSizeFieldNumber = 3;
    private long totalSize_;
    /// <summary>
    /// Required. Total number of vehicles matching request criteria across all pages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TotalSize {
      get { return totalSize_; }
      set {
        totalSize_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListVehiclesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListVehiclesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!vehicles_.Equals(other.vehicles_)) return false;
      if (NextPageToken != other.NextPageToken) return false;
      if (TotalSize != other.TotalSize) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= vehicles_.GetHashCode();
      if (NextPageToken.Length != 0) hash ^= NextPageToken.GetHashCode();
      if (TotalSize != 0L) hash ^= TotalSize.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      vehicles_.WriteTo(output, _repeated_vehicles_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (TotalSize != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      vehicles_.WriteTo(ref output, _repeated_vehicles_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (TotalSize != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += vehicles_.CalculateSize(_repeated_vehicles_codec);
      if (NextPageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NextPageToken);
      }
      if (TotalSize != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalSize);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListVehiclesResponse other) {
      if (other == null) {
        return;
      }
      vehicles_.Add(other.vehicles_);
      if (other.NextPageToken.Length != 0) {
        NextPageToken = other.NextPageToken;
      }
      if (other.TotalSize != 0L) {
        TotalSize = other.TotalSize;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            vehicles_.AddEntriesFrom(input, _repeated_vehicles_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
          case 24: {
            TotalSize = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            vehicles_.AddEntriesFrom(ref input, _repeated_vehicles_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
          case 24: {
            TotalSize = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Waypoint describes intermediate points along a route.
  /// </summary>
  public sealed partial class Waypoint : pb::IMessage<Waypoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Waypoint> _parser = new pb::MessageParser<Waypoint>(() => new Waypoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Waypoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Waypoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Waypoint(Waypoint other) : this() {
      latLng_ = other.latLng_ != null ? other.latLng_.Clone() : null;
      eta_ = other.eta_ != null ? other.eta_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Waypoint Clone() {
      return new Waypoint(this);
    }

    /// <summary>Field number for the "lat_lng" field.</summary>
    public const int LatLngFieldNumber = 1;
    private global::Google.Type.LatLng latLng_;
    /// <summary>
    /// The location of this waypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng LatLng {
      get { return latLng_; }
      set {
        latLng_ = value;
      }
    }

    /// <summary>Field number for the "eta" field.</summary>
    public const int EtaFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp eta_;
    /// <summary>
    /// The estimated time that the vehicle will arrive at this waypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Eta {
      get { return eta_; }
      set {
        eta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Waypoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Waypoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LatLng, other.LatLng)) return false;
      if (!object.Equals(Eta, other.Eta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (latLng_ != null) hash ^= LatLng.GetHashCode();
      if (eta_ != null) hash ^= Eta.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (latLng_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LatLng);
      }
      if (eta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Eta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (latLng_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LatLng);
      }
      if (eta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Eta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (latLng_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LatLng);
      }
      if (eta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Eta);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Waypoint other) {
      if (other == null) {
        return;
      }
      if (other.latLng_ != null) {
        if (latLng_ == null) {
          LatLng = new global::Google.Type.LatLng();
        }
        LatLng.MergeFrom(other.LatLng);
      }
      if (other.eta_ != null) {
        if (eta_ == null) {
          Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Eta.MergeFrom(other.Eta);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (latLng_ == null) {
              LatLng = new global::Google.Type.LatLng();
            }
            input.ReadMessage(LatLng);
            break;
          }
          case 18: {
            if (eta_ == null) {
              Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Eta);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (latLng_ == null) {
              LatLng = new global::Google.Type.LatLng();
            }
            input.ReadMessage(LatLng);
            break;
          }
          case 18: {
            if (eta_ == null) {
              Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Eta);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// VehicleMatch contains the vehicle, ETA, and distance calculations for a
  /// vehicle that matches the SearchVehiclesRequest.
  /// </summary>
  public sealed partial class VehicleMatch : pb::IMessage<VehicleMatch>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehicleMatch> _parser = new pb::MessageParser<VehicleMatch>(() => new VehicleMatch());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VehicleMatch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleMatch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleMatch(VehicleMatch other) : this() {
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      vehiclePickupEta_ = other.vehiclePickupEta_ != null ? other.vehiclePickupEta_.Clone() : null;
      VehiclePickupDistanceMeters = other.VehiclePickupDistanceMeters;
      VehiclePickupStraightLineDistanceMeters = other.VehiclePickupStraightLineDistanceMeters;
      vehicleDropoffEta_ = other.vehicleDropoffEta_ != null ? other.vehicleDropoffEta_.Clone() : null;
      VehiclePickupToDropoffDistanceMeters = other.VehiclePickupToDropoffDistanceMeters;
      tripType_ = other.tripType_;
      vehicleTripsWaypoints_ = other.vehicleTripsWaypoints_.Clone();
      vehicleMatchType_ = other.vehicleMatchType_;
      requestedOrderedBy_ = other.requestedOrderedBy_;
      orderedBy_ = other.orderedBy_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleMatch Clone() {
      return new VehicleMatch(this);
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 1;
    private global::Maps.Fleetengine.V1.Vehicle vehicle_;
    /// <summary>
    /// Required. A vehicle that matches the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.Vehicle Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_pickup_eta" field.</summary>
    public const int VehiclePickupEtaFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp vehiclePickupEta_;
    /// <summary>
    /// The vehicle's driving ETA to the pickup point specified in the
    /// request. An empty value indicates a failure in calculating ETA for the
    /// vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp VehiclePickupEta {
      get { return vehiclePickupEta_; }
      set {
        vehiclePickupEta_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_pickup_distance_meters" field.</summary>
    public const int VehiclePickupDistanceMetersFieldNumber = 3;
    private static readonly pb::FieldCodec<int?> _single_vehiclePickupDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(26);
    private int? vehiclePickupDistanceMeters_;
    /// <summary>
    /// The vehicle's driving distance to the pickup point specified in
    /// the request, including any intermediate pickup or dropoff points for
    /// an existing ride.  An empty value indicates a failure in calculating
    /// distance for the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? VehiclePickupDistanceMeters {
      get { return vehiclePickupDistanceMeters_; }
      set {
        vehiclePickupDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "vehicle_pickup_straight_line_distance_meters" field.</summary>
    public const int VehiclePickupStraightLineDistanceMetersFieldNumber = 11;
    private static readonly pb::FieldCodec<int?> _single_vehiclePickupStraightLineDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(90);
    private int? vehiclePickupStraightLineDistanceMeters_;
    /// <summary>
    /// Required. The straight-line distance between the vehicle and the pickup
    /// point specified in the request, including intermediate waypoints for
    /// existing trips.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? VehiclePickupStraightLineDistanceMeters {
      get { return vehiclePickupStraightLineDistanceMeters_; }
      set {
        vehiclePickupStraightLineDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "vehicle_dropoff_eta" field.</summary>
    public const int VehicleDropoffEtaFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp vehicleDropoffEta_;
    /// <summary>
    /// The complete vehicle's driving ETA to the drop off point
    /// specified in the request. The ETA includes any required visits for active
    /// trips that must be completed before the vehicle visits the dropoff_point
    /// specified in the request. The value will only be populated when a
    /// dropoff_point is specified in the request. An empty value indicates
    /// a failure in calculating the ETA for the vehicle to reach
    /// the dropoff_point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp VehicleDropoffEta {
      get { return vehicleDropoffEta_; }
      set {
        vehicleDropoffEta_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_pickup_to_dropoff_distance_meters" field.</summary>
    public const int VehiclePickupToDropoffDistanceMetersFieldNumber = 5;
    private static readonly pb::FieldCodec<int?> _single_vehiclePickupToDropoffDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(42);
    private int? vehiclePickupToDropoffDistanceMeters_;
    /// <summary>
    /// The vehicle's driving distance (in meters) from the pickup point
    /// to the drop off point specified in the request. The distance is only
    /// between the two points and does not include the vehicle location or any
    /// other points that must be visited before the vehicle visits either the
    /// pickup point or dropoff point. The value will only be populated when a
    /// dropoff_point is specified in the request. An empty value indicates
    /// a failure in calculating the distance from the pickup to
    /// dropoff points specified in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int? VehiclePickupToDropoffDistanceMeters {
      get { return vehiclePickupToDropoffDistanceMeters_; }
      set {
        vehiclePickupToDropoffDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "trip_type" field.</summary>
    public const int TripTypeFieldNumber = 6;
    private global::Maps.Fleetengine.V1.TripType tripType_ = global::Maps.Fleetengine.V1.TripType.UnknownTripType;
    /// <summary>
    /// Required. The trip type of the request that was used to calculate the ETA
    /// to the pickup point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TripType TripType {
      get { return tripType_; }
      set {
        tripType_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_trips_waypoints" field.</summary>
    public const int VehicleTripsWaypointsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.Waypoint> _repeated_vehicleTripsWaypoints_codec
        = pb::FieldCodec.ForMessage(58, global::Maps.Fleetengine.V1.Waypoint.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.Waypoint> vehicleTripsWaypoints_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.Waypoint>();
    /// <summary>
    /// The ordered list of waypoints used to calculate the ETA. The list
    /// will include the vehicle location, the pickup/drop off points of active
    /// trips for the vehicle and the pickup/dropoff points provided in the
    /// request. An empty list indicates a failure in calculating ETA for the
    /// vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.Waypoint> VehicleTripsWaypoints {
      get { return vehicleTripsWaypoints_; }
    }

    /// <summary>Field number for the "vehicle_match_type" field.</summary>
    public const int VehicleMatchTypeFieldNumber = 8;
    private global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType vehicleMatchType_ = global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType.Unknown;
    /// <summary>
    /// Type of the vehicle match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType VehicleMatchType {
      get { return vehicleMatchType_; }
      set {
        vehicleMatchType_ = value;
      }
    }

    /// <summary>Field number for the "requested_ordered_by" field.</summary>
    public const int RequestedOrderedByFieldNumber = 9;
    private global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder requestedOrderedBy_ = global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder;
    /// <summary>
    /// The method the caller requested for sorting vehicle matches.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder RequestedOrderedBy {
      get { return requestedOrderedBy_; }
      set {
        requestedOrderedBy_ = value;
      }
    }

    /// <summary>Field number for the "ordered_by" field.</summary>
    public const int OrderedByFieldNumber = 10;
    private global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder orderedBy_ = global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder;
    /// <summary>
    /// The actual method that is used to order this vehicle. In normal cases this
    /// will match the 'order_by' field from the request, however in certain
    /// circumstances such as a failure of google maps backends, a different method
    /// may be used (such as PICKUP_POINT_STRAIGHT_DISTANCE).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder OrderedBy {
      get { return orderedBy_; }
      set {
        orderedBy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VehicleMatch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VehicleMatch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(VehiclePickupEta, other.VehiclePickupEta)) return false;
      if (VehiclePickupDistanceMeters != other.VehiclePickupDistanceMeters) return false;
      if (VehiclePickupStraightLineDistanceMeters != other.VehiclePickupStraightLineDistanceMeters) return false;
      if (!object.Equals(VehicleDropoffEta, other.VehicleDropoffEta)) return false;
      if (VehiclePickupToDropoffDistanceMeters != other.VehiclePickupToDropoffDistanceMeters) return false;
      if (TripType != other.TripType) return false;
      if(!vehicleTripsWaypoints_.Equals(other.vehicleTripsWaypoints_)) return false;
      if (VehicleMatchType != other.VehicleMatchType) return false;
      if (RequestedOrderedBy != other.RequestedOrderedBy) return false;
      if (OrderedBy != other.OrderedBy) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (vehiclePickupEta_ != null) hash ^= VehiclePickupEta.GetHashCode();
      if (vehiclePickupDistanceMeters_ != null) hash ^= VehiclePickupDistanceMeters.GetHashCode();
      if (vehiclePickupStraightLineDistanceMeters_ != null) hash ^= VehiclePickupStraightLineDistanceMeters.GetHashCode();
      if (vehicleDropoffEta_ != null) hash ^= VehicleDropoffEta.GetHashCode();
      if (vehiclePickupToDropoffDistanceMeters_ != null) hash ^= VehiclePickupToDropoffDistanceMeters.GetHashCode();
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) hash ^= TripType.GetHashCode();
      hash ^= vehicleTripsWaypoints_.GetHashCode();
      if (VehicleMatchType != global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) hash ^= VehicleMatchType.GetHashCode();
      if (RequestedOrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) hash ^= RequestedOrderedBy.GetHashCode();
      if (OrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) hash ^= OrderedBy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (vehicle_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Vehicle);
      }
      if (vehiclePickupEta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(VehiclePickupEta);
      }
      if (vehiclePickupDistanceMeters_ != null) {
        _single_vehiclePickupDistanceMeters_codec.WriteTagAndValue(output, VehiclePickupDistanceMeters);
      }
      if (vehicleDropoffEta_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(VehicleDropoffEta);
      }
      if (vehiclePickupToDropoffDistanceMeters_ != null) {
        _single_vehiclePickupToDropoffDistanceMeters_codec.WriteTagAndValue(output, VehiclePickupToDropoffDistanceMeters);
      }
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) TripType);
      }
      vehicleTripsWaypoints_.WriteTo(output, _repeated_vehicleTripsWaypoints_codec);
      if (VehicleMatchType != global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        output.WriteRawTag(64);
        output.WriteEnum((int) VehicleMatchType);
      }
      if (RequestedOrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(72);
        output.WriteEnum((int) RequestedOrderedBy);
      }
      if (OrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(80);
        output.WriteEnum((int) OrderedBy);
      }
      if (vehiclePickupStraightLineDistanceMeters_ != null) {
        _single_vehiclePickupStraightLineDistanceMeters_codec.WriteTagAndValue(output, VehiclePickupStraightLineDistanceMeters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (vehicle_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Vehicle);
      }
      if (vehiclePickupEta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(VehiclePickupEta);
      }
      if (vehiclePickupDistanceMeters_ != null) {
        _single_vehiclePickupDistanceMeters_codec.WriteTagAndValue(ref output, VehiclePickupDistanceMeters);
      }
      if (vehicleDropoffEta_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(VehicleDropoffEta);
      }
      if (vehiclePickupToDropoffDistanceMeters_ != null) {
        _single_vehiclePickupToDropoffDistanceMeters_codec.WriteTagAndValue(ref output, VehiclePickupToDropoffDistanceMeters);
      }
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) TripType);
      }
      vehicleTripsWaypoints_.WriteTo(ref output, _repeated_vehicleTripsWaypoints_codec);
      if (VehicleMatchType != global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        output.WriteRawTag(64);
        output.WriteEnum((int) VehicleMatchType);
      }
      if (RequestedOrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(72);
        output.WriteEnum((int) RequestedOrderedBy);
      }
      if (OrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(80);
        output.WriteEnum((int) OrderedBy);
      }
      if (vehiclePickupStraightLineDistanceMeters_ != null) {
        _single_vehiclePickupStraightLineDistanceMeters_codec.WriteTagAndValue(ref output, VehiclePickupStraightLineDistanceMeters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (vehiclePickupEta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehiclePickupEta);
      }
      if (vehiclePickupDistanceMeters_ != null) {
        size += _single_vehiclePickupDistanceMeters_codec.CalculateSizeWithTag(VehiclePickupDistanceMeters);
      }
      if (vehiclePickupStraightLineDistanceMeters_ != null) {
        size += _single_vehiclePickupStraightLineDistanceMeters_codec.CalculateSizeWithTag(VehiclePickupStraightLineDistanceMeters);
      }
      if (vehicleDropoffEta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleDropoffEta);
      }
      if (vehiclePickupToDropoffDistanceMeters_ != null) {
        size += _single_vehiclePickupToDropoffDistanceMeters_codec.CalculateSizeWithTag(VehiclePickupToDropoffDistanceMeters);
      }
      if (TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TripType);
      }
      size += vehicleTripsWaypoints_.CalculateSize(_repeated_vehicleTripsWaypoints_codec);
      if (VehicleMatchType != global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) VehicleMatchType);
      }
      if (RequestedOrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RequestedOrderedBy);
      }
      if (OrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OrderedBy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VehicleMatch other) {
      if (other == null) {
        return;
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.vehiclePickupEta_ != null) {
        if (vehiclePickupEta_ == null) {
          VehiclePickupEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        VehiclePickupEta.MergeFrom(other.VehiclePickupEta);
      }
      if (other.vehiclePickupDistanceMeters_ != null) {
        if (vehiclePickupDistanceMeters_ == null || other.VehiclePickupDistanceMeters != 0) {
          VehiclePickupDistanceMeters = other.VehiclePickupDistanceMeters;
        }
      }
      if (other.vehiclePickupStraightLineDistanceMeters_ != null) {
        if (vehiclePickupStraightLineDistanceMeters_ == null || other.VehiclePickupStraightLineDistanceMeters != 0) {
          VehiclePickupStraightLineDistanceMeters = other.VehiclePickupStraightLineDistanceMeters;
        }
      }
      if (other.vehicleDropoffEta_ != null) {
        if (vehicleDropoffEta_ == null) {
          VehicleDropoffEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        VehicleDropoffEta.MergeFrom(other.VehicleDropoffEta);
      }
      if (other.vehiclePickupToDropoffDistanceMeters_ != null) {
        if (vehiclePickupToDropoffDistanceMeters_ == null || other.VehiclePickupToDropoffDistanceMeters != 0) {
          VehiclePickupToDropoffDistanceMeters = other.VehiclePickupToDropoffDistanceMeters;
        }
      }
      if (other.TripType != global::Maps.Fleetengine.V1.TripType.UnknownTripType) {
        TripType = other.TripType;
      }
      vehicleTripsWaypoints_.Add(other.vehicleTripsWaypoints_);
      if (other.VehicleMatchType != global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        VehicleMatchType = other.VehicleMatchType;
      }
      if (other.RequestedOrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        RequestedOrderedBy = other.RequestedOrderedBy;
      }
      if (other.OrderedBy != global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        OrderedBy = other.OrderedBy;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (vehicle_ == null) {
              Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 18: {
            if (vehiclePickupEta_ == null) {
              VehiclePickupEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehiclePickupEta);
            break;
          }
          case 26: {
            int? value = _single_vehiclePickupDistanceMeters_codec.Read(input);
            if (vehiclePickupDistanceMeters_ == null || value != 0) {
              VehiclePickupDistanceMeters = value;
            }
            break;
          }
          case 34: {
            if (vehicleDropoffEta_ == null) {
              VehicleDropoffEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleDropoffEta);
            break;
          }
          case 42: {
            int? value = _single_vehiclePickupToDropoffDistanceMeters_codec.Read(input);
            if (vehiclePickupToDropoffDistanceMeters_ == null || value != 0) {
              VehiclePickupToDropoffDistanceMeters = value;
            }
            break;
          }
          case 48: {
            TripType = (global::Maps.Fleetengine.V1.TripType) input.ReadEnum();
            break;
          }
          case 58: {
            vehicleTripsWaypoints_.AddEntriesFrom(input, _repeated_vehicleTripsWaypoints_codec);
            break;
          }
          case 64: {
            VehicleMatchType = (global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType) input.ReadEnum();
            break;
          }
          case 72: {
            RequestedOrderedBy = (global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 80: {
            OrderedBy = (global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 90: {
            int? value = _single_vehiclePickupStraightLineDistanceMeters_codec.Read(input);
            if (vehiclePickupStraightLineDistanceMeters_ == null || value != 0) {
              VehiclePickupStraightLineDistanceMeters = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (vehicle_ == null) {
              Vehicle = new global::Maps.Fleetengine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 18: {
            if (vehiclePickupEta_ == null) {
              VehiclePickupEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehiclePickupEta);
            break;
          }
          case 26: {
            int? value = _single_vehiclePickupDistanceMeters_codec.Read(ref input);
            if (vehiclePickupDistanceMeters_ == null || value != 0) {
              VehiclePickupDistanceMeters = value;
            }
            break;
          }
          case 34: {
            if (vehicleDropoffEta_ == null) {
              VehicleDropoffEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleDropoffEta);
            break;
          }
          case 42: {
            int? value = _single_vehiclePickupToDropoffDistanceMeters_codec.Read(ref input);
            if (vehiclePickupToDropoffDistanceMeters_ == null || value != 0) {
              VehiclePickupToDropoffDistanceMeters = value;
            }
            break;
          }
          case 48: {
            TripType = (global::Maps.Fleetengine.V1.TripType) input.ReadEnum();
            break;
          }
          case 58: {
            vehicleTripsWaypoints_.AddEntriesFrom(ref input, _repeated_vehicleTripsWaypoints_codec);
            break;
          }
          case 64: {
            VehicleMatchType = (global::Maps.Fleetengine.V1.VehicleMatch.Types.VehicleMatchType) input.ReadEnum();
            break;
          }
          case 72: {
            RequestedOrderedBy = (global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 80: {
            OrderedBy = (global::Maps.Fleetengine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 90: {
            int? value = _single_vehiclePickupStraightLineDistanceMeters_codec.Read(ref input);
            if (vehiclePickupStraightLineDistanceMeters_ == null || value != 0) {
              VehiclePickupStraightLineDistanceMeters = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the VehicleMatch message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Type of vehicle match.
      /// </summary>
      public enum VehicleMatchType {
        /// <summary>
        /// Unknown vehicle match type
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Exclusive vehicle trip match
        /// </summary>
        [pbr::OriginalName("EXCLUSIVE")] Exclusive = 1,
        /// <summary>
        /// Back to back ride match.
        /// </summary>
        [pbr::OriginalName("BACK_TO_BACK")] BackToBack = 2,
        /// <summary>
        /// Carpool ride match.
        /// </summary>
        [pbr::OriginalName("CARPOOL")] Carpool = 3,
        /// <summary>
        /// Carpool ride match. The car has an active exclusive trip.
        /// </summary>
        [pbr::OriginalName("CARPOOL_BACK_TO_BACK")] CarpoolBackToBack = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// This messages allows a list-of-list datatype for VehicleAttribute.
  /// </summary>
  public sealed partial class VehicleAttributeList : pb::IMessage<VehicleAttributeList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehicleAttributeList> _parser = new pb::MessageParser<VehicleAttributeList>(() => new VehicleAttributeList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VehicleAttributeList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.VehicleApiReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleAttributeList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleAttributeList(VehicleAttributeList other) : this() {
      attributes_ = other.attributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleAttributeList Clone() {
      return new VehicleAttributeList(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(10, global::Maps.Fleetengine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute>();
    /// <summary>
    /// A list of attributes in this collection.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VehicleAttributeList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VehicleAttributeList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VehicleAttributeList other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
