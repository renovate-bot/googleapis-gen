// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/fleetengine/v1/trip_api.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Maps.Fleetengine.V1 {

  /// <summary>Holder for reflection information generated from google/maps/fleetengine/v1/trip_api.proto</summary>
  public static partial class TripApiReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/fleetengine/v1/trip_api.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TripApiReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cilnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS90cmlwX2FwaS5wcm90bxIT",
            "bWFwcy5mbGVldGVuZ2luZS52MRocZ29vZ2xlL2FwaS9hbm5vdGF0aW9ucy5w",
            "cm90bxofZ29vZ2xlL2FwaS9maWVsZF9iZWhhdmlvci5wcm90bxoZZ29vZ2xl",
            "L2FwaS9yZXNvdXJjZS5wcm90bxosZ29vZ2xlL21hcHMvZmxlZXRlbmdpbmUv",
            "djEvZmxlZXRlbmdpbmUucHJvdG8aJ2dvb2dsZS9tYXBzL2ZsZWV0ZW5naW5l",
            "L3YxL2hlYWRlci5wcm90bxomZ29vZ2xlL21hcHMvZmxlZXRlbmdpbmUvdjEv",
            "dHJpcHMucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxob",
            "Z29vZ2xlL3Byb3RvYnVmL2VtcHR5LnByb3RvGiBnb29nbGUvcHJvdG9idWYv",
            "ZmllbGRfbWFzay5wcm90bxofZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5w",
            "cm90bxoXZ29vZ2xlL2FwaS9jbGllbnQucHJvdG8ixAEKEUNyZWF0ZVRyaXBS",
            "ZXF1ZXN0EjIKBmhlYWRlchgBIAEoCzIiLm1hcHMuZmxlZXRlbmdpbmUudjEu",
            "UmVxdWVzdEhlYWRlchI3CgZwYXJlbnQYAyABKAlCJ+BBAvpBIQofZmxlZXRl",
            "bmdpbmUuZ29vZ2xlYXBpcy5jb20vVHJpcBIUCgd0cmlwX2lkGAUgASgJQgPg",
            "QQISLAoEdHJpcBgEIAEoCzIZLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcEID",
            "4EECIvACCg5HZXRUcmlwUmVxdWVzdBIyCgZoZWFkZXIYASABKAsyIi5tYXBz",
            "LmZsZWV0ZW5naW5lLnYxLlJlcXVlc3RIZWFkZXISNQoEbmFtZRgDIAEoCUIn",
            "4EEC+kEhCh9mbGVldGVuZ2luZS5nb29nbGVhcGlzLmNvbS9UcmlwEisKBHZp",
            "ZXcYCyABKA4yHS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBWaWV3EkEKHWN1",
            "cnJlbnRfcm91dGVfc2VnbWVudF92ZXJzaW9uGAYgASgLMhouZ29vZ2xlLnBy",
            "b3RvYnVmLlRpbWVzdGFtcBI/ChtyZW1haW5pbmdfd2F5cG9pbnRzX3ZlcnNp",
            "b24YByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEkIKEXJvdXRl",
            "X2Zvcm1hdF90eXBlGAggASgOMicubWFwcy5mbGVldGVuZ2luZS52MS5Qb2x5",
            "bGluZUZvcm1hdFR5cGUizQIKGVJlcG9ydEJpbGxhYmxlVHJpcFJlcXVlc3QS",
            "EQoEbmFtZRgCIAEoCUID4EECEhkKDGNvdW50cnlfY29kZRgDIAEoCUID4EEC",
            "EkAKCHBsYXRmb3JtGAUgASgOMi4ubWFwcy5mbGVldGVuZ2luZS52MS5CaWxs",
            "aW5nUGxhdGZvcm1JZGVudGlmaWVyEhMKC3JlbGF0ZWRfaWRzGAYgAygJElIK",
            "DXNvbHV0aW9uX3R5cGUYByABKA4yOy5tYXBzLmZsZWV0ZW5naW5lLnYxLlJl",
            "cG9ydEJpbGxhYmxlVHJpcFJlcXVlc3QuU29sdXRpb25UeXBlIlcKDFNvbHV0",
            "aW9uVHlwZRIdChlTT0xVVElPTl9UWVBFX1VOU1BFQ0lGSUVEEAASKAokT05f",
            "REVNQU5EX1JJREVTSEFSSU5HX0FORF9ERUxJVkVSSUVTEAEivgEKEVVwZGF0",
            "ZVRyaXBSZXF1ZXN0EjIKBmhlYWRlchgBIAEoCzIiLm1hcHMuZmxlZXRlbmdp",
            "bmUudjEuUmVxdWVzdEhlYWRlchIRCgRuYW1lGAMgASgJQgPgQQISLAoEdHJp",
            "cBgEIAEoCzIZLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcEID4EECEjQKC3Vw",
            "ZGF0ZV9tYXNrGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFza0ID",
            "4EECIukBChJTZWFyY2hUcmlwc1JlcXVlc3QSMgoGaGVhZGVyGAEgASgLMiIu",
            "bWFwcy5mbGVldGVuZ2luZS52MS5SZXF1ZXN0SGVhZGVyEhMKBnBhcmVudBgD",
            "IAEoCUID4EECEhIKCnZlaGljbGVfaWQYBCABKAkSGQoRYWN0aXZlX3RyaXBz",
            "X29ubHkYBSABKAgSEQoJcGFnZV9zaXplGAYgASgFEhIKCnBhZ2VfdG9rZW4Y",
            "ByABKAkSNAoRbWluaW11bV9zdGFsZW5lc3MYCCABKAsyGS5nb29nbGUucHJv",
            "dG9idWYuRHVyYXRpb24iWAoTU2VhcmNoVHJpcHNSZXNwb25zZRIoCgV0cmlw",
            "cxgBIAMoCzIZLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcBIXCg9uZXh0X3Bh",
            "Z2VfdG9rZW4YAiABKAkyywUKC1RyaXBTZXJ2aWNlEn0KCkNyZWF0ZVRyaXAS",
            "Ji5tYXBzLmZsZWV0ZW5naW5lLnYxLkNyZWF0ZVRyaXBSZXF1ZXN0GhkubWFw",
            "cy5mbGVldGVuZ2luZS52MS5UcmlwIiyC0+STAiYiHi92MS97cGFyZW50PXBy",
            "b3ZpZGVycy8qfS90cmlwczoEdHJpcBJxCgdHZXRUcmlwEiMubWFwcy5mbGVl",
            "dGVuZ2luZS52MS5HZXRUcmlwUmVxdWVzdBoZLm1hcHMuZmxlZXRlbmdpbmUu",
            "djEuVHJpcCImgtPkkwIgEh4vdjEve25hbWU9cHJvdmlkZXJzLyovdHJpcHMv",
            "Kn0SlgEKElJlcG9ydEJpbGxhYmxlVHJpcBIuLm1hcHMuZmxlZXRlbmdpbmUu",
            "djEuUmVwb3J0QmlsbGFibGVUcmlwUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1",
            "Zi5FbXB0eSI4gtPkkwIyIi0vdjEve25hbWU9cHJvdmlkZXJzLyovYmlsbGFi",
            "bGVUcmlwcy8qfTpyZXBvcnQ6ASoSkgEKC1NlYXJjaFRyaXBzEicubWFwcy5m",
            "bGVldGVuZ2luZS52MS5TZWFyY2hUcmlwc1JlcXVlc3QaKC5tYXBzLmZsZWV0",
            "ZW5naW5lLnYxLlNlYXJjaFRyaXBzUmVzcG9uc2UiMILT5JMCKiIlL3YxL3tw",
            "YXJlbnQ9cHJvdmlkZXJzLyp9L3RyaXBzOnNlYXJjaDoBKhJ9CgpVcGRhdGVU",
            "cmlwEiYubWFwcy5mbGVldGVuZ2luZS52MS5VcGRhdGVUcmlwUmVxdWVzdBoZ",
            "Lm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcCIsgtPkkwImGh4vdjEve25hbWU9",
            "cHJvdmlkZXJzLyovdHJpcHMvKn06BHRyaXAaHcpBGmZsZWV0ZW5naW5lLmdv",
            "b2dsZWFwaXMuY29tQnQKGmdvb2dsZS5tYXBzLmZsZWV0ZW5naW5lLnYxQgdU",
            "cmlwQXBpUAFaRWdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFw",
            "aXMvbWFwcy9mbGVldGVuZ2luZS92MTtmbGVldGVuZ2luZaICA0NGRWIGcHJv",
            "dG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Maps.Fleetengine.V1.FleetengineReflection.Descriptor, global::Maps.Fleetengine.V1.HeaderReflection.Descriptor, global::Maps.Fleetengine.V1.TripsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.EmptyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.FieldMaskReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.CreateTripRequest), global::Maps.Fleetengine.V1.CreateTripRequest.Parser, new[]{ "Header", "Parent", "TripId", "Trip" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.GetTripRequest), global::Maps.Fleetengine.V1.GetTripRequest.Parser, new[]{ "Header", "Name", "View", "CurrentRouteSegmentVersion", "RemainingWaypointsVersion", "RouteFormatType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.ReportBillableTripRequest), global::Maps.Fleetengine.V1.ReportBillableTripRequest.Parser, new[]{ "Name", "CountryCode", "Platform", "RelatedIds", "SolutionType" }, null, new[]{ typeof(global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.UpdateTripRequest), global::Maps.Fleetengine.V1.UpdateTripRequest.Parser, new[]{ "Header", "Name", "Trip", "UpdateMask" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.SearchTripsRequest), global::Maps.Fleetengine.V1.SearchTripsRequest.Parser, new[]{ "Header", "Parent", "VehicleId", "ActiveTripsOnly", "PageSize", "PageToken", "MinimumStaleness" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Maps.Fleetengine.V1.SearchTripsResponse), global::Maps.Fleetengine.V1.SearchTripsResponse.Parser, new[]{ "Trips", "NextPageToken" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// CreateTrip request message.
  /// </summary>
  public sealed partial class CreateTripRequest : pb::IMessage<CreateTripRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CreateTripRequest> _parser = new pb::MessageParser<CreateTripRequest>(() => new CreateTripRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreateTripRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripApiReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateTripRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateTripRequest(CreateTripRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      tripId_ = other.tripId_;
      trip_ = other.trip_ != null ? other.trip_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateTripRequest Clone() {
      return new CreateTripRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 3;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format "providers/{provider}".
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 5;
    private string tripId_ = "";
    /// <summary>
    /// Required. Unique Trip ID; must be unique per provider.  The actual
    /// format and value is opaque to the Fleet Engine and is determined
    /// by the provider.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 4;
    private global::Maps.Fleetengine.V1.Trip trip_;
    /// <summary>
    /// Required. Trip entity to create.
    ///
    /// When creating a Trip, the following fields are required:
    ///
    /// * trip_type
    /// * pickup_point
    ///
    /// The following fields are used if you provide them:
    ///
    /// * number_of_passengers
    /// * vehicle_id
    /// * dropoff_point
    /// * intermediate_destinations
    ///
    /// Only EXCLUSIVE trips support multiple destinations.
    ///
    /// When vehicle_id is set for a shared trip, you must supply
    /// the list of `Trip.vehicle_waypoints` to specify the order of the remaining
    /// waypoints for the vehicle, otherwise the waypoint order will be
    /// undetermined.
    ///
    /// When you specify `Trip.vehicle_waypoints`, the list must contain all
    /// the remaining waypoints of the vehicle's trips, with no extra waypoints.
    /// You must order these waypoints such that for a given trip, the pickup
    /// point is before intermediate destinations, and all intermediate
    /// destinations come before the drop-off point. An `EXCLUSIVE` trip's
    /// waypoints must not interleave with any other trips.
    ///
    /// The `trip_id`, `waypoint_type` and `location` fields are used, and all
    /// other TripWaypoint fields in vehicle_waypoints are ignored.
    ///
    /// All other Trip fields are ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.Trip Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreateTripRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreateTripRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (TripId != other.TripId) return false;
      if (!object.Equals(Trip, other.Trip)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Trip);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(TripId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Trip);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(TripId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (TripId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreateTripRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          Trip = new global::Maps.Fleetengine.V1.Trip();
        }
        Trip.MergeFrom(other.Trip);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            if (trip_ == null) {
              Trip = new global::Maps.Fleetengine.V1.Trip();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 42: {
            TripId = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            if (trip_ == null) {
              Trip = new global::Maps.Fleetengine.V1.Trip();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 42: {
            TripId = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// GetTrip request message.
  /// </summary>
  public sealed partial class GetTripRequest : pb::IMessage<GetTripRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetTripRequest> _parser = new pb::MessageParser<GetTripRequest>(() => new GetTripRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetTripRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripApiReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetTripRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetTripRequest(GetTripRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      view_ = other.view_;
      currentRouteSegmentVersion_ = other.currentRouteSegmentVersion_ != null ? other.currentRouteSegmentVersion_.Clone() : null;
      remainingWaypointsVersion_ = other.remainingWaypointsVersion_ != null ? other.remainingWaypointsVersion_.Clone() : null;
      routeFormatType_ = other.routeFormatType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetTripRequest Clone() {
      return new GetTripRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format "providers/{provider}/trips/{trip}".
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "view" field.</summary>
    public const int ViewFieldNumber = 11;
    private global::Maps.Fleetengine.V1.TripView view_ = global::Maps.Fleetengine.V1.TripView.Unspecified;
    /// <summary>
    /// The subset of Trip fields that should be returned and their interpretation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.TripView View {
      get { return view_; }
      set {
        view_ = value;
      }
    }

    /// <summary>Field number for the "current_route_segment_version" field.</summary>
    public const int CurrentRouteSegmentVersionFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Timestamp currentRouteSegmentVersion_;
    /// <summary>
    /// Indicates the minimum timestamp (exclusive) for which Trip.route or
    /// Trip.current_route_segment data is retrieved. If route data is unchanged
    /// since this timestamp, the route field is not set in the response. If a
    /// minimum is unspecified, the route data is always retrieved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CurrentRouteSegmentVersion {
      get { return currentRouteSegmentVersion_; }
      set {
        currentRouteSegmentVersion_ = value;
      }
    }

    /// <summary>Field number for the "remaining_waypoints_version" field.</summary>
    public const int RemainingWaypointsVersionFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Timestamp remainingWaypointsVersion_;
    /// <summary>
    /// Indicates the minimum timestamp (exclusive) for which
    /// Trip.remaining_waypoints are retrieved. If they are unchanged since this
    /// timestamp, the remaining_waypoints are not set in the response. If this
    /// field is unspecified, remaining_waypoints is always retrieved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp RemainingWaypointsVersion {
      get { return remainingWaypointsVersion_; }
      set {
        remainingWaypointsVersion_ = value;
      }
    }

    /// <summary>Field number for the "route_format_type" field.</summary>
    public const int RouteFormatTypeFieldNumber = 8;
    private global::Maps.Fleetengine.V1.PolylineFormatType routeFormatType_ = global::Maps.Fleetengine.V1.PolylineFormatType.UnknownFormatType;
    /// <summary>
    /// The returned current route format, LAT_LNG_LIST_TYPE (in Trip.route), or
    /// ENCODED_POLYLINE_TYPE (in Trip.current_route_segment).
    /// The default is LAT_LNG_LIST_TYPE.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.PolylineFormatType RouteFormatType {
      get { return routeFormatType_; }
      set {
        routeFormatType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetTripRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetTripRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if (View != other.View) return false;
      if (!object.Equals(CurrentRouteSegmentVersion, other.CurrentRouteSegmentVersion)) return false;
      if (!object.Equals(RemainingWaypointsVersion, other.RemainingWaypointsVersion)) return false;
      if (RouteFormatType != other.RouteFormatType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) hash ^= View.GetHashCode();
      if (currentRouteSegmentVersion_ != null) hash ^= CurrentRouteSegmentVersion.GetHashCode();
      if (remainingWaypointsVersion_ != null) hash ^= RemainingWaypointsVersion.GetHashCode();
      if (RouteFormatType != global::Maps.Fleetengine.V1.PolylineFormatType.UnknownFormatType) hash ^= RouteFormatType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (remainingWaypointsVersion_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(RemainingWaypointsVersion);
      }
      if (RouteFormatType != global::Maps.Fleetengine.V1.PolylineFormatType.UnknownFormatType) {
        output.WriteRawTag(64);
        output.WriteEnum((int) RouteFormatType);
      }
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        output.WriteRawTag(88);
        output.WriteEnum((int) View);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (remainingWaypointsVersion_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(RemainingWaypointsVersion);
      }
      if (RouteFormatType != global::Maps.Fleetengine.V1.PolylineFormatType.UnknownFormatType) {
        output.WriteRawTag(64);
        output.WriteEnum((int) RouteFormatType);
      }
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        output.WriteRawTag(88);
        output.WriteEnum((int) View);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) View);
      }
      if (currentRouteSegmentVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentVersion);
      }
      if (remainingWaypointsVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemainingWaypointsVersion);
      }
      if (RouteFormatType != global::Maps.Fleetengine.V1.PolylineFormatType.UnknownFormatType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RouteFormatType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetTripRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.View != global::Maps.Fleetengine.V1.TripView.Unspecified) {
        View = other.View;
      }
      if (other.currentRouteSegmentVersion_ != null) {
        if (currentRouteSegmentVersion_ == null) {
          CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CurrentRouteSegmentVersion.MergeFrom(other.CurrentRouteSegmentVersion);
      }
      if (other.remainingWaypointsVersion_ != null) {
        if (remainingWaypointsVersion_ == null) {
          RemainingWaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        RemainingWaypointsVersion.MergeFrom(other.RemainingWaypointsVersion);
      }
      if (other.RouteFormatType != global::Maps.Fleetengine.V1.PolylineFormatType.UnknownFormatType) {
        RouteFormatType = other.RouteFormatType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 50: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 58: {
            if (remainingWaypointsVersion_ == null) {
              RemainingWaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RemainingWaypointsVersion);
            break;
          }
          case 64: {
            RouteFormatType = (global::Maps.Fleetengine.V1.PolylineFormatType) input.ReadEnum();
            break;
          }
          case 88: {
            View = (global::Maps.Fleetengine.V1.TripView) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 50: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 58: {
            if (remainingWaypointsVersion_ == null) {
              RemainingWaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(RemainingWaypointsVersion);
            break;
          }
          case 64: {
            RouteFormatType = (global::Maps.Fleetengine.V1.PolylineFormatType) input.ReadEnum();
            break;
          }
          case 88: {
            View = (global::Maps.Fleetengine.V1.TripView) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ReportBillableTrip request message.
  /// </summary>
  public sealed partial class ReportBillableTripRequest : pb::IMessage<ReportBillableTripRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReportBillableTripRequest> _parser = new pb::MessageParser<ReportBillableTripRequest>(() => new ReportBillableTripRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReportBillableTripRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripApiReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReportBillableTripRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReportBillableTripRequest(ReportBillableTripRequest other) : this() {
      name_ = other.name_;
      countryCode_ = other.countryCode_;
      platform_ = other.platform_;
      relatedIds_ = other.relatedIds_.Clone();
      solutionType_ = other.solutionType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReportBillableTripRequest Clone() {
      return new ReportBillableTripRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// "providers/{provider}/billableTrips/{billable_trip}". The
    /// provider must be the Project ID (for example, sample-cloud-project) of the
    /// Google Cloud Project of which the service account making this call is a
    /// member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "country_code" field.</summary>
    public const int CountryCodeFieldNumber = 3;
    private string countryCode_ = "";
    /// <summary>
    /// Required. Two letter country code of the country where the trip takes place. Price is
    /// defined according to country code.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CountryCode {
      get { return countryCode_; }
      set {
        countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "platform" field.</summary>
    public const int PlatformFieldNumber = 5;
    private global::Maps.Fleetengine.V1.BillingPlatformIdentifier platform_ = global::Maps.Fleetengine.V1.BillingPlatformIdentifier.Unspecified;
    /// <summary>
    /// The platform upon which the request was issued.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.BillingPlatformIdentifier Platform {
      get { return platform_; }
      set {
        platform_ = value;
      }
    }

    /// <summary>Field number for the "related_ids" field.</summary>
    public const int RelatedIdsFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_relatedIds_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> relatedIds_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The identifiers that are directly related to the trip being reported. These
    /// are usually IDs (for example, session IDs) of pre-booking operations done
    /// before the trip ID is available. The number of related_ids is
    /// limited to 50.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> RelatedIds {
      get { return relatedIds_; }
    }

    /// <summary>Field number for the "solution_type" field.</summary>
    public const int SolutionTypeFieldNumber = 7;
    private global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType solutionType_ = global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType.Unspecified;
    /// <summary>
    /// The type of GMP product solution (for example,
    /// ON_DEMAND_RIDESHARING_AND_DELIVERIES) used for the reported trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType SolutionType {
      get { return solutionType_; }
      set {
        solutionType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReportBillableTripRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReportBillableTripRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (CountryCode != other.CountryCode) return false;
      if (Platform != other.Platform) return false;
      if(!relatedIds_.Equals(other.relatedIds_)) return false;
      if (SolutionType != other.SolutionType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (CountryCode.Length != 0) hash ^= CountryCode.GetHashCode();
      if (Platform != global::Maps.Fleetengine.V1.BillingPlatformIdentifier.Unspecified) hash ^= Platform.GetHashCode();
      hash ^= relatedIds_.GetHashCode();
      if (SolutionType != global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType.Unspecified) hash ^= SolutionType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (CountryCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(CountryCode);
      }
      if (Platform != global::Maps.Fleetengine.V1.BillingPlatformIdentifier.Unspecified) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Platform);
      }
      relatedIds_.WriteTo(output, _repeated_relatedIds_codec);
      if (SolutionType != global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType.Unspecified) {
        output.WriteRawTag(56);
        output.WriteEnum((int) SolutionType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (CountryCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(CountryCode);
      }
      if (Platform != global::Maps.Fleetengine.V1.BillingPlatformIdentifier.Unspecified) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Platform);
      }
      relatedIds_.WriteTo(ref output, _repeated_relatedIds_codec);
      if (SolutionType != global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType.Unspecified) {
        output.WriteRawTag(56);
        output.WriteEnum((int) SolutionType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (CountryCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryCode);
      }
      if (Platform != global::Maps.Fleetengine.V1.BillingPlatformIdentifier.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Platform);
      }
      size += relatedIds_.CalculateSize(_repeated_relatedIds_codec);
      if (SolutionType != global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SolutionType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReportBillableTripRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.CountryCode.Length != 0) {
        CountryCode = other.CountryCode;
      }
      if (other.Platform != global::Maps.Fleetengine.V1.BillingPlatformIdentifier.Unspecified) {
        Platform = other.Platform;
      }
      relatedIds_.Add(other.relatedIds_);
      if (other.SolutionType != global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType.Unspecified) {
        SolutionType = other.SolutionType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            CountryCode = input.ReadString();
            break;
          }
          case 40: {
            Platform = (global::Maps.Fleetengine.V1.BillingPlatformIdentifier) input.ReadEnum();
            break;
          }
          case 50: {
            relatedIds_.AddEntriesFrom(input, _repeated_relatedIds_codec);
            break;
          }
          case 56: {
            SolutionType = (global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            CountryCode = input.ReadString();
            break;
          }
          case 40: {
            Platform = (global::Maps.Fleetengine.V1.BillingPlatformIdentifier) input.ReadEnum();
            break;
          }
          case 50: {
            relatedIds_.AddEntriesFrom(ref input, _repeated_relatedIds_codec);
            break;
          }
          case 56: {
            SolutionType = (global::Maps.Fleetengine.V1.ReportBillableTripRequest.Types.SolutionType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ReportBillableTripRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Selector for different solution types of a reported trip.
      /// </summary>
      public enum SolutionType {
        /// <summary>
        /// The default value. For backwards-compatibility, the API will use
        /// ON_DEMAND_RIDESHARING_AND_DELIVERIES by default which is the first
        /// supported solution type.
        /// </summary>
        [pbr::OriginalName("SOLUTION_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// The solution is an on-demand ridesharing and deliveries trip.
        /// </summary>
        [pbr::OriginalName("ON_DEMAND_RIDESHARING_AND_DELIVERIES")] OnDemandRidesharingAndDeliveries = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// UpdateTrip request message.
  /// </summary>
  public sealed partial class UpdateTripRequest : pb::IMessage<UpdateTripRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateTripRequest> _parser = new pb::MessageParser<UpdateTripRequest>(() => new UpdateTripRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateTripRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripApiReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateTripRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateTripRequest(UpdateTripRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      trip_ = other.trip_ != null ? other.trip_.Clone() : null;
      updateMask_ = other.updateMask_ != null ? other.updateMask_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateTripRequest Clone() {
      return new UpdateTripRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// `providers/{provider}/trips/{trip}`. The provider must
    /// be the Project ID (for example, sample-consumer-project) of the Google
    /// Cloud Project of which the service account making this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 4;
    private global::Maps.Fleetengine.V1.Trip trip_;
    /// <summary>
    /// Required. The Trip associated with the update.
    ///
    /// The following fields are maintained by the Fleet Engine. Do not update
    /// them using Trip.update.
    ///
    /// * current_route_segment
    /// * current_route_segment_version
    /// * eta_to_next_waypoint
    /// * intermediate_destinations_version
    /// * last_location
    /// * name
    /// * number_of_passengers
    /// * remaining_distance_meters
    /// * remaining_time_to_first_waypoint
    /// * remaining_waypoints
    /// * remaining_waypoints_version
    ///
    /// When you update the `Trip.vehicle_id` for a shared trip, you must supply
    /// the list of `Trip.vehicle_waypoints` to specify the order of the remaining
    /// waypoints, otherwise the order will be undetermined.
    ///
    /// When you specify `Trip.vehicle_waypoints`, the list must contain all
    /// the remaining waypoints of the vehicle's trips, with no extra waypoints.
    /// You must order these waypoints such that for a given trip, the pickup
    /// point is before intermediate destinations, and all intermediate
    /// destinations come before the drop-off point. An `EXCLUSIVE` trip's
    /// waypoints must not interleave with any other trips.
    /// The `trip_id`, `waypoint_type` and `location` fields are used, and all
    /// other TripWaypoint fields in vehicle_waypoints are ignored.
    ///
    /// To avoid a race condition for trips with multiple destinations, you
    /// should provide `Trip.intermediate_destinations_version` when updating
    /// the trip status to `ENROUTE_TO_INTERMEDIATE_DESTINATION`. The
    /// `Trip.intermediate_destinations_version` passed must be consistent with
    /// Fleet Engine's version. If it isn't, the request fails.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.Trip Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    /// <summary>Field number for the "update_mask" field.</summary>
    public const int UpdateMaskFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.FieldMask updateMask_;
    /// <summary>
    /// Required. The field mask indicating which fields in Trip to update.
    /// The update_mask must contain at least one field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.FieldMask UpdateMask {
      get { return updateMask_; }
      set {
        updateMask_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateTripRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateTripRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if (!object.Equals(Trip, other.Trip)) return false;
      if (!object.Equals(UpdateMask, other.UpdateMask)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (updateMask_ != null) hash ^= UpdateMask.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Trip);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Trip);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (updateMask_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateMask);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateTripRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          Trip = new global::Maps.Fleetengine.V1.Trip();
        }
        Trip.MergeFrom(other.Trip);
      }
      if (other.updateMask_ != null) {
        if (updateMask_ == null) {
          UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
        }
        UpdateMask.MergeFrom(other.UpdateMask);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (trip_ == null) {
              Trip = new global::Maps.Fleetengine.V1.Trip();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 42: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (trip_ == null) {
              Trip = new global::Maps.Fleetengine.V1.Trip();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 42: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SearchTrips request message.
  /// </summary>
  public sealed partial class SearchTripsRequest : pb::IMessage<SearchTripsRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchTripsRequest> _parser = new pb::MessageParser<SearchTripsRequest>(() => new SearchTripsRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SearchTripsRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripApiReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchTripsRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchTripsRequest(SearchTripsRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      vehicleId_ = other.vehicleId_;
      activeTripsOnly_ = other.activeTripsOnly_;
      pageSize_ = other.pageSize_;
      pageToken_ = other.pageToken_;
      minimumStaleness_ = other.minimumStaleness_ != null ? other.minimumStaleness_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchTripsRequest Clone() {
      return new SearchTripsRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Maps.Fleetengine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Maps.Fleetengine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 3;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format "providers/*"
    /// The provider must be the Project ID (for example, sample-cloud-project)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle_id" field.</summary>
    public const int VehicleIdFieldNumber = 4;
    private string vehicleId_ = "";
    /// <summary>
    /// The vehicle associated with the trips in the request. If unspecified, the
    /// returned trips do not contain:
    ///
    /// * current_route_segment
    /// * remaining_waypoints
    /// * remaining_distance_meters
    /// * eta_to_first_waypoint
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VehicleId {
      get { return vehicleId_; }
      set {
        vehicleId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "active_trips_only" field.</summary>
    public const int ActiveTripsOnlyFieldNumber = 5;
    private bool activeTripsOnly_;
    /// <summary>
    /// If set to true, only Trips that influence the drivers route
    /// are included in the response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ActiveTripsOnly {
      get { return activeTripsOnly_; }
      set {
        activeTripsOnly_ = value;
      }
    }

    /// <summary>Field number for the "page_size" field.</summary>
    public const int PageSizeFieldNumber = 6;
    private int pageSize_;
    /// <summary>
    /// If not set, the server will decide the number of
    /// results to return.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PageSize {
      get { return pageSize_; }
      set {
        pageSize_ = value;
      }
    }

    /// <summary>Field number for the "page_token" field.</summary>
    public const int PageTokenFieldNumber = 7;
    private string pageToken_ = "";
    /// <summary>
    /// Set this to a value previously returned in the
    /// SearchTripsResponse to continue from previous results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PageToken {
      get { return pageToken_; }
      set {
        pageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "minimum_staleness" field.</summary>
    public const int MinimumStalenessFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration minimumStaleness_;
    /// <summary>
    /// If specified, returns the trips that have not been updated after
    /// the time (current - minimum_staleness).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MinimumStaleness {
      get { return minimumStaleness_; }
      set {
        minimumStaleness_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SearchTripsRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SearchTripsRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (VehicleId != other.VehicleId) return false;
      if (ActiveTripsOnly != other.ActiveTripsOnly) return false;
      if (PageSize != other.PageSize) return false;
      if (PageToken != other.PageToken) return false;
      if (!object.Equals(MinimumStaleness, other.MinimumStaleness)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (VehicleId.Length != 0) hash ^= VehicleId.GetHashCode();
      if (ActiveTripsOnly != false) hash ^= ActiveTripsOnly.GetHashCode();
      if (PageSize != 0) hash ^= PageSize.GetHashCode();
      if (PageToken.Length != 0) hash ^= PageToken.GetHashCode();
      if (minimumStaleness_ != null) hash ^= MinimumStaleness.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(VehicleId);
      }
      if (ActiveTripsOnly != false) {
        output.WriteRawTag(40);
        output.WriteBool(ActiveTripsOnly);
      }
      if (PageSize != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(PageToken);
      }
      if (minimumStaleness_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MinimumStaleness);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(VehicleId);
      }
      if (ActiveTripsOnly != false) {
        output.WriteRawTag(40);
        output.WriteBool(ActiveTripsOnly);
      }
      if (PageSize != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(PageToken);
      }
      if (minimumStaleness_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MinimumStaleness);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (VehicleId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VehicleId);
      }
      if (ActiveTripsOnly != false) {
        size += 1 + 1;
      }
      if (PageSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PageSize);
      }
      if (PageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PageToken);
      }
      if (minimumStaleness_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinimumStaleness);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SearchTripsRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Maps.Fleetengine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.VehicleId.Length != 0) {
        VehicleId = other.VehicleId;
      }
      if (other.ActiveTripsOnly != false) {
        ActiveTripsOnly = other.ActiveTripsOnly;
      }
      if (other.PageSize != 0) {
        PageSize = other.PageSize;
      }
      if (other.PageToken.Length != 0) {
        PageToken = other.PageToken;
      }
      if (other.minimumStaleness_ != null) {
        if (minimumStaleness_ == null) {
          MinimumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MinimumStaleness.MergeFrom(other.MinimumStaleness);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            VehicleId = input.ReadString();
            break;
          }
          case 40: {
            ActiveTripsOnly = input.ReadBool();
            break;
          }
          case 48: {
            PageSize = input.ReadInt32();
            break;
          }
          case 58: {
            PageToken = input.ReadString();
            break;
          }
          case 66: {
            if (minimumStaleness_ == null) {
              MinimumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MinimumStaleness);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Maps.Fleetengine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            VehicleId = input.ReadString();
            break;
          }
          case 40: {
            ActiveTripsOnly = input.ReadBool();
            break;
          }
          case 48: {
            PageSize = input.ReadInt32();
            break;
          }
          case 58: {
            PageToken = input.ReadString();
            break;
          }
          case 66: {
            if (minimumStaleness_ == null) {
              MinimumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MinimumStaleness);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SearchTrips response message.
  /// </summary>
  public sealed partial class SearchTripsResponse : pb::IMessage<SearchTripsResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchTripsResponse> _parser = new pb::MessageParser<SearchTripsResponse>(() => new SearchTripsResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SearchTripsResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Maps.Fleetengine.V1.TripApiReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchTripsResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchTripsResponse(SearchTripsResponse other) : this() {
      trips_ = other.trips_.Clone();
      nextPageToken_ = other.nextPageToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SearchTripsResponse Clone() {
      return new SearchTripsResponse(this);
    }

    /// <summary>Field number for the "trips" field.</summary>
    public const int TripsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Maps.Fleetengine.V1.Trip> _repeated_trips_codec
        = pb::FieldCodec.ForMessage(10, global::Maps.Fleetengine.V1.Trip.Parser);
    private readonly pbc::RepeatedField<global::Maps.Fleetengine.V1.Trip> trips_ = new pbc::RepeatedField<global::Maps.Fleetengine.V1.Trip>();
    /// <summary>
    /// The list of trips for the requested vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Maps.Fleetengine.V1.Trip> Trips {
      get { return trips_; }
    }

    /// <summary>Field number for the "next_page_token" field.</summary>
    public const int NextPageTokenFieldNumber = 2;
    private string nextPageToken_ = "";
    /// <summary>
    /// Pass this token in the SearchTripsRequest to continue to
    /// list results. If all results have been returned, this field is an empty
    /// string or not present in the response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NextPageToken {
      get { return nextPageToken_; }
      set {
        nextPageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SearchTripsResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SearchTripsResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!trips_.Equals(other.trips_)) return false;
      if (NextPageToken != other.NextPageToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= trips_.GetHashCode();
      if (NextPageToken.Length != 0) hash ^= NextPageToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      trips_.WriteTo(output, _repeated_trips_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      trips_.WriteTo(ref output, _repeated_trips_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += trips_.CalculateSize(_repeated_trips_codec);
      if (NextPageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NextPageToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SearchTripsResponse other) {
      if (other == null) {
        return;
      }
      trips_.Add(other.trips_);
      if (other.NextPageToken.Length != 0) {
        NextPageToken = other.NextPageToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            trips_.AddEntriesFrom(input, _repeated_trips_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            trips_.AddEntriesFrom(ref input, _repeated_trips_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
