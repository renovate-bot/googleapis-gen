// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/playablelocations/v3/playablelocations.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Maps.PlayableLocations.V3 {

  /// <summary>Holder for reflection information generated from google/maps/playablelocations/v3/playablelocations.proto</summary>
  public static partial class PlayablelocationsReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/playablelocations/v3/playablelocations.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PlayablelocationsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cjhnb29nbGUvbWFwcy9wbGF5YWJsZWxvY2F0aW9ucy92My9wbGF5YWJsZWxv",
            "Y2F0aW9ucy5wcm90bxIgZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMu",
            "djMaHGdvb2dsZS9hcGkvYW5ub3RhdGlvbnMucHJvdG8aH2dvb2dsZS9hcGkv",
            "ZmllbGRfYmVoYXZpb3IucHJvdG8aMGdvb2dsZS9tYXBzL3BsYXlhYmxlbG9j",
            "YXRpb25zL3YzL3Jlc291cmNlcy5wcm90bxo3Z29vZ2xlL21hcHMvcGxheWFi",
            "bGVsb2NhdGlvbnMvdjMvc2FtcGxlL3Jlc291cmNlcy5wcm90bxoiZ29vZ2xl",
            "L21hcHMvdW5pdHkvY2xpZW50aW5mby5wcm90bxoeZ29vZ2xlL3Byb3RvYnVm",
            "L2R1cmF0aW9uLnByb3RvGhdnb29nbGUvYXBpL2NsaWVudC5wcm90byK6AQoe",
            "U2FtcGxlUGxheWFibGVMb2NhdGlvbnNSZXF1ZXN0Ek0KC2FyZWFfZmlsdGVy",
            "GAEgASgLMjMuZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMudjMuc2Ft",
            "cGxlLkFyZWFGaWx0ZXJCA+BBAhJJCghjcml0ZXJpYRgCIAMoCzIyLmdvb2ds",
            "ZS5tYXBzLnBsYXlhYmxlbG9jYXRpb25zLnYzLnNhbXBsZS5Dcml0ZXJpb25C",
            "A+BBAiLYAgofU2FtcGxlUGxheWFibGVMb2NhdGlvbnNSZXNwb25zZRKJAQoe",
            "bG9jYXRpb25zX3Blcl9nYW1lX29iamVjdF90eXBlGAEgAygLMmEuZ29vZ2xl",
            "Lm1hcHMucGxheWFibGVsb2NhdGlvbnMudjMuU2FtcGxlUGxheWFibGVMb2Nh",
            "dGlvbnNSZXNwb25zZS5Mb2NhdGlvbnNQZXJHYW1lT2JqZWN0VHlwZUVudHJ5",
            "EiYKA3R0bBgJIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhqAAQof",
            "TG9jYXRpb25zUGVyR2FtZU9iamVjdFR5cGVFbnRyeRILCgNrZXkYASABKAUS",
            "TAoFdmFsdWUYAiABKAsyPS5nb29nbGUubWFwcy5wbGF5YWJsZWxvY2F0aW9u",
            "cy52My5zYW1wbGUuUGxheWFibGVMb2NhdGlvbkxpc3Q6AjgBIrgBChdMb2dQ",
            "bGF5ZXJSZXBvcnRzUmVxdWVzdBJLCg5wbGF5ZXJfcmVwb3J0cxgBIAMoCzIu",
            "Lmdvb2dsZS5tYXBzLnBsYXlhYmxlbG9jYXRpb25zLnYzLlBsYXllclJlcG9y",
            "dEID4EECEhcKCnJlcXVlc3RfaWQYAiABKAlCA+BBAhI3CgtjbGllbnRfaW5m",
            "bxgDIAEoCzIdLmdvb2dsZS5tYXBzLnVuaXR5LkNsaWVudEluZm9CA+BBAiIa",
            "ChhMb2dQbGF5ZXJSZXBvcnRzUmVzcG9uc2UisQEKFUxvZ0ltcHJlc3Npb25z",
            "UmVxdWVzdBJGCgtpbXByZXNzaW9ucxgBIAMoCzIsLmdvb2dsZS5tYXBzLnBs",
            "YXlhYmxlbG9jYXRpb25zLnYzLkltcHJlc3Npb25CA+BBAhIXCgpyZXF1ZXN0",
            "X2lkGAIgASgJQgPgQQISNwoLY2xpZW50X2luZm8YAyABKAsyHS5nb29nbGUu",
            "bWFwcy51bml0eS5DbGllbnRJbmZvQgPgQQIiGAoWTG9nSW1wcmVzc2lvbnNS",
            "ZXNwb25zZTLTBAoRUGxheWFibGVMb2NhdGlvbnMSxgEKF1NhbXBsZVBsYXlh",
            "YmxlTG9jYXRpb25zEkAuZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMu",
            "djMuU2FtcGxlUGxheWFibGVMb2NhdGlvbnNSZXF1ZXN0GkEuZ29vZ2xlLm1h",
            "cHMucGxheWFibGVsb2NhdGlvbnMudjMuU2FtcGxlUGxheWFibGVMb2NhdGlv",
            "bnNSZXNwb25zZSImgtPkkwIgIhsvdjM6c2FtcGxlUGxheWFibGVMb2NhdGlv",
            "bnM6ASoSqgEKEExvZ1BsYXllclJlcG9ydHMSOS5nb29nbGUubWFwcy5wbGF5",
            "YWJsZWxvY2F0aW9ucy52My5Mb2dQbGF5ZXJSZXBvcnRzUmVxdWVzdBo6Lmdv",
            "b2dsZS5tYXBzLnBsYXlhYmxlbG9jYXRpb25zLnYzLkxvZ1BsYXllclJlcG9y",
            "dHNSZXNwb25zZSIfgtPkkwIZIhQvdjM6bG9nUGxheWVyUmVwb3J0czoBKhKi",
            "AQoOTG9nSW1wcmVzc2lvbnMSNy5nb29nbGUubWFwcy5wbGF5YWJsZWxvY2F0",
            "aW9ucy52My5Mb2dJbXByZXNzaW9uc1JlcXVlc3QaOC5nb29nbGUubWFwcy5w",
            "bGF5YWJsZWxvY2F0aW9ucy52My5Mb2dJbXByZXNzaW9uc1Jlc3BvbnNlIh2C",
            "0+STAhciEi92Mzpsb2dJbXByZXNzaW9uczoBKhojykEgcGxheWFibGVsb2Nh",
            "dGlvbnMuZ29vZ2xlYXBpcy5jb21C4AEKJGNvbS5nb29nbGUubWFwcy5wbGF5",
            "YWJsZWxvY2F0aW9ucy52M0IWUGxheWFibGVMb2NhdGlvbnNQcm90b1ABWlFn",
            "b29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL21hcHMvcGxh",
            "eWFibGVsb2NhdGlvbnMvdjM7cGxheWFibGVsb2NhdGlvbnOiAgRHTVBMqgIg",
            "R29vZ2xlLk1hcHMuUGxheWFibGVMb2NhdGlvbnMuVjPKAiBHb29nbGVcTWFw",
            "c1xQbGF5YWJsZUxvY2F0aW9uc1xWM2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Maps.PlayableLocations.V3.ResourcesReflection.Descriptor, global::Google.Maps.PlayableLocations.V3.Sample.ResourcesReflection.Descriptor, global::Google.Maps.Unity.ClientinfoReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.PlayableLocations.V3.SamplePlayableLocationsRequest), global::Google.Maps.PlayableLocations.V3.SamplePlayableLocationsRequest.Parser, new[]{ "AreaFilter", "Criteria" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.PlayableLocations.V3.SamplePlayableLocationsResponse), global::Google.Maps.PlayableLocations.V3.SamplePlayableLocationsResponse.Parser, new[]{ "LocationsPerGameObjectType", "Ttl" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.PlayableLocations.V3.LogPlayerReportsRequest), global::Google.Maps.PlayableLocations.V3.LogPlayerReportsRequest.Parser, new[]{ "PlayerReports", "RequestId", "ClientInfo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.PlayableLocations.V3.LogPlayerReportsResponse), global::Google.Maps.PlayableLocations.V3.LogPlayerReportsResponse.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.PlayableLocations.V3.LogImpressionsRequest), global::Google.Maps.PlayableLocations.V3.LogImpressionsRequest.Parser, new[]{ "Impressions", "RequestId", "ClientInfo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.PlayableLocations.V3.LogImpressionsResponse), global::Google.Maps.PlayableLocations.V3.LogImpressionsResponse.Parser, null, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// Life of a query:
  ///
  /// - When a game starts in a new location, your game server issues a
  /// [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
  /// request. The request specifies the S2 cell, and contains one or more
  /// "criteria" for filtering:
  ///
  /// - Criterion 0: i locations for long-lived bases, or level 0 monsters, or...
  /// - Criterion 1: j locations for short-lived bases, or level 1 monsters, ...
  /// - Criterion 2: k locations for random objects.
  /// - etc (up to 5 criterion may be specified).
  ///
  /// `PlayableLocationList` will then contain mutually
  /// exclusive lists of `PlayableLocation` objects that satisfy each of
  /// the criteria. Think of it as a collection of real-world locations that you
  /// can then associate with your game state.
  ///
  /// Note: These points are impermanent in nature. E.g, parks can close, and
  /// places can be removed.
  ///
  /// The response specifies how long you can expect the playable locations to
  /// last. Once they expire, you should query the `samplePlayableLocations` API
  /// again to get a fresh view of the real world.
  /// </summary>
  public sealed partial class SamplePlayableLocationsRequest : pb::IMessage<SamplePlayableLocationsRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SamplePlayableLocationsRequest> _parser = new pb::MessageParser<SamplePlayableLocationsRequest>(() => new SamplePlayableLocationsRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SamplePlayableLocationsRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.PlayableLocations.V3.PlayablelocationsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SamplePlayableLocationsRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SamplePlayableLocationsRequest(SamplePlayableLocationsRequest other) : this() {
      areaFilter_ = other.areaFilter_ != null ? other.areaFilter_.Clone() : null;
      criteria_ = other.criteria_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SamplePlayableLocationsRequest Clone() {
      return new SamplePlayableLocationsRequest(this);
    }

    /// <summary>Field number for the "area_filter" field.</summary>
    public const int AreaFilterFieldNumber = 1;
    private global::Google.Maps.PlayableLocations.V3.Sample.AreaFilter areaFilter_;
    /// <summary>
    /// Required. Specifies the area to search within for playable locations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Maps.PlayableLocations.V3.Sample.AreaFilter AreaFilter {
      get { return areaFilter_; }
      set {
        areaFilter_ = value;
      }
    }

    /// <summary>Field number for the "criteria" field.</summary>
    public const int CriteriaFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.PlayableLocations.V3.Sample.Criterion> _repeated_criteria_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.PlayableLocations.V3.Sample.Criterion.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.Sample.Criterion> criteria_ = new pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.Sample.Criterion>();
    /// <summary>
    /// Required. Specifies one or more (up to 5) criteria for filtering the
    /// returned playable locations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.Sample.Criterion> Criteria {
      get { return criteria_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SamplePlayableLocationsRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SamplePlayableLocationsRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AreaFilter, other.AreaFilter)) return false;
      if(!criteria_.Equals(other.criteria_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (areaFilter_ != null) hash ^= AreaFilter.GetHashCode();
      hash ^= criteria_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (areaFilter_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AreaFilter);
      }
      criteria_.WriteTo(output, _repeated_criteria_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (areaFilter_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AreaFilter);
      }
      criteria_.WriteTo(ref output, _repeated_criteria_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (areaFilter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AreaFilter);
      }
      size += criteria_.CalculateSize(_repeated_criteria_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SamplePlayableLocationsRequest other) {
      if (other == null) {
        return;
      }
      if (other.areaFilter_ != null) {
        if (areaFilter_ == null) {
          AreaFilter = new global::Google.Maps.PlayableLocations.V3.Sample.AreaFilter();
        }
        AreaFilter.MergeFrom(other.AreaFilter);
      }
      criteria_.Add(other.criteria_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (areaFilter_ == null) {
              AreaFilter = new global::Google.Maps.PlayableLocations.V3.Sample.AreaFilter();
            }
            input.ReadMessage(AreaFilter);
            break;
          }
          case 18: {
            criteria_.AddEntriesFrom(input, _repeated_criteria_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (areaFilter_ == null) {
              AreaFilter = new global::Google.Maps.PlayableLocations.V3.Sample.AreaFilter();
            }
            input.ReadMessage(AreaFilter);
            break;
          }
          case 18: {
            criteria_.AddEntriesFrom(ref input, _repeated_criteria_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///
  /// Response for the
  /// [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
  /// method.
  /// </summary>
  public sealed partial class SamplePlayableLocationsResponse : pb::IMessage<SamplePlayableLocationsResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SamplePlayableLocationsResponse> _parser = new pb::MessageParser<SamplePlayableLocationsResponse>(() => new SamplePlayableLocationsResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SamplePlayableLocationsResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.PlayableLocations.V3.PlayablelocationsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SamplePlayableLocationsResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SamplePlayableLocationsResponse(SamplePlayableLocationsResponse other) : this() {
      locationsPerGameObjectType_ = other.locationsPerGameObjectType_.Clone();
      ttl_ = other.ttl_ != null ? other.ttl_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SamplePlayableLocationsResponse Clone() {
      return new SamplePlayableLocationsResponse(this);
    }

    /// <summary>Field number for the "locations_per_game_object_type" field.</summary>
    public const int LocationsPerGameObjectTypeFieldNumber = 1;
    private static readonly pbc::MapField<int, global::Google.Maps.PlayableLocations.V3.Sample.PlayableLocationList>.Codec _map_locationsPerGameObjectType_codec
        = new pbc::MapField<int, global::Google.Maps.PlayableLocations.V3.Sample.PlayableLocationList>.Codec(pb::FieldCodec.ForInt32(8, 0), pb::FieldCodec.ForMessage(18, global::Google.Maps.PlayableLocations.V3.Sample.PlayableLocationList.Parser), 10);
    private readonly pbc::MapField<int, global::Google.Maps.PlayableLocations.V3.Sample.PlayableLocationList> locationsPerGameObjectType_ = new pbc::MapField<int, global::Google.Maps.PlayableLocations.V3.Sample.PlayableLocationList>();
    /// <summary>
    /// Each PlayableLocation object corresponds to a game_object_type specified
    /// in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, global::Google.Maps.PlayableLocations.V3.Sample.PlayableLocationList> LocationsPerGameObjectType {
      get { return locationsPerGameObjectType_; }
    }

    /// <summary>Field number for the "ttl" field.</summary>
    public const int TtlFieldNumber = 9;
    private global::Google.Protobuf.WellKnownTypes.Duration ttl_;
    /// <summary>
    /// Required. Specifies the "time-to-live" for the set of playable locations.
    /// You can use this value to determine how long to cache the set of playable
    /// locations. After this length of time, your back-end game server should
    /// issue a new
    /// [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
    /// request to get a fresh set of playable locations (because for example, they
    /// might have been removed, a park might have closed for the day, a
    /// business might have closed permanently).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Ttl {
      get { return ttl_; }
      set {
        ttl_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SamplePlayableLocationsResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SamplePlayableLocationsResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!LocationsPerGameObjectType.Equals(other.LocationsPerGameObjectType)) return false;
      if (!object.Equals(Ttl, other.Ttl)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= LocationsPerGameObjectType.GetHashCode();
      if (ttl_ != null) hash ^= Ttl.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      locationsPerGameObjectType_.WriteTo(output, _map_locationsPerGameObjectType_codec);
      if (ttl_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Ttl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      locationsPerGameObjectType_.WriteTo(ref output, _map_locationsPerGameObjectType_codec);
      if (ttl_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Ttl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += locationsPerGameObjectType_.CalculateSize(_map_locationsPerGameObjectType_codec);
      if (ttl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ttl);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SamplePlayableLocationsResponse other) {
      if (other == null) {
        return;
      }
      locationsPerGameObjectType_.Add(other.locationsPerGameObjectType_);
      if (other.ttl_ != null) {
        if (ttl_ == null) {
          Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Ttl.MergeFrom(other.Ttl);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            locationsPerGameObjectType_.AddEntriesFrom(input, _map_locationsPerGameObjectType_codec);
            break;
          }
          case 74: {
            if (ttl_ == null) {
              Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Ttl);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            locationsPerGameObjectType_.AddEntriesFrom(ref input, _map_locationsPerGameObjectType_codec);
            break;
          }
          case 74: {
            if (ttl_ == null) {
              Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Ttl);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A request for logging your player's bad location reports.
  /// </summary>
  public sealed partial class LogPlayerReportsRequest : pb::IMessage<LogPlayerReportsRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LogPlayerReportsRequest> _parser = new pb::MessageParser<LogPlayerReportsRequest>(() => new LogPlayerReportsRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LogPlayerReportsRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.PlayableLocations.V3.PlayablelocationsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogPlayerReportsRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogPlayerReportsRequest(LogPlayerReportsRequest other) : this() {
      playerReports_ = other.playerReports_.Clone();
      requestId_ = other.requestId_;
      clientInfo_ = other.clientInfo_ != null ? other.clientInfo_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogPlayerReportsRequest Clone() {
      return new LogPlayerReportsRequest(this);
    }

    /// <summary>Field number for the "player_reports" field.</summary>
    public const int PlayerReportsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.PlayableLocations.V3.PlayerReport> _repeated_playerReports_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.PlayableLocations.V3.PlayerReport.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.PlayerReport> playerReports_ = new pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.PlayerReport>();
    /// <summary>
    /// Required. Player reports. The maximum number of player reports that you can
    /// log at once is 50.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.PlayerReport> PlayerReports {
      get { return playerReports_; }
    }

    /// <summary>Field number for the "request_id" field.</summary>
    public const int RequestIdFieldNumber = 2;
    private string requestId_ = "";
    /// <summary>
    /// Required. A string that uniquely identifies the log player reports request.
    /// This allows you to detect duplicate requests. We recommend that you use
    /// UUIDs for this value. The value must not exceed 50 characters.
    ///
    /// You should reuse the `request_id` only when retrying a request in the case
    /// of a failure. In that case, the request must be identical to the one that
    /// failed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RequestId {
      get { return requestId_; }
      set {
        requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "client_info" field.</summary>
    public const int ClientInfoFieldNumber = 3;
    private global::Google.Maps.Unity.ClientInfo clientInfo_;
    /// <summary>
    /// Required. Information about the client device (for example, device model
    /// and operating system).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Maps.Unity.ClientInfo ClientInfo {
      get { return clientInfo_; }
      set {
        clientInfo_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LogPlayerReportsRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LogPlayerReportsRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!playerReports_.Equals(other.playerReports_)) return false;
      if (RequestId != other.RequestId) return false;
      if (!object.Equals(ClientInfo, other.ClientInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= playerReports_.GetHashCode();
      if (RequestId.Length != 0) hash ^= RequestId.GetHashCode();
      if (clientInfo_ != null) hash ^= ClientInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      playerReports_.WriteTo(output, _repeated_playerReports_codec);
      if (RequestId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RequestId);
      }
      if (clientInfo_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ClientInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      playerReports_.WriteTo(ref output, _repeated_playerReports_codec);
      if (RequestId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RequestId);
      }
      if (clientInfo_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ClientInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += playerReports_.CalculateSize(_repeated_playerReports_codec);
      if (RequestId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RequestId);
      }
      if (clientInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientInfo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LogPlayerReportsRequest other) {
      if (other == null) {
        return;
      }
      playerReports_.Add(other.playerReports_);
      if (other.RequestId.Length != 0) {
        RequestId = other.RequestId;
      }
      if (other.clientInfo_ != null) {
        if (clientInfo_ == null) {
          ClientInfo = new global::Google.Maps.Unity.ClientInfo();
        }
        ClientInfo.MergeFrom(other.ClientInfo);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            playerReports_.AddEntriesFrom(input, _repeated_playerReports_codec);
            break;
          }
          case 18: {
            RequestId = input.ReadString();
            break;
          }
          case 26: {
            if (clientInfo_ == null) {
              ClientInfo = new global::Google.Maps.Unity.ClientInfo();
            }
            input.ReadMessage(ClientInfo);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            playerReports_.AddEntriesFrom(ref input, _repeated_playerReports_codec);
            break;
          }
          case 18: {
            RequestId = input.ReadString();
            break;
          }
          case 26: {
            if (clientInfo_ == null) {
              ClientInfo = new global::Google.Maps.Unity.ClientInfo();
            }
            input.ReadMessage(ClientInfo);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A response for the
  /// [LogPlayerReports][google.maps.playablelocations.v3.PlayableLocations.LogPlayerReports]
  /// method.
  ///
  /// This method returns no data upon success.
  /// </summary>
  public sealed partial class LogPlayerReportsResponse : pb::IMessage<LogPlayerReportsResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LogPlayerReportsResponse> _parser = new pb::MessageParser<LogPlayerReportsResponse>(() => new LogPlayerReportsResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LogPlayerReportsResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.PlayableLocations.V3.PlayablelocationsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogPlayerReportsResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogPlayerReportsResponse(LogPlayerReportsResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogPlayerReportsResponse Clone() {
      return new LogPlayerReportsResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LogPlayerReportsResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LogPlayerReportsResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LogPlayerReportsResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A request for logging impressions.
  /// </summary>
  public sealed partial class LogImpressionsRequest : pb::IMessage<LogImpressionsRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LogImpressionsRequest> _parser = new pb::MessageParser<LogImpressionsRequest>(() => new LogImpressionsRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LogImpressionsRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.PlayableLocations.V3.PlayablelocationsReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogImpressionsRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogImpressionsRequest(LogImpressionsRequest other) : this() {
      impressions_ = other.impressions_.Clone();
      requestId_ = other.requestId_;
      clientInfo_ = other.clientInfo_ != null ? other.clientInfo_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogImpressionsRequest Clone() {
      return new LogImpressionsRequest(this);
    }

    /// <summary>Field number for the "impressions" field.</summary>
    public const int ImpressionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.PlayableLocations.V3.Impression> _repeated_impressions_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.PlayableLocations.V3.Impression.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.Impression> impressions_ = new pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.Impression>();
    /// <summary>
    /// Required. Impression event details. The maximum number of impression
    /// reports that you can log at once is 50.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Maps.PlayableLocations.V3.Impression> Impressions {
      get { return impressions_; }
    }

    /// <summary>Field number for the "request_id" field.</summary>
    public const int RequestIdFieldNumber = 2;
    private string requestId_ = "";
    /// <summary>
    /// Required. A string that uniquely identifies the log impressions request.
    /// This allows you to detect duplicate requests. We recommend that you use
    /// UUIDs for this value. The value must not exceed 50 characters.
    ///
    /// You should reuse the `request_id` only when retrying a request in case of
    /// failure. In this case, the request must be identical to the one that
    /// failed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RequestId {
      get { return requestId_; }
      set {
        requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "client_info" field.</summary>
    public const int ClientInfoFieldNumber = 3;
    private global::Google.Maps.Unity.ClientInfo clientInfo_;
    /// <summary>
    /// Required. Information about the client device. For example, device model
    /// and operating system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Maps.Unity.ClientInfo ClientInfo {
      get { return clientInfo_; }
      set {
        clientInfo_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LogImpressionsRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LogImpressionsRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!impressions_.Equals(other.impressions_)) return false;
      if (RequestId != other.RequestId) return false;
      if (!object.Equals(ClientInfo, other.ClientInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= impressions_.GetHashCode();
      if (RequestId.Length != 0) hash ^= RequestId.GetHashCode();
      if (clientInfo_ != null) hash ^= ClientInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      impressions_.WriteTo(output, _repeated_impressions_codec);
      if (RequestId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RequestId);
      }
      if (clientInfo_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ClientInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      impressions_.WriteTo(ref output, _repeated_impressions_codec);
      if (RequestId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RequestId);
      }
      if (clientInfo_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ClientInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += impressions_.CalculateSize(_repeated_impressions_codec);
      if (RequestId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RequestId);
      }
      if (clientInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientInfo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LogImpressionsRequest other) {
      if (other == null) {
        return;
      }
      impressions_.Add(other.impressions_);
      if (other.RequestId.Length != 0) {
        RequestId = other.RequestId;
      }
      if (other.clientInfo_ != null) {
        if (clientInfo_ == null) {
          ClientInfo = new global::Google.Maps.Unity.ClientInfo();
        }
        ClientInfo.MergeFrom(other.ClientInfo);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            impressions_.AddEntriesFrom(input, _repeated_impressions_codec);
            break;
          }
          case 18: {
            RequestId = input.ReadString();
            break;
          }
          case 26: {
            if (clientInfo_ == null) {
              ClientInfo = new global::Google.Maps.Unity.ClientInfo();
            }
            input.ReadMessage(ClientInfo);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            impressions_.AddEntriesFrom(ref input, _repeated_impressions_codec);
            break;
          }
          case 18: {
            RequestId = input.ReadString();
            break;
          }
          case 26: {
            if (clientInfo_ == null) {
              ClientInfo = new global::Google.Maps.Unity.ClientInfo();
            }
            input.ReadMessage(ClientInfo);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A response for the
  /// [LogImpressions][google.maps.playablelocations.v3.PlayableLocations.LogImpressions]
  /// method. This method returns no data upon success.
  /// </summary>
  public sealed partial class LogImpressionsResponse : pb::IMessage<LogImpressionsResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LogImpressionsResponse> _parser = new pb::MessageParser<LogImpressionsResponse>(() => new LogImpressionsResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LogImpressionsResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.PlayableLocations.V3.PlayablelocationsReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogImpressionsResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogImpressionsResponse(LogImpressionsResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogImpressionsResponse Clone() {
      return new LogImpressionsResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LogImpressionsResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LogImpressionsResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LogImpressionsResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
