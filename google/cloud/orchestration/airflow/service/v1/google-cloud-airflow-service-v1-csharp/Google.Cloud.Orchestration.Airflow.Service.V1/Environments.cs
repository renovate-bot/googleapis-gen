// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/orchestration/airflow/service/v1/environments.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Orchestration.Airflow.Service.V1 {

  /// <summary>Holder for reflection information generated from google/cloud/orchestration/airflow/service/v1/environments.proto</summary>
  public static partial class EnvironmentsReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/orchestration/airflow/service/v1/environments.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static EnvironmentsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkBnb29nbGUvY2xvdWQvb3JjaGVzdHJhdGlvbi9haXJmbG93L3NlcnZpY2Uv",
            "djEvZW52aXJvbm1lbnRzLnByb3RvEi1nb29nbGUuY2xvdWQub3JjaGVzdHJh",
            "dGlvbi5haXJmbG93LnNlcnZpY2UudjEaHGdvb2dsZS9hcGkvYW5ub3RhdGlv",
            "bnMucHJvdG8aF2dvb2dsZS9hcGkvY2xpZW50LnByb3RvGh9nb29nbGUvYXBp",
            "L2ZpZWxkX2JlaGF2aW9yLnByb3RvGhlnb29nbGUvYXBpL3Jlc291cmNlLnBy",
            "b3RvGiNnb29nbGUvbG9uZ3J1bm5pbmcvb3BlcmF0aW9ucy5wcm90bxogZ29v",
            "Z2xlL3Byb3RvYnVmL2ZpZWxkX21hc2sucHJvdG8aH2dvb2dsZS9wcm90b2J1",
            "Zi90aW1lc3RhbXAucHJvdG8iewoYQ3JlYXRlRW52aXJvbm1lbnRSZXF1ZXN0",
            "Eg4KBnBhcmVudBgBIAEoCRJPCgtlbnZpcm9ubWVudBgCIAEoCzI6Lmdvb2ds",
            "ZS5jbG91ZC5vcmNoZXN0cmF0aW9uLmFpcmZsb3cuc2VydmljZS52MS5FbnZp",
            "cm9ubWVudCIlChVHZXRFbnZpcm9ubWVudFJlcXVlc3QSDAoEbmFtZRgBIAEo",
            "CSJQChdMaXN0RW52aXJvbm1lbnRzUmVxdWVzdBIOCgZwYXJlbnQYASABKAkS",
            "EQoJcGFnZV9zaXplGAIgASgFEhIKCnBhZ2VfdG9rZW4YAyABKAkihQEKGExp",
            "c3RFbnZpcm9ubWVudHNSZXNwb25zZRJQCgxlbnZpcm9ubWVudHMYASADKAsy",
            "Oi5nb29nbGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZpY2Uu",
            "djEuRW52aXJvbm1lbnQSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIigKGERl",
            "bGV0ZUVudmlyb25tZW50UmVxdWVzdBIMCgRuYW1lGAEgASgJIqoBChhVcGRh",
            "dGVFbnZpcm9ubWVudFJlcXVlc3QSDAoEbmFtZRgCIAEoCRJPCgtlbnZpcm9u",
            "bWVudBgBIAEoCzI6Lmdvb2dsZS5jbG91ZC5vcmNoZXN0cmF0aW9uLmFpcmZs",
            "b3cuc2VydmljZS52MS5FbnZpcm9ubWVudBIvCgt1cGRhdGVfbWFzaxgDIAEo",
            "CzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2simgYKEUVudmlyb25tZW50",
            "Q29uZmlnEhMKC2drZV9jbHVzdGVyGAEgASgJEhYKDmRhZ19nY3NfcHJlZml4",
            "GAIgASgJEhIKCm5vZGVfY291bnQYAyABKAUSVgoPc29mdHdhcmVfY29uZmln",
            "GAQgASgLMj0uZ29vZ2xlLmNsb3VkLm9yY2hlc3RyYXRpb24uYWlyZmxvdy5z",
            "ZXJ2aWNlLnYxLlNvZnR3YXJlQ29uZmlnEk4KC25vZGVfY29uZmlnGAUgASgL",
            "MjkuZ29vZ2xlLmNsb3VkLm9yY2hlc3RyYXRpb24uYWlyZmxvdy5zZXJ2aWNl",
            "LnYxLk5vZGVDb25maWcSawoacHJpdmF0ZV9lbnZpcm9ubWVudF9jb25maWcY",
            "ByABKAsyRy5nb29nbGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNl",
            "cnZpY2UudjEuUHJpdmF0ZUVudmlyb25tZW50Q29uZmlnEnwKIXdlYl9zZXJ2",
            "ZXJfbmV0d29ya19hY2Nlc3NfY29udHJvbBgIIAEoCzJMLmdvb2dsZS5jbG91",
            "ZC5vcmNoZXN0cmF0aW9uLmFpcmZsb3cuc2VydmljZS52MS5XZWJTZXJ2ZXJO",
            "ZXR3b3JrQWNjZXNzQ29udHJvbEID4EEBElsKD2RhdGFiYXNlX2NvbmZpZxgJ",
            "IAEoCzI9Lmdvb2dsZS5jbG91ZC5vcmNoZXN0cmF0aW9uLmFpcmZsb3cuc2Vy",
            "dmljZS52MS5EYXRhYmFzZUNvbmZpZ0ID4EEBEl4KEXdlYl9zZXJ2ZXJfY29u",
            "ZmlnGAogASgLMj4uZ29vZ2xlLmNsb3VkLm9yY2hlc3RyYXRpb24uYWlyZmxv",
            "dy5zZXJ2aWNlLnYxLldlYlNlcnZlckNvbmZpZ0ID4EEBEl8KEWVuY3J5cHRp",
            "b25fY29uZmlnGAsgASgLMj8uZ29vZ2xlLmNsb3VkLm9yY2hlc3RyYXRpb24u",
            "YWlyZmxvdy5zZXJ2aWNlLnYxLkVuY3J5cHRpb25Db25maWdCA+BBARITCgth",
            "aXJmbG93X3VyaRgGIAEoCSLSAQodV2ViU2VydmVyTmV0d29ya0FjY2Vzc0Nv",
            "bnRyb2wSdgoRYWxsb3dlZF9pcF9yYW5nZXMYASADKAsyWy5nb29nbGUuY2xv",
            "dWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZpY2UudjEuV2ViU2VydmVy",
            "TmV0d29ya0FjY2Vzc0NvbnRyb2wuQWxsb3dlZElwUmFuZ2UaOQoOQWxsb3dl",
            "ZElwUmFuZ2USDQoFdmFsdWUYASABKAkSGAoLZGVzY3JpcHRpb24YAiABKAlC",
            "A+BBASIrCg5EYXRhYmFzZUNvbmZpZxIZCgxtYWNoaW5lX3R5cGUYASABKAlC",
            "A+BBASIsCg9XZWJTZXJ2ZXJDb25maWcSGQoMbWFjaGluZV90eXBlGAEgASgJ",
            "QgPgQQEiLQoQRW5jcnlwdGlvbkNvbmZpZxIZCgxrbXNfa2V5X25hbWUYASAB",
            "KAlCA+BBASK1BAoOU29mdHdhcmVDb25maWcSFQoNaW1hZ2VfdmVyc2lvbhgB",
            "IAEoCRJ7ChhhaXJmbG93X2NvbmZpZ19vdmVycmlkZXMYAiADKAsyWS5nb29n",
            "bGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZpY2UudjEuU29m",
            "dHdhcmVDb25maWcuQWlyZmxvd0NvbmZpZ092ZXJyaWRlc0VudHJ5EmYKDXB5",
            "cGlfcGFja2FnZXMYAyADKAsyTy5nb29nbGUuY2xvdWQub3JjaGVzdHJhdGlv",
            "bi5haXJmbG93LnNlcnZpY2UudjEuU29mdHdhcmVDb25maWcuUHlwaVBhY2th",
            "Z2VzRW50cnkSZgoNZW52X3ZhcmlhYmxlcxgEIAMoCzJPLmdvb2dsZS5jbG91",
            "ZC5vcmNoZXN0cmF0aW9uLmFpcmZsb3cuc2VydmljZS52MS5Tb2Z0d2FyZUNv",
            "bmZpZy5FbnZWYXJpYWJsZXNFbnRyeRIWCg5weXRob25fdmVyc2lvbhgGIAEo",
            "CRo9ChtBaXJmbG93Q29uZmlnT3ZlcnJpZGVzRW50cnkSCwoDa2V5GAEgASgJ",
            "Eg0KBXZhbHVlGAIgASgJOgI4ARozChFQeXBpUGFja2FnZXNFbnRyeRILCgNr",
            "ZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjMKEUVudlZhcmlhYmxlc0Vu",
            "dHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEikAIKEklQQWxs",
            "b2NhdGlvblBvbGljeRIbCg51c2VfaXBfYWxpYXNlcxgBIAEoCEID4EEBEisK",
            "HGNsdXN0ZXJfc2Vjb25kYXJ5X3JhbmdlX25hbWUYAiABKAlCA+BBAUgAEiYK",
            "F2NsdXN0ZXJfaXB2NF9jaWRyX2Jsb2NrGAQgASgJQgPgQQFIABIsCh1zZXJ2",
            "aWNlc19zZWNvbmRhcnlfcmFuZ2VfbmFtZRgDIAEoCUID4EEBSAESJwoYc2Vy",
            "dmljZXNfaXB2NF9jaWRyX2Jsb2NrGAUgASgJQgPgQQFIAUIXChVjbHVzdGVy",
            "X2lwX2FsbG9jYXRpb25CGAoWc2VydmljZXNfaXBfYWxsb2NhdGlvbiKSAgoK",
            "Tm9kZUNvbmZpZxIQCghsb2NhdGlvbhgBIAEoCRIUCgxtYWNoaW5lX3R5cGUY",
            "AiABKAkSDwoHbmV0d29yaxgDIAEoCRISCgpzdWJuZXR3b3JrGAQgASgJEhQK",
            "DGRpc2tfc2l6ZV9nYhgFIAEoBRIUCgxvYXV0aF9zY29wZXMYBiADKAkSFwoP",
            "c2VydmljZV9hY2NvdW50GAcgASgJEgwKBHRhZ3MYCCADKAkSZAoUaXBfYWxs",
            "b2NhdGlvbl9wb2xpY3kYCSABKAsyQS5nb29nbGUuY2xvdWQub3JjaGVzdHJh",
            "dGlvbi5haXJmbG93LnNlcnZpY2UudjEuSVBBbGxvY2F0aW9uUG9saWN5QgPg",
            "QQEiigEKFFByaXZhdGVDbHVzdGVyQ29uZmlnEiQKF2VuYWJsZV9wcml2YXRl",
            "X2VuZHBvaW50GAEgASgIQgPgQQESIwoWbWFzdGVyX2lwdjRfY2lkcl9ibG9j",
            "axgCIAEoCUID4EEBEicKGm1hc3Rlcl9pcHY0X3Jlc2VydmVkX3JhbmdlGAMg",
            "ASgJQgPgQQMiqwIKGFByaXZhdGVFbnZpcm9ubWVudENvbmZpZxInChplbmFi",
            "bGVfcHJpdmF0ZV9lbnZpcm9ubWVudBgBIAEoCEID4EEBEmgKFnByaXZhdGVf",
            "Y2x1c3Rlcl9jb25maWcYAiABKAsyQy5nb29nbGUuY2xvdWQub3JjaGVzdHJh",
            "dGlvbi5haXJmbG93LnNlcnZpY2UudjEuUHJpdmF0ZUNsdXN0ZXJDb25maWdC",
            "A+BBARInChp3ZWJfc2VydmVyX2lwdjRfY2lkcl9ibG9jaxgDIAEoCUID4EEB",
            "EiYKGWNsb3VkX3NxbF9pcHY0X2NpZHJfYmxvY2sYBCABKAlCA+BBARIrCh53",
            "ZWJfc2VydmVyX2lwdjRfcmVzZXJ2ZWRfcmFuZ2UYBSABKAlCA+BBAyKFBQoL",
            "RW52aXJvbm1lbnQSDAoEbmFtZRgBIAEoCRJQCgZjb25maWcYAiABKAsyQC5n",
            "b29nbGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZpY2UudjEu",
            "RW52aXJvbm1lbnRDb25maWcSDAoEdXVpZBgDIAEoCRJPCgVzdGF0ZRgEIAEo",
            "DjJALmdvb2dsZS5jbG91ZC5vcmNoZXN0cmF0aW9uLmFpcmZsb3cuc2Vydmlj",
            "ZS52MS5FbnZpcm9ubWVudC5TdGF0ZRIvCgtjcmVhdGVfdGltZRgFIAEoCzIa",
            "Lmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLwoLdXBkYXRlX3RpbWUYBiAB",
            "KAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wElYKBmxhYmVscxgHIAMo",
            "CzJGLmdvb2dsZS5jbG91ZC5vcmNoZXN0cmF0aW9uLmFpcmZsb3cuc2Vydmlj",
            "ZS52MS5FbnZpcm9ubWVudC5MYWJlbHNFbnRyeRotCgtMYWJlbHNFbnRyeRIL",
            "CgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBImAKBVN0YXRlEhUKEVNU",
            "QVRFX1VOU1BFQ0lGSUVEEAASDAoIQ1JFQVRJTkcQARILCgdSVU5OSU5HEAIS",
            "DAoIVVBEQVRJTkcQAxIMCghERUxFVElORxAEEgkKBUVSUk9SEAU6bOpBaQoj",
            "Y29tcG9zZXIuZ29vZ2xlYXBpcy5jb20vRW52aXJvbm1lbnQSQnByb2plY3Rz",
            "L3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0aW9ufS9lbnZpcm9ubWVudHMv",
            "e2Vudmlyb25tZW50fSL5AwoUQ2hlY2tVcGdyYWRlUmVzcG9uc2USGgoNYnVp",
            "bGRfbG9nX3VyaRgBIAEoCUID4EEDEn8KHmNvbnRhaW5zX3B5cGlfbW9kdWxl",
            "c19jb25mbGljdBgEIAEoDjJSLmdvb2dsZS5jbG91ZC5vcmNoZXN0cmF0aW9u",
            "LmFpcmZsb3cuc2VydmljZS52MS5DaGVja1VwZ3JhZGVSZXNwb25zZS5Db25m",
            "bGljdFJlc3VsdEID4EEDEiwKH3B5cGlfY29uZmxpY3RfYnVpbGRfbG9nX2V4",
            "dHJhY3QYAyABKAlCA+BBAxIVCg1pbWFnZV92ZXJzaW9uGAUgASgJEnQKEXB5",
            "cGlfZGVwZW5kZW5jaWVzGAYgAygLMlkuZ29vZ2xlLmNsb3VkLm9yY2hlc3Ry",
            "YXRpb24uYWlyZmxvdy5zZXJ2aWNlLnYxLkNoZWNrVXBncmFkZVJlc3BvbnNl",
            "LlB5cGlEZXBlbmRlbmNpZXNFbnRyeRo3ChVQeXBpRGVwZW5kZW5jaWVzRW50",
            "cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJQCg5Db25mbGlj",
            "dFJlc3VsdBIfChtDT05GTElDVF9SRVNVTFRfVU5TUEVDSUZJRUQQABIMCghD",
            "T05GTElDVBABEg8KC05PX0NPTkZMSUNUEAIylwsKDEVudmlyb25tZW50cxKp",
            "AgoRQ3JlYXRlRW52aXJvbm1lbnQSRy5nb29nbGUuY2xvdWQub3JjaGVzdHJh",
            "dGlvbi5haXJmbG93LnNlcnZpY2UudjEuQ3JlYXRlRW52aXJvbm1lbnRSZXF1",
            "ZXN0Gh0uZ29vZ2xlLmxvbmdydW5uaW5nLk9wZXJhdGlvbiKrAYLT5JMCPyIw",
            "L3YxL3twYXJlbnQ9cHJvamVjdHMvKi9sb2NhdGlvbnMvKn0vZW52aXJvbm1l",
            "bnRzOgtlbnZpcm9ubWVudNpBEnBhcmVudCxlbnZpcm9ubWVudMpBTgoLRW52",
            "aXJvbm1lbnQSP2dvb2dsZS5jbG91ZC5vcmNoZXN0cmF0aW9uLmFpcmZsb3cu",
            "c2VydmljZS52MS5PcGVyYXRpb25NZXRhZGF0YRLTAQoOR2V0RW52aXJvbm1l",
            "bnQSRC5nb29nbGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZp",
            "Y2UudjEuR2V0RW52aXJvbm1lbnRSZXF1ZXN0GjouZ29vZ2xlLmNsb3VkLm9y",
            "Y2hlc3RyYXRpb24uYWlyZmxvdy5zZXJ2aWNlLnYxLkVudmlyb25tZW50Ij+C",
            "0+STAjISMC92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2Vudmly",
            "b25tZW50cy8qfdpBBG5hbWUS5gEKEExpc3RFbnZpcm9ubWVudHMSRi5nb29n",
            "bGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZpY2UudjEuTGlz",
            "dEVudmlyb25tZW50c1JlcXVlc3QaRy5nb29nbGUuY2xvdWQub3JjaGVzdHJh",
            "dGlvbi5haXJmbG93LnNlcnZpY2UudjEuTGlzdEVudmlyb25tZW50c1Jlc3Bv",
            "bnNlIkGC0+STAjISMC92MS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25z",
            "Lyp9L2Vudmlyb25tZW50c9pBBnBhcmVudBKzAgoRVXBkYXRlRW52aXJvbm1l",
            "bnQSRy5nb29nbGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZp",
            "Y2UudjEuVXBkYXRlRW52aXJvbm1lbnRSZXF1ZXN0Gh0uZ29vZ2xlLmxvbmdy",
            "dW5uaW5nLk9wZXJhdGlvbiK1AYLT5JMCPzIwL3YxL3tuYW1lPXByb2plY3Rz",
            "LyovbG9jYXRpb25zLyovZW52aXJvbm1lbnRzLyp9OgtlbnZpcm9ubWVudNpB",
            "HG5hbWUsZW52aXJvbm1lbnQsdXBkYXRlX21hc2vKQU4KC0Vudmlyb25tZW50",
            "Ej9nb29nbGUuY2xvdWQub3JjaGVzdHJhdGlvbi5haXJmbG93LnNlcnZpY2Uu",
            "djEuT3BlcmF0aW9uTWV0YWRhdGESmAIKEURlbGV0ZUVudmlyb25tZW50Ekcu",
            "Z29vZ2xlLmNsb3VkLm9yY2hlc3RyYXRpb24uYWlyZmxvdy5zZXJ2aWNlLnYx",
            "LkRlbGV0ZUVudmlyb25tZW50UmVxdWVzdBodLmdvb2dsZS5sb25ncnVubmlu",
            "Zy5PcGVyYXRpb24imgGC0+STAjIqMC92MS97bmFtZT1wcm9qZWN0cy8qL2xv",
            "Y2F0aW9ucy8qL2Vudmlyb25tZW50cy8qfdpBBG5hbWXKQVgKFWdvb2dsZS5w",
            "cm90b2J1Zi5FbXB0eRI/Z29vZ2xlLmNsb3VkLm9yY2hlc3RyYXRpb24uYWly",
            "Zmxvdy5zZXJ2aWNlLnYxLk9wZXJhdGlvbk1ldGFkYXRhGkvKQRdjb21wb3Nl",
            "ci5nb29nbGVhcGlzLmNvbdJBLmh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29t",
            "L2F1dGgvY2xvdWQtcGxhdGZvcm1CiwEKMWNvbS5nb29nbGUuY2xvdWQub3Jj",
            "aGVzdHJhdGlvbi5haXJmbG93LnNlcnZpY2UudjFQAVpUZ29vZ2xlLmdvbGFu",
            "Zy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9jbG91ZC9vcmNoZXN0cmF0aW9u",
            "L2FpcmZsb3cvc2VydmljZS92MTtzZXJ2aWNlYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Google.LongRunning.OperationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.FieldMaskReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.CreateEnvironmentRequest), global::Google.Cloud.Orchestration.Airflow.Service.V1.CreateEnvironmentRequest.Parser, new[]{ "Parent", "Environment" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.GetEnvironmentRequest), global::Google.Cloud.Orchestration.Airflow.Service.V1.GetEnvironmentRequest.Parser, new[]{ "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.ListEnvironmentsRequest), global::Google.Cloud.Orchestration.Airflow.Service.V1.ListEnvironmentsRequest.Parser, new[]{ "Parent", "PageSize", "PageToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.ListEnvironmentsResponse), global::Google.Cloud.Orchestration.Airflow.Service.V1.ListEnvironmentsResponse.Parser, new[]{ "Environments", "NextPageToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.DeleteEnvironmentRequest), global::Google.Cloud.Orchestration.Airflow.Service.V1.DeleteEnvironmentRequest.Parser, new[]{ "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.UpdateEnvironmentRequest), global::Google.Cloud.Orchestration.Airflow.Service.V1.UpdateEnvironmentRequest.Parser, new[]{ "Name", "Environment", "UpdateMask" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentConfig.Parser, new[]{ "GkeCluster", "DagGcsPrefix", "NodeCount", "SoftwareConfig", "NodeConfig", "PrivateEnvironmentConfig", "WebServerNetworkAccessControl", "DatabaseConfig", "WebServerConfig", "EncryptionConfig", "AirflowUri" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl), global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Parser, new[]{ "AllowedIpRanges" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Types.AllowedIpRange), global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Types.AllowedIpRange.Parser, new[]{ "Value", "Description" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.DatabaseConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.DatabaseConfig.Parser, new[]{ "MachineType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerConfig.Parser, new[]{ "MachineType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.EncryptionConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.EncryptionConfig.Parser, new[]{ "KmsKeyName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.SoftwareConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.SoftwareConfig.Parser, new[]{ "ImageVersion", "AirflowConfigOverrides", "PypiPackages", "EnvVariables", "PythonVersion" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.IPAllocationPolicy), global::Google.Cloud.Orchestration.Airflow.Service.V1.IPAllocationPolicy.Parser, new[]{ "UseIpAliases", "ClusterSecondaryRangeName", "ClusterIpv4CidrBlock", "ServicesSecondaryRangeName", "ServicesIpv4CidrBlock" }, new[]{ "ClusterIpAllocation", "ServicesIpAllocation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.NodeConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.NodeConfig.Parser, new[]{ "Location", "MachineType", "Network", "Subnetwork", "DiskSizeGb", "OauthScopes", "ServiceAccount", "Tags", "IpAllocationPolicy" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateClusterConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateClusterConfig.Parser, new[]{ "EnablePrivateEndpoint", "MasterIpv4CidrBlock", "MasterIpv4ReservedRange" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateEnvironmentConfig), global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateEnvironmentConfig.Parser, new[]{ "EnablePrivateEnvironment", "PrivateClusterConfig", "WebServerIpv4CidrBlock", "CloudSqlIpv4CidrBlock", "WebServerIpv4ReservedRange" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment), global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Parser, new[]{ "Name", "Config", "Uuid", "State", "CreateTime", "UpdateTime", "Labels" }, null, new[]{ typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State) }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse), global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Parser, new[]{ "BuildLogUri", "ContainsPypiModulesConflict", "PypiConflictBuildLogExtract", "ImageVersion", "PypiDependencies" }, null, new[]{ typeof(global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult) }, null, new pbr::GeneratedClrTypeInfo[] { null, })
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Create a new environment.
  /// </summary>
  public sealed partial class CreateEnvironmentRequest : pb::IMessage<CreateEnvironmentRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CreateEnvironmentRequest> _parser = new pb::MessageParser<CreateEnvironmentRequest>(() => new CreateEnvironmentRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreateEnvironmentRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateEnvironmentRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateEnvironmentRequest(CreateEnvironmentRequest other) : this() {
      parent_ = other.parent_;
      environment_ = other.environment_ != null ? other.environment_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateEnvironmentRequest Clone() {
      return new CreateEnvironmentRequest(this);
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// The parent must be of the form
    /// "projects/{projectId}/locations/{locationId}".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "environment" field.</summary>
    public const int EnvironmentFieldNumber = 2;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment environment_;
    /// <summary>
    /// The environment to create.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment Environment {
      get { return environment_; }
      set {
        environment_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreateEnvironmentRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreateEnvironmentRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Parent != other.Parent) return false;
      if (!object.Equals(Environment, other.Environment)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (environment_ != null) hash ^= Environment.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (environment_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Environment);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (environment_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Environment);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (environment_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Environment);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreateEnvironmentRequest other) {
      if (other == null) {
        return;
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.environment_ != null) {
        if (environment_ == null) {
          Environment = new global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment();
        }
        Environment.MergeFrom(other.Environment);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            if (environment_ == null) {
              Environment = new global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment();
            }
            input.ReadMessage(Environment);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            if (environment_ == null) {
              Environment = new global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment();
            }
            input.ReadMessage(Environment);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Get an environment.
  /// </summary>
  public sealed partial class GetEnvironmentRequest : pb::IMessage<GetEnvironmentRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetEnvironmentRequest> _parser = new pb::MessageParser<GetEnvironmentRequest>(() => new GetEnvironmentRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetEnvironmentRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetEnvironmentRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetEnvironmentRequest(GetEnvironmentRequest other) : this() {
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetEnvironmentRequest Clone() {
      return new GetEnvironmentRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The resource name of the environment to get, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetEnvironmentRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetEnvironmentRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetEnvironmentRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// List environments in a project and location.
  /// </summary>
  public sealed partial class ListEnvironmentsRequest : pb::IMessage<ListEnvironmentsRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ListEnvironmentsRequest> _parser = new pb::MessageParser<ListEnvironmentsRequest>(() => new ListEnvironmentsRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListEnvironmentsRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListEnvironmentsRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListEnvironmentsRequest(ListEnvironmentsRequest other) : this() {
      parent_ = other.parent_;
      pageSize_ = other.pageSize_;
      pageToken_ = other.pageToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListEnvironmentsRequest Clone() {
      return new ListEnvironmentsRequest(this);
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// List environments in the given project and location, in the form:
    /// "projects/{projectId}/locations/{locationId}"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "page_size" field.</summary>
    public const int PageSizeFieldNumber = 2;
    private int pageSize_;
    /// <summary>
    /// The maximum number of environments to return.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PageSize {
      get { return pageSize_; }
      set {
        pageSize_ = value;
      }
    }

    /// <summary>Field number for the "page_token" field.</summary>
    public const int PageTokenFieldNumber = 3;
    private string pageToken_ = "";
    /// <summary>
    /// The next_page_token value returned from a previous List request, if any.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PageToken {
      get { return pageToken_; }
      set {
        pageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListEnvironmentsRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListEnvironmentsRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Parent != other.Parent) return false;
      if (PageSize != other.PageSize) return false;
      if (PageToken != other.PageToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (PageSize != 0) hash ^= PageSize.GetHashCode();
      if (PageToken.Length != 0) hash ^= PageToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (PageSize != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(PageToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (PageSize != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(PageToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (PageSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PageSize);
      }
      if (PageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PageToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListEnvironmentsRequest other) {
      if (other == null) {
        return;
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.PageSize != 0) {
        PageSize = other.PageSize;
      }
      if (other.PageToken.Length != 0) {
        PageToken = other.PageToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 16: {
            PageSize = input.ReadInt32();
            break;
          }
          case 26: {
            PageToken = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 16: {
            PageSize = input.ReadInt32();
            break;
          }
          case 26: {
            PageToken = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The environments in a project and location.
  /// </summary>
  public sealed partial class ListEnvironmentsResponse : pb::IMessage<ListEnvironmentsResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ListEnvironmentsResponse> _parser = new pb::MessageParser<ListEnvironmentsResponse>(() => new ListEnvironmentsResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListEnvironmentsResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListEnvironmentsResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListEnvironmentsResponse(ListEnvironmentsResponse other) : this() {
      environments_ = other.environments_.Clone();
      nextPageToken_ = other.nextPageToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListEnvironmentsResponse Clone() {
      return new ListEnvironmentsResponse(this);
    }

    /// <summary>Field number for the "environments" field.</summary>
    public const int EnvironmentsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment> _repeated_environments_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment> environments_ = new pbc::RepeatedField<global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment>();
    /// <summary>
    /// The list of environments returned by a ListEnvironmentsRequest.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment> Environments {
      get { return environments_; }
    }

    /// <summary>Field number for the "next_page_token" field.</summary>
    public const int NextPageTokenFieldNumber = 2;
    private string nextPageToken_ = "";
    /// <summary>
    /// The page token used to query for the next page if one exists.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NextPageToken {
      get { return nextPageToken_; }
      set {
        nextPageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListEnvironmentsResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListEnvironmentsResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!environments_.Equals(other.environments_)) return false;
      if (NextPageToken != other.NextPageToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= environments_.GetHashCode();
      if (NextPageToken.Length != 0) hash ^= NextPageToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      environments_.WriteTo(output, _repeated_environments_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      environments_.WriteTo(ref output, _repeated_environments_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += environments_.CalculateSize(_repeated_environments_codec);
      if (NextPageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NextPageToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListEnvironmentsResponse other) {
      if (other == null) {
        return;
      }
      environments_.Add(other.environments_);
      if (other.NextPageToken.Length != 0) {
        NextPageToken = other.NextPageToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            environments_.AddEntriesFrom(input, _repeated_environments_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            environments_.AddEntriesFrom(ref input, _repeated_environments_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Delete an environment.
  /// </summary>
  public sealed partial class DeleteEnvironmentRequest : pb::IMessage<DeleteEnvironmentRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DeleteEnvironmentRequest> _parser = new pb::MessageParser<DeleteEnvironmentRequest>(() => new DeleteEnvironmentRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeleteEnvironmentRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteEnvironmentRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteEnvironmentRequest(DeleteEnvironmentRequest other) : this() {
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteEnvironmentRequest Clone() {
      return new DeleteEnvironmentRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The environment to delete, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeleteEnvironmentRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeleteEnvironmentRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeleteEnvironmentRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Update an environment.
  /// </summary>
  public sealed partial class UpdateEnvironmentRequest : pb::IMessage<UpdateEnvironmentRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateEnvironmentRequest> _parser = new pb::MessageParser<UpdateEnvironmentRequest>(() => new UpdateEnvironmentRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateEnvironmentRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateEnvironmentRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateEnvironmentRequest(UpdateEnvironmentRequest other) : this() {
      name_ = other.name_;
      environment_ = other.environment_ != null ? other.environment_.Clone() : null;
      updateMask_ = other.updateMask_ != null ? other.updateMask_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateEnvironmentRequest Clone() {
      return new UpdateEnvironmentRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// The relative resource name of the environment to update, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "environment" field.</summary>
    public const int EnvironmentFieldNumber = 1;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment environment_;
    /// <summary>
    /// A patch environment. Fields specified by the `updateMask` will be copied
    /// from the patch environment into the environment under update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment Environment {
      get { return environment_; }
      set {
        environment_ = value;
      }
    }

    /// <summary>Field number for the "update_mask" field.</summary>
    public const int UpdateMaskFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.FieldMask updateMask_;
    /// <summary>
    /// Required. A comma-separated list of paths, relative to `Environment`, of
    /// fields to update.
    /// For example, to set the version of scikit-learn to install in the
    /// environment to 0.19.0 and to remove an existing installation of
    /// numpy, the `updateMask` parameter would include the following two
    /// `paths` values: "config.softwareConfig.pypiPackages.scikit-learn" and
    /// "config.softwareConfig.pypiPackages.numpy". The included patch
    /// environment would specify the scikit-learn version as follows:
    ///
    ///     {
    ///       "config":{
    ///         "softwareConfig":{
    ///           "pypiPackages":{
    ///             "scikit-learn":"==0.19.0"
    ///           }
    ///         }
    ///       }
    ///     }
    ///
    /// Note that in the above example, any existing PyPI packages
    /// other than scikit-learn and numpy will be unaffected.
    ///
    /// Only one update type may be included in a single request's `updateMask`.
    /// For example, one cannot update both the PyPI packages and
    /// labels in the same request. However, it is possible to update multiple
    /// members of a map field simultaneously in the same request. For example,
    /// to set the labels "label1" and "label2" while clearing "label3" (assuming
    /// it already exists), one can
    /// provide the paths "labels.label1", "labels.label2", and "labels.label3"
    /// and populate the patch environment as follows:
    ///
    ///     {
    ///       "labels":{
    ///         "label1":"new-label1-value"
    ///         "label2":"new-label2-value"
    ///       }
    ///     }
    ///
    /// Note that in the above example, any existing labels that are not
    /// included in the `updateMask` will be unaffected.
    ///
    /// It is also possible to replace an entire map field by providing the
    /// map field's path in the `updateMask`. The new value of the field will
    /// be that which is provided in the patch environment. For example, to
    /// delete all pre-existing user-specified PyPI packages and
    /// install botocore at version 1.7.14, the `updateMask` would contain
    /// the path "config.softwareConfig.pypiPackages", and
    /// the patch environment would be the following:
    ///
    ///     {
    ///       "config":{
    ///         "softwareConfig":{
    ///           "pypiPackages":{
    ///             "botocore":"==1.7.14"
    ///           }
    ///         }
    ///       }
    ///     }
    ///
    /// **Note:** Only the following fields can be updated:
    ///
    /// * `config.softwareConfig.pypiPackages`
    ///     * Replace all custom custom PyPI packages. If a replacement
    ///       package map is not included in `environment`, all custom
    ///       PyPI packages are cleared. It is an error to provide both
    ///       this mask and a mask specifying an individual package.
    /// * `config.softwareConfig.pypiPackages.`packagename
    ///     * Update the custom PyPI package *packagename*,
    ///       preserving other packages. To delete the package, include it in
    ///       `updateMask`, and omit the mapping for it in
    ///       `environment.config.softwareConfig.pypiPackages`. It is an error
    ///       to provide both a mask of this form and the
    ///       `config.softwareConfig.pypiPackages` mask.
    /// * `labels`
    ///     * Replace all environment labels. If a replacement labels map is not
    ///       included in `environment`, all labels are cleared. It is an error to
    ///       provide both this mask and a mask specifying one or more individual
    ///       labels.
    /// * `labels.`labelName
    ///     * Set the label named *labelName*, while preserving other
    ///       labels. To delete the label, include it in `updateMask` and omit its
    ///       mapping in `environment.labels`. It is an error to provide both a
    ///       mask of this form and the `labels` mask.
    /// * `config.nodeCount`
    ///     * Horizontally scale the number of nodes in the environment. An integer
    ///       greater than or equal to 3 must be provided in the `config.nodeCount`
    ///       field.
    /// * `config.webServerNetworkAccessControl`
    ///     * Replace the environment's current `WebServerNetworkAccessControl`.
    /// * `config.databaseConfig`
    ///     * Replace the environment's current `DatabaseConfig`.
    /// * `config.webServerConfig`
    ///     * Replace the environment's current `WebServerConfig`.
    /// * `config.softwareConfig.airflowConfigOverrides`
    ///     * Replace all Apache Airflow config overrides. If a replacement config
    ///       overrides map is not included in `environment`, all config overrides
    ///       are cleared.
    ///       It is an error to provide both this mask and a mask specifying one or
    ///       more individual config overrides.
    /// * `config.softwareConfig.airflowConfigOverrides.`section-name
    ///     * Override the Apache Airflow config property *name* in the
    ///       section named *section*, preserving other properties. To
    ///       delete the property override, include it in `updateMask` and omit its
    ///       mapping in
    ///       `environment.config.softwareConfig.airflowConfigOverrides`.
    ///       It is an error to provide both a mask of this form and the
    ///       `config.softwareConfig.airflowConfigOverrides` mask.
    /// * `config.softwareConfig.envVariables`
    ///     * Replace all environment variables. If a replacement environment
    ///       variable map is not included in `environment`, all custom environment
    ///       variables  are cleared.
    ///       It is an error to provide both this mask and a mask specifying one or
    ///       more individual environment variables.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.FieldMask UpdateMask {
      get { return updateMask_; }
      set {
        updateMask_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateEnvironmentRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateEnvironmentRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Environment, other.Environment)) return false;
      if (!object.Equals(UpdateMask, other.UpdateMask)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (environment_ != null) hash ^= Environment.GetHashCode();
      if (updateMask_ != null) hash ^= UpdateMask.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (environment_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Environment);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (environment_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Environment);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (environment_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Environment);
      }
      if (updateMask_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateMask);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateEnvironmentRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.environment_ != null) {
        if (environment_ == null) {
          Environment = new global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment();
        }
        Environment.MergeFrom(other.Environment);
      }
      if (other.updateMask_ != null) {
        if (updateMask_ == null) {
          UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
        }
        UpdateMask.MergeFrom(other.UpdateMask);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (environment_ == null) {
              Environment = new global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment();
            }
            input.ReadMessage(Environment);
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (environment_ == null) {
              Environment = new global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment();
            }
            input.ReadMessage(Environment);
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration information for an environment.
  /// </summary>
  public sealed partial class EnvironmentConfig : pb::IMessage<EnvironmentConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvironmentConfig> _parser = new pb::MessageParser<EnvironmentConfig>(() => new EnvironmentConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EnvironmentConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnvironmentConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnvironmentConfig(EnvironmentConfig other) : this() {
      gkeCluster_ = other.gkeCluster_;
      dagGcsPrefix_ = other.dagGcsPrefix_;
      nodeCount_ = other.nodeCount_;
      softwareConfig_ = other.softwareConfig_ != null ? other.softwareConfig_.Clone() : null;
      nodeConfig_ = other.nodeConfig_ != null ? other.nodeConfig_.Clone() : null;
      privateEnvironmentConfig_ = other.privateEnvironmentConfig_ != null ? other.privateEnvironmentConfig_.Clone() : null;
      webServerNetworkAccessControl_ = other.webServerNetworkAccessControl_ != null ? other.webServerNetworkAccessControl_.Clone() : null;
      databaseConfig_ = other.databaseConfig_ != null ? other.databaseConfig_.Clone() : null;
      webServerConfig_ = other.webServerConfig_ != null ? other.webServerConfig_.Clone() : null;
      encryptionConfig_ = other.encryptionConfig_ != null ? other.encryptionConfig_.Clone() : null;
      airflowUri_ = other.airflowUri_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnvironmentConfig Clone() {
      return new EnvironmentConfig(this);
    }

    /// <summary>Field number for the "gke_cluster" field.</summary>
    public const int GkeClusterFieldNumber = 1;
    private string gkeCluster_ = "";
    /// <summary>
    /// Output only. The Kubernetes Engine cluster used to run this environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GkeCluster {
      get { return gkeCluster_; }
      set {
        gkeCluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "dag_gcs_prefix" field.</summary>
    public const int DagGcsPrefixFieldNumber = 2;
    private string dagGcsPrefix_ = "";
    /// <summary>
    /// Output only. The Cloud Storage prefix of the DAGs for this environment. Although Cloud
    /// Storage objects reside in a flat namespace, a hierarchical file tree
    /// can be simulated using "/"-delimited object name prefixes. DAG objects for
    /// this environment reside in a simulated directory with the given prefix.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DagGcsPrefix {
      get { return dagGcsPrefix_; }
      set {
        dagGcsPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 3;
    private int nodeCount_;
    /// <summary>
    /// The number of nodes in the Kubernetes Engine cluster that will be
    /// used to run this environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    /// <summary>Field number for the "software_config" field.</summary>
    public const int SoftwareConfigFieldNumber = 4;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.SoftwareConfig softwareConfig_;
    /// <summary>
    /// The configuration settings for software inside the environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.SoftwareConfig SoftwareConfig {
      get { return softwareConfig_; }
      set {
        softwareConfig_ = value;
      }
    }

    /// <summary>Field number for the "node_config" field.</summary>
    public const int NodeConfigFieldNumber = 5;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.NodeConfig nodeConfig_;
    /// <summary>
    /// The configuration used for the Kubernetes Engine cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.NodeConfig NodeConfig {
      get { return nodeConfig_; }
      set {
        nodeConfig_ = value;
      }
    }

    /// <summary>Field number for the "private_environment_config" field.</summary>
    public const int PrivateEnvironmentConfigFieldNumber = 7;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateEnvironmentConfig privateEnvironmentConfig_;
    /// <summary>
    /// The configuration used for the Private IP Cloud Composer environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateEnvironmentConfig PrivateEnvironmentConfig {
      get { return privateEnvironmentConfig_; }
      set {
        privateEnvironmentConfig_ = value;
      }
    }

    /// <summary>Field number for the "web_server_network_access_control" field.</summary>
    public const int WebServerNetworkAccessControlFieldNumber = 8;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl webServerNetworkAccessControl_;
    /// <summary>
    /// Optional. The network-level access control policy for the Airflow web server. If
    /// unspecified, no network-level access restrictions will be applied.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl WebServerNetworkAccessControl {
      get { return webServerNetworkAccessControl_; }
      set {
        webServerNetworkAccessControl_ = value;
      }
    }

    /// <summary>Field number for the "database_config" field.</summary>
    public const int DatabaseConfigFieldNumber = 9;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.DatabaseConfig databaseConfig_;
    /// <summary>
    /// Optional. The configuration settings for Cloud SQL instance used internally by Apache
    /// Airflow software.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.DatabaseConfig DatabaseConfig {
      get { return databaseConfig_; }
      set {
        databaseConfig_ = value;
      }
    }

    /// <summary>Field number for the "web_server_config" field.</summary>
    public const int WebServerConfigFieldNumber = 10;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerConfig webServerConfig_;
    /// <summary>
    /// Optional. The configuration settings for the Airflow web server App Engine instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerConfig WebServerConfig {
      get { return webServerConfig_; }
      set {
        webServerConfig_ = value;
      }
    }

    /// <summary>Field number for the "encryption_config" field.</summary>
    public const int EncryptionConfigFieldNumber = 11;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.EncryptionConfig encryptionConfig_;
    /// <summary>
    /// Optional. The encryption options for the Cloud Composer environment
    /// and its dependencies. Cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.EncryptionConfig EncryptionConfig {
      get { return encryptionConfig_; }
      set {
        encryptionConfig_ = value;
      }
    }

    /// <summary>Field number for the "airflow_uri" field.</summary>
    public const int AirflowUriFieldNumber = 6;
    private string airflowUri_ = "";
    /// <summary>
    /// Output only. The URI of the Apache Airflow Web UI hosted within this environment (see
    /// [Airflow web
    /// interface](/composer/docs/how-to/accessing/airflow-web-interface)).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AirflowUri {
      get { return airflowUri_; }
      set {
        airflowUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EnvironmentConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EnvironmentConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GkeCluster != other.GkeCluster) return false;
      if (DagGcsPrefix != other.DagGcsPrefix) return false;
      if (NodeCount != other.NodeCount) return false;
      if (!object.Equals(SoftwareConfig, other.SoftwareConfig)) return false;
      if (!object.Equals(NodeConfig, other.NodeConfig)) return false;
      if (!object.Equals(PrivateEnvironmentConfig, other.PrivateEnvironmentConfig)) return false;
      if (!object.Equals(WebServerNetworkAccessControl, other.WebServerNetworkAccessControl)) return false;
      if (!object.Equals(DatabaseConfig, other.DatabaseConfig)) return false;
      if (!object.Equals(WebServerConfig, other.WebServerConfig)) return false;
      if (!object.Equals(EncryptionConfig, other.EncryptionConfig)) return false;
      if (AirflowUri != other.AirflowUri) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (GkeCluster.Length != 0) hash ^= GkeCluster.GetHashCode();
      if (DagGcsPrefix.Length != 0) hash ^= DagGcsPrefix.GetHashCode();
      if (NodeCount != 0) hash ^= NodeCount.GetHashCode();
      if (softwareConfig_ != null) hash ^= SoftwareConfig.GetHashCode();
      if (nodeConfig_ != null) hash ^= NodeConfig.GetHashCode();
      if (privateEnvironmentConfig_ != null) hash ^= PrivateEnvironmentConfig.GetHashCode();
      if (webServerNetworkAccessControl_ != null) hash ^= WebServerNetworkAccessControl.GetHashCode();
      if (databaseConfig_ != null) hash ^= DatabaseConfig.GetHashCode();
      if (webServerConfig_ != null) hash ^= WebServerConfig.GetHashCode();
      if (encryptionConfig_ != null) hash ^= EncryptionConfig.GetHashCode();
      if (AirflowUri.Length != 0) hash ^= AirflowUri.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (GkeCluster.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(GkeCluster);
      }
      if (DagGcsPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DagGcsPrefix);
      }
      if (NodeCount != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(NodeCount);
      }
      if (softwareConfig_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SoftwareConfig);
      }
      if (nodeConfig_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(NodeConfig);
      }
      if (AirflowUri.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(AirflowUri);
      }
      if (privateEnvironmentConfig_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(PrivateEnvironmentConfig);
      }
      if (webServerNetworkAccessControl_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(WebServerNetworkAccessControl);
      }
      if (databaseConfig_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(DatabaseConfig);
      }
      if (webServerConfig_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(WebServerConfig);
      }
      if (encryptionConfig_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(EncryptionConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (GkeCluster.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(GkeCluster);
      }
      if (DagGcsPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DagGcsPrefix);
      }
      if (NodeCount != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(NodeCount);
      }
      if (softwareConfig_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SoftwareConfig);
      }
      if (nodeConfig_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(NodeConfig);
      }
      if (AirflowUri.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(AirflowUri);
      }
      if (privateEnvironmentConfig_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(PrivateEnvironmentConfig);
      }
      if (webServerNetworkAccessControl_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(WebServerNetworkAccessControl);
      }
      if (databaseConfig_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(DatabaseConfig);
      }
      if (webServerConfig_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(WebServerConfig);
      }
      if (encryptionConfig_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(EncryptionConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (GkeCluster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GkeCluster);
      }
      if (DagGcsPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DagGcsPrefix);
      }
      if (NodeCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NodeCount);
      }
      if (softwareConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SoftwareConfig);
      }
      if (nodeConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodeConfig);
      }
      if (privateEnvironmentConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrivateEnvironmentConfig);
      }
      if (webServerNetworkAccessControl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WebServerNetworkAccessControl);
      }
      if (databaseConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DatabaseConfig);
      }
      if (webServerConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WebServerConfig);
      }
      if (encryptionConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EncryptionConfig);
      }
      if (AirflowUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AirflowUri);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EnvironmentConfig other) {
      if (other == null) {
        return;
      }
      if (other.GkeCluster.Length != 0) {
        GkeCluster = other.GkeCluster;
      }
      if (other.DagGcsPrefix.Length != 0) {
        DagGcsPrefix = other.DagGcsPrefix;
      }
      if (other.NodeCount != 0) {
        NodeCount = other.NodeCount;
      }
      if (other.softwareConfig_ != null) {
        if (softwareConfig_ == null) {
          SoftwareConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.SoftwareConfig();
        }
        SoftwareConfig.MergeFrom(other.SoftwareConfig);
      }
      if (other.nodeConfig_ != null) {
        if (nodeConfig_ == null) {
          NodeConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.NodeConfig();
        }
        NodeConfig.MergeFrom(other.NodeConfig);
      }
      if (other.privateEnvironmentConfig_ != null) {
        if (privateEnvironmentConfig_ == null) {
          PrivateEnvironmentConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateEnvironmentConfig();
        }
        PrivateEnvironmentConfig.MergeFrom(other.PrivateEnvironmentConfig);
      }
      if (other.webServerNetworkAccessControl_ != null) {
        if (webServerNetworkAccessControl_ == null) {
          WebServerNetworkAccessControl = new global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl();
        }
        WebServerNetworkAccessControl.MergeFrom(other.WebServerNetworkAccessControl);
      }
      if (other.databaseConfig_ != null) {
        if (databaseConfig_ == null) {
          DatabaseConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.DatabaseConfig();
        }
        DatabaseConfig.MergeFrom(other.DatabaseConfig);
      }
      if (other.webServerConfig_ != null) {
        if (webServerConfig_ == null) {
          WebServerConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerConfig();
        }
        WebServerConfig.MergeFrom(other.WebServerConfig);
      }
      if (other.encryptionConfig_ != null) {
        if (encryptionConfig_ == null) {
          EncryptionConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.EncryptionConfig();
        }
        EncryptionConfig.MergeFrom(other.EncryptionConfig);
      }
      if (other.AirflowUri.Length != 0) {
        AirflowUri = other.AirflowUri;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            GkeCluster = input.ReadString();
            break;
          }
          case 18: {
            DagGcsPrefix = input.ReadString();
            break;
          }
          case 24: {
            NodeCount = input.ReadInt32();
            break;
          }
          case 34: {
            if (softwareConfig_ == null) {
              SoftwareConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.SoftwareConfig();
            }
            input.ReadMessage(SoftwareConfig);
            break;
          }
          case 42: {
            if (nodeConfig_ == null) {
              NodeConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.NodeConfig();
            }
            input.ReadMessage(NodeConfig);
            break;
          }
          case 50: {
            AirflowUri = input.ReadString();
            break;
          }
          case 58: {
            if (privateEnvironmentConfig_ == null) {
              PrivateEnvironmentConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateEnvironmentConfig();
            }
            input.ReadMessage(PrivateEnvironmentConfig);
            break;
          }
          case 66: {
            if (webServerNetworkAccessControl_ == null) {
              WebServerNetworkAccessControl = new global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl();
            }
            input.ReadMessage(WebServerNetworkAccessControl);
            break;
          }
          case 74: {
            if (databaseConfig_ == null) {
              DatabaseConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.DatabaseConfig();
            }
            input.ReadMessage(DatabaseConfig);
            break;
          }
          case 82: {
            if (webServerConfig_ == null) {
              WebServerConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerConfig();
            }
            input.ReadMessage(WebServerConfig);
            break;
          }
          case 90: {
            if (encryptionConfig_ == null) {
              EncryptionConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.EncryptionConfig();
            }
            input.ReadMessage(EncryptionConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            GkeCluster = input.ReadString();
            break;
          }
          case 18: {
            DagGcsPrefix = input.ReadString();
            break;
          }
          case 24: {
            NodeCount = input.ReadInt32();
            break;
          }
          case 34: {
            if (softwareConfig_ == null) {
              SoftwareConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.SoftwareConfig();
            }
            input.ReadMessage(SoftwareConfig);
            break;
          }
          case 42: {
            if (nodeConfig_ == null) {
              NodeConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.NodeConfig();
            }
            input.ReadMessage(NodeConfig);
            break;
          }
          case 50: {
            AirflowUri = input.ReadString();
            break;
          }
          case 58: {
            if (privateEnvironmentConfig_ == null) {
              PrivateEnvironmentConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateEnvironmentConfig();
            }
            input.ReadMessage(PrivateEnvironmentConfig);
            break;
          }
          case 66: {
            if (webServerNetworkAccessControl_ == null) {
              WebServerNetworkAccessControl = new global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl();
            }
            input.ReadMessage(WebServerNetworkAccessControl);
            break;
          }
          case 74: {
            if (databaseConfig_ == null) {
              DatabaseConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.DatabaseConfig();
            }
            input.ReadMessage(DatabaseConfig);
            break;
          }
          case 82: {
            if (webServerConfig_ == null) {
              WebServerConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerConfig();
            }
            input.ReadMessage(WebServerConfig);
            break;
          }
          case 90: {
            if (encryptionConfig_ == null) {
              EncryptionConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.EncryptionConfig();
            }
            input.ReadMessage(EncryptionConfig);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Network-level access control policy for the Airflow web server.
  /// </summary>
  public sealed partial class WebServerNetworkAccessControl : pb::IMessage<WebServerNetworkAccessControl>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WebServerNetworkAccessControl> _parser = new pb::MessageParser<WebServerNetworkAccessControl>(() => new WebServerNetworkAccessControl());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WebServerNetworkAccessControl> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WebServerNetworkAccessControl() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WebServerNetworkAccessControl(WebServerNetworkAccessControl other) : this() {
      allowedIpRanges_ = other.allowedIpRanges_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WebServerNetworkAccessControl Clone() {
      return new WebServerNetworkAccessControl(this);
    }

    /// <summary>Field number for the "allowed_ip_ranges" field.</summary>
    public const int AllowedIpRangesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Types.AllowedIpRange> _repeated_allowedIpRanges_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Types.AllowedIpRange.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Types.AllowedIpRange> allowedIpRanges_ = new pbc::RepeatedField<global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Types.AllowedIpRange>();
    /// <summary>
    /// A collection of allowed IP ranges with descriptions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Types.AllowedIpRange> AllowedIpRanges {
      get { return allowedIpRanges_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WebServerNetworkAccessControl);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WebServerNetworkAccessControl other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!allowedIpRanges_.Equals(other.allowedIpRanges_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= allowedIpRanges_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      allowedIpRanges_.WriteTo(output, _repeated_allowedIpRanges_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      allowedIpRanges_.WriteTo(ref output, _repeated_allowedIpRanges_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += allowedIpRanges_.CalculateSize(_repeated_allowedIpRanges_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WebServerNetworkAccessControl other) {
      if (other == null) {
        return;
      }
      allowedIpRanges_.Add(other.allowedIpRanges_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            allowedIpRanges_.AddEntriesFrom(input, _repeated_allowedIpRanges_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            allowedIpRanges_.AddEntriesFrom(ref input, _repeated_allowedIpRanges_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the WebServerNetworkAccessControl message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Allowed IP range with user-provided description.
      /// </summary>
      public sealed partial class AllowedIpRange : pb::IMessage<AllowedIpRange>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AllowedIpRange> _parser = new pb::MessageParser<AllowedIpRange>(() => new AllowedIpRange());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AllowedIpRange> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.WebServerNetworkAccessControl.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AllowedIpRange() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AllowedIpRange(AllowedIpRange other) : this() {
          value_ = other.value_;
          description_ = other.description_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AllowedIpRange Clone() {
          return new AllowedIpRange(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private string value_ = "";
        /// <summary>
        /// IP address or range, defined using CIDR notation, of requests that this
        /// rule applies to.
        /// Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32`
        ///           or `2001:0db8:0000:0042:0000:8a2e:0370:7334`.
        ///
        /// IP range prefixes should be properly truncated. For example,
        /// `1.2.3.4/24` should be truncated to `1.2.3.0/24`. Similarly, for IPv6,
        /// `2001:db8::1/32` should be truncated to `2001:db8::/32`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Value {
          get { return value_; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "description" field.</summary>
        public const int DescriptionFieldNumber = 2;
        private string description_ = "";
        /// <summary>
        /// Optional. User-provided description. It must contain at most 300 characters.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Description {
          get { return description_; }
          set {
            description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AllowedIpRange);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AllowedIpRange other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Value != other.Value) return false;
          if (Description != other.Description) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Value.Length != 0) hash ^= Value.GetHashCode();
          if (Description.Length != 0) hash ^= Description.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Value.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Value);
          }
          if (Description.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Description);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Value.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Value);
          }
          if (Description.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Description);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Value.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
          }
          if (Description.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AllowedIpRange other) {
          if (other == null) {
            return;
          }
          if (other.Value.Length != 0) {
            Value = other.Value;
          }
          if (other.Description.Length != 0) {
            Description = other.Description;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Value = input.ReadString();
                break;
              }
              case 18: {
                Description = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Value = input.ReadString();
                break;
              }
              case 18: {
                Description = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// The configuration of Cloud SQL instance that is used by the Apache Airflow
  /// software.
  /// </summary>
  public sealed partial class DatabaseConfig : pb::IMessage<DatabaseConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DatabaseConfig> _parser = new pb::MessageParser<DatabaseConfig>(() => new DatabaseConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DatabaseConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DatabaseConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DatabaseConfig(DatabaseConfig other) : this() {
      machineType_ = other.machineType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DatabaseConfig Clone() {
      return new DatabaseConfig(this);
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 1;
    private string machineType_ = "";
    /// <summary>
    /// Optional. Cloud SQL machine type used by Airflow database.
    /// It has to be one of: db-n1-standard-2, db-n1-standard-4, db-n1-standard-8
    /// or db-n1-standard-16. If not specified, db-n1-standard-2 will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MachineType {
      get { return machineType_; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DatabaseConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DatabaseConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MachineType != other.MachineType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MachineType.Length != 0) hash ^= MachineType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MachineType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MachineType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MachineType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MachineType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MachineType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DatabaseConfig other) {
      if (other == null) {
        return;
      }
      if (other.MachineType.Length != 0) {
        MachineType = other.MachineType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            MachineType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            MachineType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The configuration settings for the Airflow web server App Engine instance.
  /// </summary>
  public sealed partial class WebServerConfig : pb::IMessage<WebServerConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WebServerConfig> _parser = new pb::MessageParser<WebServerConfig>(() => new WebServerConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WebServerConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WebServerConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WebServerConfig(WebServerConfig other) : this() {
      machineType_ = other.machineType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WebServerConfig Clone() {
      return new WebServerConfig(this);
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 1;
    private string machineType_ = "";
    /// <summary>
    /// Optional. Machine type on which Airflow web server is running.
    /// It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or
    /// composer-n1-webserver-8.
    /// If not specified, composer-n1-webserver-2 will be used.
    /// Value custom is returned only in response, if Airflow web server parameters
    /// were manually changed to a non-standard values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MachineType {
      get { return machineType_; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WebServerConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WebServerConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MachineType != other.MachineType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MachineType.Length != 0) hash ^= MachineType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MachineType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MachineType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MachineType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MachineType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MachineType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WebServerConfig other) {
      if (other == null) {
        return;
      }
      if (other.MachineType.Length != 0) {
        MachineType = other.MachineType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            MachineType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            MachineType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The encryption options for the Cloud Composer environment
  /// and its dependencies.
  /// </summary>
  public sealed partial class EncryptionConfig : pb::IMessage<EncryptionConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EncryptionConfig> _parser = new pb::MessageParser<EncryptionConfig>(() => new EncryptionConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EncryptionConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EncryptionConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EncryptionConfig(EncryptionConfig other) : this() {
      kmsKeyName_ = other.kmsKeyName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EncryptionConfig Clone() {
      return new EncryptionConfig(this);
    }

    /// <summary>Field number for the "kms_key_name" field.</summary>
    public const int KmsKeyNameFieldNumber = 1;
    private string kmsKeyName_ = "";
    /// <summary>
    /// Optional. Customer-managed Encryption Key available through Google's Key Management
    /// Service. Cannot be updated.
    /// If not specified, Google-managed key will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string KmsKeyName {
      get { return kmsKeyName_; }
      set {
        kmsKeyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EncryptionConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EncryptionConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (KmsKeyName != other.KmsKeyName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (KmsKeyName.Length != 0) hash ^= KmsKeyName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (KmsKeyName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(KmsKeyName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (KmsKeyName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(KmsKeyName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (KmsKeyName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KmsKeyName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EncryptionConfig other) {
      if (other == null) {
        return;
      }
      if (other.KmsKeyName.Length != 0) {
        KmsKeyName = other.KmsKeyName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            KmsKeyName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            KmsKeyName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Specifies the selection and configuration of software inside the environment.
  /// </summary>
  public sealed partial class SoftwareConfig : pb::IMessage<SoftwareConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SoftwareConfig> _parser = new pb::MessageParser<SoftwareConfig>(() => new SoftwareConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SoftwareConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SoftwareConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SoftwareConfig(SoftwareConfig other) : this() {
      imageVersion_ = other.imageVersion_;
      airflowConfigOverrides_ = other.airflowConfigOverrides_.Clone();
      pypiPackages_ = other.pypiPackages_.Clone();
      envVariables_ = other.envVariables_.Clone();
      pythonVersion_ = other.pythonVersion_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SoftwareConfig Clone() {
      return new SoftwareConfig(this);
    }

    /// <summary>Field number for the "image_version" field.</summary>
    public const int ImageVersionFieldNumber = 1;
    private string imageVersion_ = "";
    /// <summary>
    /// The version of the software running in the environment.
    /// This encapsulates both the version of Cloud Composer functionality and the
    /// version of Apache Airflow. It must match the regular expression
    /// `composer-([0-9]+\.[0-9]+\.[0-9]+|latest)-airflow-[0-9]+\.[0-9]+(\.[0-9]+.*)?`.
    /// When used as input, the server also checks if the provided version is
    /// supported and denies the request for an unsupported version.
    ///
    /// The Cloud Composer portion of the version is a
    /// [semantic version](https://semver.org) or `latest`. When the patch version
    /// is omitted, the current Cloud Composer patch version is selected.
    /// When `latest` is provided instead of an explicit version number,
    /// the server replaces `latest` with the current Cloud Composer version
    /// and stores that version number in the same field.
    ///
    /// The portion of the image version that follows *airflow-* is an
    /// official Apache Airflow repository
    /// [release name](https://github.com/apache/incubator-airflow/releases).
    ///
    /// See also [Version
    /// List](/composer/docs/concepts/versioning/composer-versions).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ImageVersion {
      get { return imageVersion_; }
      set {
        imageVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "airflow_config_overrides" field.</summary>
    public const int AirflowConfigOverridesFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_airflowConfigOverrides_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 18);
    private readonly pbc::MapField<string, string> airflowConfigOverrides_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Apache Airflow configuration properties to override.
    ///
    /// Property keys contain the section and property names, separated by a
    /// hyphen, for example "core-dags_are_paused_at_creation". Section names must
    /// not contain hyphens ("-"), opening square brackets ("["),  or closing
    /// square brackets ("]"). The property name must not be empty and must not
    /// contain an equals sign ("=") or semicolon (";"). Section and property names
    /// must not contain a period ("."). Apache Airflow configuration property
    /// names must be written in
    /// [snake_case](https://en.wikipedia.org/wiki/Snake_case). Property values can
    /// contain any character, and can be written in any lower/upper case format.
    ///
    /// Certain Apache Airflow configuration property values are
    /// [blocked](/composer/docs/concepts/airflow-configurations),
    /// and cannot be overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> AirflowConfigOverrides {
      get { return airflowConfigOverrides_; }
    }

    /// <summary>Field number for the "pypi_packages" field.</summary>
    public const int PypiPackagesFieldNumber = 3;
    private static readonly pbc::MapField<string, string>.Codec _map_pypiPackages_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 26);
    private readonly pbc::MapField<string, string> pypiPackages_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Custom Python Package Index (PyPI) packages to be installed in
    /// the environment.
    ///
    /// Keys refer to the lowercase package name such as "numpy"
    /// and values are the lowercase extras and version specifier such as
    /// "==1.12.0", "[devel,gcp_api]", or "[devel]>=1.8.2, &lt;1.9.2". To specify a
    /// package without pinning it to a version specifier, use the empty string as
    /// the value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> PypiPackages {
      get { return pypiPackages_; }
    }

    /// <summary>Field number for the "env_variables" field.</summary>
    public const int EnvVariablesFieldNumber = 4;
    private static readonly pbc::MapField<string, string>.Codec _map_envVariables_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 34);
    private readonly pbc::MapField<string, string> envVariables_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Additional environment variables to provide to the Apache Airflow
    /// scheduler, worker, and webserver processes.
    ///
    /// Environment variable names must match the regular expression
    /// `[a-zA-Z_][a-zA-Z0-9_]*`. They cannot specify Apache Airflow
    /// software configuration overrides (they cannot match the regular expression
    /// `AIRFLOW__[A-Z0-9_]+__[A-Z0-9_]+`), and they cannot match any of the
    /// following reserved names:
    ///
    /// * `AIRFLOW_HOME`
    /// * `C_FORCE_ROOT`
    /// * `CONTAINER_NAME`
    /// * `DAGS_FOLDER`
    /// * `GCP_PROJECT`
    /// * `GCS_BUCKET`
    /// * `GKE_CLUSTER_NAME`
    /// * `SQL_DATABASE`
    /// * `SQL_INSTANCE`
    /// * `SQL_PASSWORD`
    /// * `SQL_PROJECT`
    /// * `SQL_REGION`
    /// * `SQL_USER`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> EnvVariables {
      get { return envVariables_; }
    }

    /// <summary>Field number for the "python_version" field.</summary>
    public const int PythonVersionFieldNumber = 6;
    private string pythonVersion_ = "";
    /// <summary>
    /// Optional. The major version of Python used to run the Apache Airflow
    /// scheduler, worker, and webserver processes.
    ///
    /// Can be set to '2' or '3'. If not specified, the default is '3'. Cannot be
    /// updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PythonVersion {
      get { return pythonVersion_; }
      set {
        pythonVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SoftwareConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SoftwareConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ImageVersion != other.ImageVersion) return false;
      if (!AirflowConfigOverrides.Equals(other.AirflowConfigOverrides)) return false;
      if (!PypiPackages.Equals(other.PypiPackages)) return false;
      if (!EnvVariables.Equals(other.EnvVariables)) return false;
      if (PythonVersion != other.PythonVersion) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ImageVersion.Length != 0) hash ^= ImageVersion.GetHashCode();
      hash ^= AirflowConfigOverrides.GetHashCode();
      hash ^= PypiPackages.GetHashCode();
      hash ^= EnvVariables.GetHashCode();
      if (PythonVersion.Length != 0) hash ^= PythonVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ImageVersion.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ImageVersion);
      }
      airflowConfigOverrides_.WriteTo(output, _map_airflowConfigOverrides_codec);
      pypiPackages_.WriteTo(output, _map_pypiPackages_codec);
      envVariables_.WriteTo(output, _map_envVariables_codec);
      if (PythonVersion.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(PythonVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ImageVersion.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ImageVersion);
      }
      airflowConfigOverrides_.WriteTo(ref output, _map_airflowConfigOverrides_codec);
      pypiPackages_.WriteTo(ref output, _map_pypiPackages_codec);
      envVariables_.WriteTo(ref output, _map_envVariables_codec);
      if (PythonVersion.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(PythonVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ImageVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ImageVersion);
      }
      size += airflowConfigOverrides_.CalculateSize(_map_airflowConfigOverrides_codec);
      size += pypiPackages_.CalculateSize(_map_pypiPackages_codec);
      size += envVariables_.CalculateSize(_map_envVariables_codec);
      if (PythonVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PythonVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SoftwareConfig other) {
      if (other == null) {
        return;
      }
      if (other.ImageVersion.Length != 0) {
        ImageVersion = other.ImageVersion;
      }
      airflowConfigOverrides_.Add(other.airflowConfigOverrides_);
      pypiPackages_.Add(other.pypiPackages_);
      envVariables_.Add(other.envVariables_);
      if (other.PythonVersion.Length != 0) {
        PythonVersion = other.PythonVersion;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ImageVersion = input.ReadString();
            break;
          }
          case 18: {
            airflowConfigOverrides_.AddEntriesFrom(input, _map_airflowConfigOverrides_codec);
            break;
          }
          case 26: {
            pypiPackages_.AddEntriesFrom(input, _map_pypiPackages_codec);
            break;
          }
          case 34: {
            envVariables_.AddEntriesFrom(input, _map_envVariables_codec);
            break;
          }
          case 50: {
            PythonVersion = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ImageVersion = input.ReadString();
            break;
          }
          case 18: {
            airflowConfigOverrides_.AddEntriesFrom(ref input, _map_airflowConfigOverrides_codec);
            break;
          }
          case 26: {
            pypiPackages_.AddEntriesFrom(ref input, _map_pypiPackages_codec);
            break;
          }
          case 34: {
            envVariables_.AddEntriesFrom(ref input, _map_envVariables_codec);
            break;
          }
          case 50: {
            PythonVersion = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for controlling how IPs are allocated in the
  /// GKE cluster running the Apache Airflow software.
  /// </summary>
  public sealed partial class IPAllocationPolicy : pb::IMessage<IPAllocationPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IPAllocationPolicy> _parser = new pb::MessageParser<IPAllocationPolicy>(() => new IPAllocationPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<IPAllocationPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IPAllocationPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IPAllocationPolicy(IPAllocationPolicy other) : this() {
      useIpAliases_ = other.useIpAliases_;
      switch (other.ClusterIpAllocationCase) {
        case ClusterIpAllocationOneofCase.ClusterSecondaryRangeName:
          ClusterSecondaryRangeName = other.ClusterSecondaryRangeName;
          break;
        case ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock:
          ClusterIpv4CidrBlock = other.ClusterIpv4CidrBlock;
          break;
      }

      switch (other.ServicesIpAllocationCase) {
        case ServicesIpAllocationOneofCase.ServicesSecondaryRangeName:
          ServicesSecondaryRangeName = other.ServicesSecondaryRangeName;
          break;
        case ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock:
          ServicesIpv4CidrBlock = other.ServicesIpv4CidrBlock;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IPAllocationPolicy Clone() {
      return new IPAllocationPolicy(this);
    }

    /// <summary>Field number for the "use_ip_aliases" field.</summary>
    public const int UseIpAliasesFieldNumber = 1;
    private bool useIpAliases_;
    /// <summary>
    /// Optional. Whether or not to enable Alias IPs in the GKE cluster.
    /// If `true`, a VPC-native cluster is created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseIpAliases {
      get { return useIpAliases_; }
      set {
        useIpAliases_ = value;
      }
    }

    /// <summary>Field number for the "cluster_secondary_range_name" field.</summary>
    public const int ClusterSecondaryRangeNameFieldNumber = 2;
    /// <summary>
    /// Optional. The name of the GKE cluster's secondary range used to allocate
    /// IP addresses to pods.
    ///
    /// This field is applicable only when `use_ip_aliases` is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClusterSecondaryRangeName {
      get { return clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterSecondaryRangeName ? (string) clusterIpAllocation_ : ""; }
      set {
        clusterIpAllocation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterIpAllocationCase_ = ClusterIpAllocationOneofCase.ClusterSecondaryRangeName;
      }
    }

    /// <summary>Field number for the "cluster_ipv4_cidr_block" field.</summary>
    public const int ClusterIpv4CidrBlockFieldNumber = 4;
    /// <summary>
    /// Optional. The IP address range used to allocate IP addresses to pods in
    /// the GKE cluster.
    ///
    /// This field is applicable only when `use_ip_aliases` is true.
    ///
    /// Set to blank to have GKE choose a range with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClusterIpv4CidrBlock {
      get { return clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock ? (string) clusterIpAllocation_ : ""; }
      set {
        clusterIpAllocation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterIpAllocationCase_ = ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock;
      }
    }

    /// <summary>Field number for the "services_secondary_range_name" field.</summary>
    public const int ServicesSecondaryRangeNameFieldNumber = 3;
    /// <summary>
    /// Optional. The name of the services' secondary range used to allocate
    /// IP addresses to the GKE cluster.
    ///
    /// This field is applicable only when `use_ip_aliases` is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ServicesSecondaryRangeName {
      get { return servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesSecondaryRangeName ? (string) servicesIpAllocation_ : ""; }
      set {
        servicesIpAllocation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        servicesIpAllocationCase_ = ServicesIpAllocationOneofCase.ServicesSecondaryRangeName;
      }
    }

    /// <summary>Field number for the "services_ipv4_cidr_block" field.</summary>
    public const int ServicesIpv4CidrBlockFieldNumber = 5;
    /// <summary>
    /// Optional. The IP address range of the services IP addresses in this
    /// GKE cluster.
    ///
    /// This field is applicable only when `use_ip_aliases` is true.
    ///
    /// Set to blank to have GKE choose a range with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ServicesIpv4CidrBlock {
      get { return servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock ? (string) servicesIpAllocation_ : ""; }
      set {
        servicesIpAllocation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        servicesIpAllocationCase_ = ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock;
      }
    }

    private object clusterIpAllocation_;
    /// <summary>Enum of possible cases for the "cluster_ip_allocation" oneof.</summary>
    public enum ClusterIpAllocationOneofCase {
      None = 0,
      ClusterSecondaryRangeName = 2,
      ClusterIpv4CidrBlock = 4,
    }
    private ClusterIpAllocationOneofCase clusterIpAllocationCase_ = ClusterIpAllocationOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterIpAllocationOneofCase ClusterIpAllocationCase {
      get { return clusterIpAllocationCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClusterIpAllocation() {
      clusterIpAllocationCase_ = ClusterIpAllocationOneofCase.None;
      clusterIpAllocation_ = null;
    }

    private object servicesIpAllocation_;
    /// <summary>Enum of possible cases for the "services_ip_allocation" oneof.</summary>
    public enum ServicesIpAllocationOneofCase {
      None = 0,
      ServicesSecondaryRangeName = 3,
      ServicesIpv4CidrBlock = 5,
    }
    private ServicesIpAllocationOneofCase servicesIpAllocationCase_ = ServicesIpAllocationOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServicesIpAllocationOneofCase ServicesIpAllocationCase {
      get { return servicesIpAllocationCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearServicesIpAllocation() {
      servicesIpAllocationCase_ = ServicesIpAllocationOneofCase.None;
      servicesIpAllocation_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as IPAllocationPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(IPAllocationPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (UseIpAliases != other.UseIpAliases) return false;
      if (ClusterSecondaryRangeName != other.ClusterSecondaryRangeName) return false;
      if (ClusterIpv4CidrBlock != other.ClusterIpv4CidrBlock) return false;
      if (ServicesSecondaryRangeName != other.ServicesSecondaryRangeName) return false;
      if (ServicesIpv4CidrBlock != other.ServicesIpv4CidrBlock) return false;
      if (ClusterIpAllocationCase != other.ClusterIpAllocationCase) return false;
      if (ServicesIpAllocationCase != other.ServicesIpAllocationCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (UseIpAliases != false) hash ^= UseIpAliases.GetHashCode();
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterSecondaryRangeName) hash ^= ClusterSecondaryRangeName.GetHashCode();
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock) hash ^= ClusterIpv4CidrBlock.GetHashCode();
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesSecondaryRangeName) hash ^= ServicesSecondaryRangeName.GetHashCode();
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock) hash ^= ServicesIpv4CidrBlock.GetHashCode();
      hash ^= (int) clusterIpAllocationCase_;
      hash ^= (int) servicesIpAllocationCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (UseIpAliases != false) {
        output.WriteRawTag(8);
        output.WriteBool(UseIpAliases);
      }
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterSecondaryRangeName) {
        output.WriteRawTag(18);
        output.WriteString(ClusterSecondaryRangeName);
      }
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesSecondaryRangeName) {
        output.WriteRawTag(26);
        output.WriteString(ServicesSecondaryRangeName);
      }
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock) {
        output.WriteRawTag(34);
        output.WriteString(ClusterIpv4CidrBlock);
      }
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock) {
        output.WriteRawTag(42);
        output.WriteString(ServicesIpv4CidrBlock);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (UseIpAliases != false) {
        output.WriteRawTag(8);
        output.WriteBool(UseIpAliases);
      }
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterSecondaryRangeName) {
        output.WriteRawTag(18);
        output.WriteString(ClusterSecondaryRangeName);
      }
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesSecondaryRangeName) {
        output.WriteRawTag(26);
        output.WriteString(ServicesSecondaryRangeName);
      }
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock) {
        output.WriteRawTag(34);
        output.WriteString(ClusterIpv4CidrBlock);
      }
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock) {
        output.WriteRawTag(42);
        output.WriteString(ServicesIpv4CidrBlock);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (UseIpAliases != false) {
        size += 1 + 1;
      }
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterSecondaryRangeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterSecondaryRangeName);
      }
      if (clusterIpAllocationCase_ == ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterIpv4CidrBlock);
      }
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesSecondaryRangeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServicesSecondaryRangeName);
      }
      if (servicesIpAllocationCase_ == ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServicesIpv4CidrBlock);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(IPAllocationPolicy other) {
      if (other == null) {
        return;
      }
      if (other.UseIpAliases != false) {
        UseIpAliases = other.UseIpAliases;
      }
      switch (other.ClusterIpAllocationCase) {
        case ClusterIpAllocationOneofCase.ClusterSecondaryRangeName:
          ClusterSecondaryRangeName = other.ClusterSecondaryRangeName;
          break;
        case ClusterIpAllocationOneofCase.ClusterIpv4CidrBlock:
          ClusterIpv4CidrBlock = other.ClusterIpv4CidrBlock;
          break;
      }

      switch (other.ServicesIpAllocationCase) {
        case ServicesIpAllocationOneofCase.ServicesSecondaryRangeName:
          ServicesSecondaryRangeName = other.ServicesSecondaryRangeName;
          break;
        case ServicesIpAllocationOneofCase.ServicesIpv4CidrBlock:
          ServicesIpv4CidrBlock = other.ServicesIpv4CidrBlock;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            UseIpAliases = input.ReadBool();
            break;
          }
          case 18: {
            ClusterSecondaryRangeName = input.ReadString();
            break;
          }
          case 26: {
            ServicesSecondaryRangeName = input.ReadString();
            break;
          }
          case 34: {
            ClusterIpv4CidrBlock = input.ReadString();
            break;
          }
          case 42: {
            ServicesIpv4CidrBlock = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            UseIpAliases = input.ReadBool();
            break;
          }
          case 18: {
            ClusterSecondaryRangeName = input.ReadString();
            break;
          }
          case 26: {
            ServicesSecondaryRangeName = input.ReadString();
            break;
          }
          case 34: {
            ClusterIpv4CidrBlock = input.ReadString();
            break;
          }
          case 42: {
            ServicesIpv4CidrBlock = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The configuration information for the Kubernetes Engine nodes running
  /// the Apache Airflow software.
  /// </summary>
  public sealed partial class NodeConfig : pb::IMessage<NodeConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeConfig> _parser = new pb::MessageParser<NodeConfig>(() => new NodeConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeConfig(NodeConfig other) : this() {
      location_ = other.location_;
      machineType_ = other.machineType_;
      network_ = other.network_;
      subnetwork_ = other.subnetwork_;
      diskSizeGb_ = other.diskSizeGb_;
      oauthScopes_ = other.oauthScopes_.Clone();
      serviceAccount_ = other.serviceAccount_;
      tags_ = other.tags_.Clone();
      ipAllocationPolicy_ = other.ipAllocationPolicy_ != null ? other.ipAllocationPolicy_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeConfig Clone() {
      return new NodeConfig(this);
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 1;
    private string location_ = "";
    /// <summary>
    /// Optional. The Compute Engine [zone](/compute/docs/regions-zones) in which
    /// to deploy the VMs used to run the Apache Airflow software, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/zones/{zoneId}".
    ///
    /// This `location` must belong to the enclosing environment's project and
    /// location. If both this field and `nodeConfig.machineType` are specified,
    /// `nodeConfig.machineType` must belong to this `location`; if both are
    /// unspecified, the service will pick a zone in the Compute Engine region
    /// corresponding to the Cloud Composer location, and propagate that choice to
    /// both fields. If only one field (`location` or `nodeConfig.machineType`) is
    /// specified, the location information from the specified field will be
    /// propagated to the unspecified field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 2;
    private string machineType_ = "";
    /// <summary>
    /// Optional. The Compute Engine
    /// [machine type](/compute/docs/machine-types) used for cluster instances,
    /// specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/zones/{zoneId}/machineTypes/{machineTypeId}".
    ///
    /// The `machineType` must belong to the enclosing environment's project and
    /// location. If both this field and `nodeConfig.location` are specified,
    /// this `machineType` must belong to the `nodeConfig.location`; if both are
    /// unspecified, the service will pick a zone in the Compute Engine region
    /// corresponding to the Cloud Composer location, and propagate that choice to
    /// both fields. If exactly one of this field and `nodeConfig.location` is
    /// specified, the location information from the specified field will be
    /// propagated to the unspecified field.
    ///
    /// The `machineTypeId` must not be a [shared-core machine
    /// type](/compute/docs/machine-types#sharedcore).
    ///
    /// If this field is unspecified, the `machineTypeId` defaults
    /// to "n1-standard-1".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MachineType {
      get { return machineType_; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "network" field.</summary>
    public const int NetworkFieldNumber = 3;
    private string network_ = "";
    /// <summary>
    /// Optional. The Compute Engine network to be used for machine
    /// communications, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/global/networks/{networkId}".
    ///
    /// If unspecified, the "default" network ID in the environment's project is
    /// used. If a [Custom Subnet Network](/vpc/docs/vpc#vpc_networks_and_subnets)
    /// is provided, `nodeConfig.subnetwork` must also be provided. For
    /// [Shared VPC](/vpc/docs/shared-vpc) subnetwork requirements, see
    /// `nodeConfig.subnetwork`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Network {
      get { return network_; }
      set {
        network_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "subnetwork" field.</summary>
    public const int SubnetworkFieldNumber = 4;
    private string subnetwork_ = "";
    /// <summary>
    /// Optional. The Compute Engine subnetwork to be used for machine
    /// communications, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/regions/{regionId}/subnetworks/{subnetworkId}"
    ///
    /// If a subnetwork is provided, `nodeConfig.network` must also be provided,
    /// and the subnetwork must belong to the enclosing environment's project and
    /// location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Subnetwork {
      get { return subnetwork_; }
      set {
        subnetwork_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "disk_size_gb" field.</summary>
    public const int DiskSizeGbFieldNumber = 5;
    private int diskSizeGb_;
    /// <summary>
    /// Optional. The disk size in GB used for node VMs. Minimum size is 20GB.
    /// If unspecified, defaults to 100GB. Cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DiskSizeGb {
      get { return diskSizeGb_; }
      set {
        diskSizeGb_ = value;
      }
    }

    /// <summary>Field number for the "oauth_scopes" field.</summary>
    public const int OauthScopesFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_oauthScopes_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> oauthScopes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. The set of Google API scopes to be made available on all
    /// node VMs. If `oauth_scopes` is empty, defaults to
    /// ["https://www.googleapis.com/auth/cloud-platform"]. Cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> OauthScopes {
      get { return oauthScopes_; }
    }

    /// <summary>Field number for the "service_account" field.</summary>
    public const int ServiceAccountFieldNumber = 7;
    private string serviceAccount_ = "";
    /// <summary>
    /// Optional. The Google Cloud Platform Service Account to be used by the node
    /// VMs. If a service account is not specified, the "default" Compute Engine
    /// service account is used. Cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ServiceAccount {
      get { return serviceAccount_; }
      set {
        serviceAccount_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tags" field.</summary>
    public const int TagsFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_tags_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> tags_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. The list of instance tags applied to all node VMs. Tags are used
    /// to identify valid sources or targets for network firewalls. Each tag within
    /// the list must comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Tags {
      get { return tags_; }
    }

    /// <summary>Field number for the "ip_allocation_policy" field.</summary>
    public const int IpAllocationPolicyFieldNumber = 9;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.IPAllocationPolicy ipAllocationPolicy_;
    /// <summary>
    /// Optional. The configuration for controlling how IPs are allocated in the GKE cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.IPAllocationPolicy IpAllocationPolicy {
      get { return ipAllocationPolicy_; }
      set {
        ipAllocationPolicy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Location != other.Location) return false;
      if (MachineType != other.MachineType) return false;
      if (Network != other.Network) return false;
      if (Subnetwork != other.Subnetwork) return false;
      if (DiskSizeGb != other.DiskSizeGb) return false;
      if(!oauthScopes_.Equals(other.oauthScopes_)) return false;
      if (ServiceAccount != other.ServiceAccount) return false;
      if(!tags_.Equals(other.tags_)) return false;
      if (!object.Equals(IpAllocationPolicy, other.IpAllocationPolicy)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Location.Length != 0) hash ^= Location.GetHashCode();
      if (MachineType.Length != 0) hash ^= MachineType.GetHashCode();
      if (Network.Length != 0) hash ^= Network.GetHashCode();
      if (Subnetwork.Length != 0) hash ^= Subnetwork.GetHashCode();
      if (DiskSizeGb != 0) hash ^= DiskSizeGb.GetHashCode();
      hash ^= oauthScopes_.GetHashCode();
      if (ServiceAccount.Length != 0) hash ^= ServiceAccount.GetHashCode();
      hash ^= tags_.GetHashCode();
      if (ipAllocationPolicy_ != null) hash ^= IpAllocationPolicy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Location.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Location);
      }
      if (MachineType.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(MachineType);
      }
      if (Network.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Network);
      }
      if (Subnetwork.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Subnetwork);
      }
      if (DiskSizeGb != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(DiskSizeGb);
      }
      oauthScopes_.WriteTo(output, _repeated_oauthScopes_codec);
      if (ServiceAccount.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(ServiceAccount);
      }
      tags_.WriteTo(output, _repeated_tags_codec);
      if (ipAllocationPolicy_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(IpAllocationPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Location.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Location);
      }
      if (MachineType.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(MachineType);
      }
      if (Network.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Network);
      }
      if (Subnetwork.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Subnetwork);
      }
      if (DiskSizeGb != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(DiskSizeGb);
      }
      oauthScopes_.WriteTo(ref output, _repeated_oauthScopes_codec);
      if (ServiceAccount.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(ServiceAccount);
      }
      tags_.WriteTo(ref output, _repeated_tags_codec);
      if (ipAllocationPolicy_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(IpAllocationPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Location);
      }
      if (MachineType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      if (Network.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Network);
      }
      if (Subnetwork.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Subnetwork);
      }
      if (DiskSizeGb != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DiskSizeGb);
      }
      size += oauthScopes_.CalculateSize(_repeated_oauthScopes_codec);
      if (ServiceAccount.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceAccount);
      }
      size += tags_.CalculateSize(_repeated_tags_codec);
      if (ipAllocationPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IpAllocationPolicy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeConfig other) {
      if (other == null) {
        return;
      }
      if (other.Location.Length != 0) {
        Location = other.Location;
      }
      if (other.MachineType.Length != 0) {
        MachineType = other.MachineType;
      }
      if (other.Network.Length != 0) {
        Network = other.Network;
      }
      if (other.Subnetwork.Length != 0) {
        Subnetwork = other.Subnetwork;
      }
      if (other.DiskSizeGb != 0) {
        DiskSizeGb = other.DiskSizeGb;
      }
      oauthScopes_.Add(other.oauthScopes_);
      if (other.ServiceAccount.Length != 0) {
        ServiceAccount = other.ServiceAccount;
      }
      tags_.Add(other.tags_);
      if (other.ipAllocationPolicy_ != null) {
        if (ipAllocationPolicy_ == null) {
          IpAllocationPolicy = new global::Google.Cloud.Orchestration.Airflow.Service.V1.IPAllocationPolicy();
        }
        IpAllocationPolicy.MergeFrom(other.IpAllocationPolicy);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Location = input.ReadString();
            break;
          }
          case 18: {
            MachineType = input.ReadString();
            break;
          }
          case 26: {
            Network = input.ReadString();
            break;
          }
          case 34: {
            Subnetwork = input.ReadString();
            break;
          }
          case 40: {
            DiskSizeGb = input.ReadInt32();
            break;
          }
          case 50: {
            oauthScopes_.AddEntriesFrom(input, _repeated_oauthScopes_codec);
            break;
          }
          case 58: {
            ServiceAccount = input.ReadString();
            break;
          }
          case 66: {
            tags_.AddEntriesFrom(input, _repeated_tags_codec);
            break;
          }
          case 74: {
            if (ipAllocationPolicy_ == null) {
              IpAllocationPolicy = new global::Google.Cloud.Orchestration.Airflow.Service.V1.IPAllocationPolicy();
            }
            input.ReadMessage(IpAllocationPolicy);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Location = input.ReadString();
            break;
          }
          case 18: {
            MachineType = input.ReadString();
            break;
          }
          case 26: {
            Network = input.ReadString();
            break;
          }
          case 34: {
            Subnetwork = input.ReadString();
            break;
          }
          case 40: {
            DiskSizeGb = input.ReadInt32();
            break;
          }
          case 50: {
            oauthScopes_.AddEntriesFrom(ref input, _repeated_oauthScopes_codec);
            break;
          }
          case 58: {
            ServiceAccount = input.ReadString();
            break;
          }
          case 66: {
            tags_.AddEntriesFrom(ref input, _repeated_tags_codec);
            break;
          }
          case 74: {
            if (ipAllocationPolicy_ == null) {
              IpAllocationPolicy = new global::Google.Cloud.Orchestration.Airflow.Service.V1.IPAllocationPolicy();
            }
            input.ReadMessage(IpAllocationPolicy);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration options for the private GKE cluster in a Cloud Composer
  /// environment.
  /// </summary>
  public sealed partial class PrivateClusterConfig : pb::IMessage<PrivateClusterConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PrivateClusterConfig> _parser = new pb::MessageParser<PrivateClusterConfig>(() => new PrivateClusterConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PrivateClusterConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrivateClusterConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrivateClusterConfig(PrivateClusterConfig other) : this() {
      enablePrivateEndpoint_ = other.enablePrivateEndpoint_;
      masterIpv4CidrBlock_ = other.masterIpv4CidrBlock_;
      masterIpv4ReservedRange_ = other.masterIpv4ReservedRange_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrivateClusterConfig Clone() {
      return new PrivateClusterConfig(this);
    }

    /// <summary>Field number for the "enable_private_endpoint" field.</summary>
    public const int EnablePrivateEndpointFieldNumber = 1;
    private bool enablePrivateEndpoint_;
    /// <summary>
    /// Optional. If `true`, access to the public endpoint of the GKE cluster is
    /// denied.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnablePrivateEndpoint {
      get { return enablePrivateEndpoint_; }
      set {
        enablePrivateEndpoint_ = value;
      }
    }

    /// <summary>Field number for the "master_ipv4_cidr_block" field.</summary>
    public const int MasterIpv4CidrBlockFieldNumber = 2;
    private string masterIpv4CidrBlock_ = "";
    /// <summary>
    /// Optional. The CIDR block from which IPv4 range for GKE master will be reserved. If
    /// left blank, the default value of '172.16.0.0/23' is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MasterIpv4CidrBlock {
      get { return masterIpv4CidrBlock_; }
      set {
        masterIpv4CidrBlock_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "master_ipv4_reserved_range" field.</summary>
    public const int MasterIpv4ReservedRangeFieldNumber = 3;
    private string masterIpv4ReservedRange_ = "";
    /// <summary>
    /// Output only. The IP range in CIDR notation to use for the hosted master network. This
    /// range is used for assigning internal IP addresses to the GKE cluster
    /// master or set of masters and to the internal load balancer virtual IP.
    /// This range must not overlap with any other ranges in use
    /// within the cluster's network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MasterIpv4ReservedRange {
      get { return masterIpv4ReservedRange_; }
      set {
        masterIpv4ReservedRange_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PrivateClusterConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PrivateClusterConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnablePrivateEndpoint != other.EnablePrivateEndpoint) return false;
      if (MasterIpv4CidrBlock != other.MasterIpv4CidrBlock) return false;
      if (MasterIpv4ReservedRange != other.MasterIpv4ReservedRange) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (EnablePrivateEndpoint != false) hash ^= EnablePrivateEndpoint.GetHashCode();
      if (MasterIpv4CidrBlock.Length != 0) hash ^= MasterIpv4CidrBlock.GetHashCode();
      if (MasterIpv4ReservedRange.Length != 0) hash ^= MasterIpv4ReservedRange.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (EnablePrivateEndpoint != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnablePrivateEndpoint);
      }
      if (MasterIpv4CidrBlock.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(MasterIpv4CidrBlock);
      }
      if (MasterIpv4ReservedRange.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(MasterIpv4ReservedRange);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (EnablePrivateEndpoint != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnablePrivateEndpoint);
      }
      if (MasterIpv4CidrBlock.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(MasterIpv4CidrBlock);
      }
      if (MasterIpv4ReservedRange.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(MasterIpv4ReservedRange);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (EnablePrivateEndpoint != false) {
        size += 1 + 1;
      }
      if (MasterIpv4CidrBlock.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MasterIpv4CidrBlock);
      }
      if (MasterIpv4ReservedRange.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MasterIpv4ReservedRange);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PrivateClusterConfig other) {
      if (other == null) {
        return;
      }
      if (other.EnablePrivateEndpoint != false) {
        EnablePrivateEndpoint = other.EnablePrivateEndpoint;
      }
      if (other.MasterIpv4CidrBlock.Length != 0) {
        MasterIpv4CidrBlock = other.MasterIpv4CidrBlock;
      }
      if (other.MasterIpv4ReservedRange.Length != 0) {
        MasterIpv4ReservedRange = other.MasterIpv4ReservedRange;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EnablePrivateEndpoint = input.ReadBool();
            break;
          }
          case 18: {
            MasterIpv4CidrBlock = input.ReadString();
            break;
          }
          case 26: {
            MasterIpv4ReservedRange = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EnablePrivateEndpoint = input.ReadBool();
            break;
          }
          case 18: {
            MasterIpv4CidrBlock = input.ReadString();
            break;
          }
          case 26: {
            MasterIpv4ReservedRange = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The configuration information for configuring a Private IP Cloud Composer
  /// environment.
  /// </summary>
  public sealed partial class PrivateEnvironmentConfig : pb::IMessage<PrivateEnvironmentConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PrivateEnvironmentConfig> _parser = new pb::MessageParser<PrivateEnvironmentConfig>(() => new PrivateEnvironmentConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PrivateEnvironmentConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrivateEnvironmentConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrivateEnvironmentConfig(PrivateEnvironmentConfig other) : this() {
      enablePrivateEnvironment_ = other.enablePrivateEnvironment_;
      privateClusterConfig_ = other.privateClusterConfig_ != null ? other.privateClusterConfig_.Clone() : null;
      webServerIpv4CidrBlock_ = other.webServerIpv4CidrBlock_;
      cloudSqlIpv4CidrBlock_ = other.cloudSqlIpv4CidrBlock_;
      webServerIpv4ReservedRange_ = other.webServerIpv4ReservedRange_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrivateEnvironmentConfig Clone() {
      return new PrivateEnvironmentConfig(this);
    }

    /// <summary>Field number for the "enable_private_environment" field.</summary>
    public const int EnablePrivateEnvironmentFieldNumber = 1;
    private bool enablePrivateEnvironment_;
    /// <summary>
    /// Optional. If `true`, a Private IP Cloud Composer environment is created.
    /// If this field is set to true, `IPAllocationPolicy.use_ip_aliases` must be
    /// set to true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnablePrivateEnvironment {
      get { return enablePrivateEnvironment_; }
      set {
        enablePrivateEnvironment_ = value;
      }
    }

    /// <summary>Field number for the "private_cluster_config" field.</summary>
    public const int PrivateClusterConfigFieldNumber = 2;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateClusterConfig privateClusterConfig_;
    /// <summary>
    /// Optional. Configuration for the private GKE cluster for a Private IP
    /// Cloud Composer environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateClusterConfig PrivateClusterConfig {
      get { return privateClusterConfig_; }
      set {
        privateClusterConfig_ = value;
      }
    }

    /// <summary>Field number for the "web_server_ipv4_cidr_block" field.</summary>
    public const int WebServerIpv4CidrBlockFieldNumber = 3;
    private string webServerIpv4CidrBlock_ = "";
    /// <summary>
    /// Optional. The CIDR block from which IP range for web server will be reserved. Needs
    /// to be disjoint from `private_cluster_config.master_ipv4_cidr_block` and
    /// `cloud_sql_ipv4_cidr_block`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string WebServerIpv4CidrBlock {
      get { return webServerIpv4CidrBlock_; }
      set {
        webServerIpv4CidrBlock_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cloud_sql_ipv4_cidr_block" field.</summary>
    public const int CloudSqlIpv4CidrBlockFieldNumber = 4;
    private string cloudSqlIpv4CidrBlock_ = "";
    /// <summary>
    /// Optional. The CIDR block from which IP range in tenant project will be reserved for
    /// Cloud SQL. Needs to be disjoint from `web_server_ipv4_cidr_block`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CloudSqlIpv4CidrBlock {
      get { return cloudSqlIpv4CidrBlock_; }
      set {
        cloudSqlIpv4CidrBlock_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "web_server_ipv4_reserved_range" field.</summary>
    public const int WebServerIpv4ReservedRangeFieldNumber = 5;
    private string webServerIpv4ReservedRange_ = "";
    /// <summary>
    /// Output only. The IP range reserved for the tenant project's App Engine VMs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string WebServerIpv4ReservedRange {
      get { return webServerIpv4ReservedRange_; }
      set {
        webServerIpv4ReservedRange_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PrivateEnvironmentConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PrivateEnvironmentConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnablePrivateEnvironment != other.EnablePrivateEnvironment) return false;
      if (!object.Equals(PrivateClusterConfig, other.PrivateClusterConfig)) return false;
      if (WebServerIpv4CidrBlock != other.WebServerIpv4CidrBlock) return false;
      if (CloudSqlIpv4CidrBlock != other.CloudSqlIpv4CidrBlock) return false;
      if (WebServerIpv4ReservedRange != other.WebServerIpv4ReservedRange) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (EnablePrivateEnvironment != false) hash ^= EnablePrivateEnvironment.GetHashCode();
      if (privateClusterConfig_ != null) hash ^= PrivateClusterConfig.GetHashCode();
      if (WebServerIpv4CidrBlock.Length != 0) hash ^= WebServerIpv4CidrBlock.GetHashCode();
      if (CloudSqlIpv4CidrBlock.Length != 0) hash ^= CloudSqlIpv4CidrBlock.GetHashCode();
      if (WebServerIpv4ReservedRange.Length != 0) hash ^= WebServerIpv4ReservedRange.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (EnablePrivateEnvironment != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnablePrivateEnvironment);
      }
      if (privateClusterConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PrivateClusterConfig);
      }
      if (WebServerIpv4CidrBlock.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(WebServerIpv4CidrBlock);
      }
      if (CloudSqlIpv4CidrBlock.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(CloudSqlIpv4CidrBlock);
      }
      if (WebServerIpv4ReservedRange.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(WebServerIpv4ReservedRange);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (EnablePrivateEnvironment != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnablePrivateEnvironment);
      }
      if (privateClusterConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PrivateClusterConfig);
      }
      if (WebServerIpv4CidrBlock.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(WebServerIpv4CidrBlock);
      }
      if (CloudSqlIpv4CidrBlock.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(CloudSqlIpv4CidrBlock);
      }
      if (WebServerIpv4ReservedRange.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(WebServerIpv4ReservedRange);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (EnablePrivateEnvironment != false) {
        size += 1 + 1;
      }
      if (privateClusterConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrivateClusterConfig);
      }
      if (WebServerIpv4CidrBlock.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WebServerIpv4CidrBlock);
      }
      if (CloudSqlIpv4CidrBlock.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CloudSqlIpv4CidrBlock);
      }
      if (WebServerIpv4ReservedRange.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WebServerIpv4ReservedRange);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PrivateEnvironmentConfig other) {
      if (other == null) {
        return;
      }
      if (other.EnablePrivateEnvironment != false) {
        EnablePrivateEnvironment = other.EnablePrivateEnvironment;
      }
      if (other.privateClusterConfig_ != null) {
        if (privateClusterConfig_ == null) {
          PrivateClusterConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateClusterConfig();
        }
        PrivateClusterConfig.MergeFrom(other.PrivateClusterConfig);
      }
      if (other.WebServerIpv4CidrBlock.Length != 0) {
        WebServerIpv4CidrBlock = other.WebServerIpv4CidrBlock;
      }
      if (other.CloudSqlIpv4CidrBlock.Length != 0) {
        CloudSqlIpv4CidrBlock = other.CloudSqlIpv4CidrBlock;
      }
      if (other.WebServerIpv4ReservedRange.Length != 0) {
        WebServerIpv4ReservedRange = other.WebServerIpv4ReservedRange;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EnablePrivateEnvironment = input.ReadBool();
            break;
          }
          case 18: {
            if (privateClusterConfig_ == null) {
              PrivateClusterConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateClusterConfig();
            }
            input.ReadMessage(PrivateClusterConfig);
            break;
          }
          case 26: {
            WebServerIpv4CidrBlock = input.ReadString();
            break;
          }
          case 34: {
            CloudSqlIpv4CidrBlock = input.ReadString();
            break;
          }
          case 42: {
            WebServerIpv4ReservedRange = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EnablePrivateEnvironment = input.ReadBool();
            break;
          }
          case 18: {
            if (privateClusterConfig_ == null) {
              PrivateClusterConfig = new global::Google.Cloud.Orchestration.Airflow.Service.V1.PrivateClusterConfig();
            }
            input.ReadMessage(PrivateClusterConfig);
            break;
          }
          case 26: {
            WebServerIpv4CidrBlock = input.ReadString();
            break;
          }
          case 34: {
            CloudSqlIpv4CidrBlock = input.ReadString();
            break;
          }
          case 42: {
            WebServerIpv4ReservedRange = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// An environment for running orchestration tasks.
  /// </summary>
  public sealed partial class Environment : pb::IMessage<Environment>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Environment> _parser = new pb::MessageParser<Environment>(() => new Environment());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Environment> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Environment() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Environment(Environment other) : this() {
      name_ = other.name_;
      config_ = other.config_ != null ? other.config_.Clone() : null;
      uuid_ = other.uuid_;
      state_ = other.state_;
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Environment Clone() {
      return new Environment(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The resource name of the environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    ///
    /// EnvironmentId must start with a lowercase letter followed by up to 63
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 2;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentConfig config_;
    /// <summary>
    /// Configuration parameters for this environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "uuid" field.</summary>
    public const int UuidFieldNumber = 3;
    private string uuid_ = "";
    /// <summary>
    /// Output only. The UUID (Universally Unique IDentifier) associated with this environment.
    /// This value is generated when the environment is created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Uuid {
      get { return uuid_; }
      set {
        uuid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 4;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State state_ = global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State.Unspecified;
    /// <summary>
    /// The current state of the environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this environment was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this environment was last modified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 7;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 58);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. User-defined labels for this environment.
    /// The labels map can contain no more than 64 entries. Entries of the labels
    /// map are UTF8 strings that comply with the following restrictions:
    ///
    /// * Keys must conform to regexp: [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
    /// * Values must conform to regexp:  [\p{Ll}\p{Lo}\p{N}_-]{0,63}
    /// * Both keys and values are additionally constrained to be &lt;= 128 bytes in
    /// size.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Environment);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Environment other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Config, other.Config)) return false;
      if (Uuid != other.Uuid) return false;
      if (State != other.State) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (config_ != null) hash ^= Config.GetHashCode();
      if (Uuid.Length != 0) hash ^= Uuid.GetHashCode();
      if (State != global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State.Unspecified) hash ^= State.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (config_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Config);
      }
      if (Uuid.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uuid);
      }
      if (State != global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) State);
      }
      if (createTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (config_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Config);
      }
      if (Uuid.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uuid);
      }
      if (State != global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) State);
      }
      if (createTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (Uuid.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uuid);
      }
      if (State != global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Environment other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.Uuid.Length != 0) {
        Uuid = other.Uuid;
      }
      if (other.State != global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State.Unspecified) {
        State = other.State;
      }
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (config_ == null) {
              Config = new global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 26: {
            Uuid = input.ReadString();
            break;
          }
          case 32: {
            State = (global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State) input.ReadEnum();
            break;
          }
          case 42: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 50: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 58: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (config_ == null) {
              Config = new global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 26: {
            Uuid = input.ReadString();
            break;
          }
          case 32: {
            State = (global::Google.Cloud.Orchestration.Airflow.Service.V1.Environment.Types.State) input.ReadEnum();
            break;
          }
          case 42: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 50: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 58: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Environment message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// State of the environment.
      /// </summary>
      public enum State {
        /// <summary>
        /// The state of the environment is unknown.
        /// </summary>
        [pbr::OriginalName("STATE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// The environment is in the process of being created.
        /// </summary>
        [pbr::OriginalName("CREATING")] Creating = 1,
        /// <summary>
        /// The environment is currently running and healthy. It is ready for use.
        /// </summary>
        [pbr::OriginalName("RUNNING")] Running = 2,
        /// <summary>
        /// The environment is being updated. It remains usable but cannot receive
        /// additional update requests or be deleted at this time.
        /// </summary>
        [pbr::OriginalName("UPDATING")] Updating = 3,
        /// <summary>
        /// The environment is undergoing deletion. It cannot be used.
        /// </summary>
        [pbr::OriginalName("DELETING")] Deleting = 4,
        /// <summary>
        /// The environment has encountered an error and cannot be used.
        /// </summary>
        [pbr::OriginalName("ERROR")] Error = 5,
      }

    }
    #endregion

  }

  /// <summary>
  /// Message containing information about the result of an upgrade check
  /// operation.
  /// </summary>
  public sealed partial class CheckUpgradeResponse : pb::IMessage<CheckUpgradeResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CheckUpgradeResponse> _parser = new pb::MessageParser<CheckUpgradeResponse>(() => new CheckUpgradeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CheckUpgradeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Orchestration.Airflow.Service.V1.EnvironmentsReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckUpgradeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckUpgradeResponse(CheckUpgradeResponse other) : this() {
      buildLogUri_ = other.buildLogUri_;
      containsPypiModulesConflict_ = other.containsPypiModulesConflict_;
      pypiConflictBuildLogExtract_ = other.pypiConflictBuildLogExtract_;
      imageVersion_ = other.imageVersion_;
      pypiDependencies_ = other.pypiDependencies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckUpgradeResponse Clone() {
      return new CheckUpgradeResponse(this);
    }

    /// <summary>Field number for the "build_log_uri" field.</summary>
    public const int BuildLogUriFieldNumber = 1;
    private string buildLogUri_ = "";
    /// <summary>
    /// Output only. Url for a docker build log of an upgraded image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BuildLogUri {
      get { return buildLogUri_; }
      set {
        buildLogUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "contains_pypi_modules_conflict" field.</summary>
    public const int ContainsPypiModulesConflictFieldNumber = 4;
    private global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult containsPypiModulesConflict_ = global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult.Unspecified;
    /// <summary>
    /// Output only. Whether build has succeeded or failed on modules conflicts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult ContainsPypiModulesConflict {
      get { return containsPypiModulesConflict_; }
      set {
        containsPypiModulesConflict_ = value;
      }
    }

    /// <summary>Field number for the "pypi_conflict_build_log_extract" field.</summary>
    public const int PypiConflictBuildLogExtractFieldNumber = 3;
    private string pypiConflictBuildLogExtract_ = "";
    /// <summary>
    /// Output only. Extract from a docker image build log containing information about pypi
    /// modules conflicts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PypiConflictBuildLogExtract {
      get { return pypiConflictBuildLogExtract_; }
      set {
        pypiConflictBuildLogExtract_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "image_version" field.</summary>
    public const int ImageVersionFieldNumber = 5;
    private string imageVersion_ = "";
    /// <summary>
    /// Composer image for which the build was happening.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ImageVersion {
      get { return imageVersion_; }
      set {
        imageVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "pypi_dependencies" field.</summary>
    public const int PypiDependenciesFieldNumber = 6;
    private static readonly pbc::MapField<string, string>.Codec _map_pypiDependencies_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 50);
    private readonly pbc::MapField<string, string> pypiDependencies_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Pypi dependencies specified in the environment configuration, at the time
    /// when the build was triggered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> PypiDependencies {
      get { return pypiDependencies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CheckUpgradeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CheckUpgradeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BuildLogUri != other.BuildLogUri) return false;
      if (ContainsPypiModulesConflict != other.ContainsPypiModulesConflict) return false;
      if (PypiConflictBuildLogExtract != other.PypiConflictBuildLogExtract) return false;
      if (ImageVersion != other.ImageVersion) return false;
      if (!PypiDependencies.Equals(other.PypiDependencies)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BuildLogUri.Length != 0) hash ^= BuildLogUri.GetHashCode();
      if (ContainsPypiModulesConflict != global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult.Unspecified) hash ^= ContainsPypiModulesConflict.GetHashCode();
      if (PypiConflictBuildLogExtract.Length != 0) hash ^= PypiConflictBuildLogExtract.GetHashCode();
      if (ImageVersion.Length != 0) hash ^= ImageVersion.GetHashCode();
      hash ^= PypiDependencies.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BuildLogUri.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BuildLogUri);
      }
      if (PypiConflictBuildLogExtract.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(PypiConflictBuildLogExtract);
      }
      if (ContainsPypiModulesConflict != global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ContainsPypiModulesConflict);
      }
      if (ImageVersion.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ImageVersion);
      }
      pypiDependencies_.WriteTo(output, _map_pypiDependencies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BuildLogUri.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BuildLogUri);
      }
      if (PypiConflictBuildLogExtract.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(PypiConflictBuildLogExtract);
      }
      if (ContainsPypiModulesConflict != global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ContainsPypiModulesConflict);
      }
      if (ImageVersion.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ImageVersion);
      }
      pypiDependencies_.WriteTo(ref output, _map_pypiDependencies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BuildLogUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BuildLogUri);
      }
      if (ContainsPypiModulesConflict != global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ContainsPypiModulesConflict);
      }
      if (PypiConflictBuildLogExtract.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PypiConflictBuildLogExtract);
      }
      if (ImageVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ImageVersion);
      }
      size += pypiDependencies_.CalculateSize(_map_pypiDependencies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CheckUpgradeResponse other) {
      if (other == null) {
        return;
      }
      if (other.BuildLogUri.Length != 0) {
        BuildLogUri = other.BuildLogUri;
      }
      if (other.ContainsPypiModulesConflict != global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult.Unspecified) {
        ContainsPypiModulesConflict = other.ContainsPypiModulesConflict;
      }
      if (other.PypiConflictBuildLogExtract.Length != 0) {
        PypiConflictBuildLogExtract = other.PypiConflictBuildLogExtract;
      }
      if (other.ImageVersion.Length != 0) {
        ImageVersion = other.ImageVersion;
      }
      pypiDependencies_.Add(other.pypiDependencies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            BuildLogUri = input.ReadString();
            break;
          }
          case 26: {
            PypiConflictBuildLogExtract = input.ReadString();
            break;
          }
          case 32: {
            ContainsPypiModulesConflict = (global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult) input.ReadEnum();
            break;
          }
          case 42: {
            ImageVersion = input.ReadString();
            break;
          }
          case 50: {
            pypiDependencies_.AddEntriesFrom(input, _map_pypiDependencies_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            BuildLogUri = input.ReadString();
            break;
          }
          case 26: {
            PypiConflictBuildLogExtract = input.ReadString();
            break;
          }
          case 32: {
            ContainsPypiModulesConflict = (global::Google.Cloud.Orchestration.Airflow.Service.V1.CheckUpgradeResponse.Types.ConflictResult) input.ReadEnum();
            break;
          }
          case 42: {
            ImageVersion = input.ReadString();
            break;
          }
          case 50: {
            pypiDependencies_.AddEntriesFrom(ref input, _map_pypiDependencies_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CheckUpgradeResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Whether there were python modules conflict during image build.
      /// </summary>
      public enum ConflictResult {
        /// <summary>
        /// It is unknown whether build had conflicts or not.
        /// </summary>
        [pbr::OriginalName("CONFLICT_RESULT_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// There were python packages conflicts.
        /// </summary>
        [pbr::OriginalName("CONFLICT")] Conflict = 1,
        /// <summary>
        /// There were no python packages conflicts.
        /// </summary>
        [pbr::OriginalName("NO_CONFLICT")] NoConflict = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
