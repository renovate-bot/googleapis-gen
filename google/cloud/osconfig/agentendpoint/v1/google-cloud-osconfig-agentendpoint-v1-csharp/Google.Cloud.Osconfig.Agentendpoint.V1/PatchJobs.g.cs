// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/osconfig/agentendpoint/v1/patch_jobs.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Osconfig.Agentendpoint.V1 {

  /// <summary>Holder for reflection information generated from google/cloud/osconfig/agentendpoint/v1/patch_jobs.proto</summary>
  public static partial class PatchJobsReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/osconfig/agentendpoint/v1/patch_jobs.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PatchJobsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cjdnb29nbGUvY2xvdWQvb3Njb25maWcvYWdlbnRlbmRwb2ludC92MS9wYXRj",
            "aF9qb2JzLnByb3RvEiZnb29nbGUuY2xvdWQub3Njb25maWcuYWdlbnRlbmRw",
            "b2ludC52MSL2BQoLUGF0Y2hDb25maWcSVwoNcmVib290X2NvbmZpZxgBIAEo",
            "DjJALmdvb2dsZS5jbG91ZC5vc2NvbmZpZy5hZ2VudGVuZHBvaW50LnYxLlBh",
            "dGNoQ29uZmlnLlJlYm9vdENvbmZpZxJNCg5yZXRyeV9zdHJhdGVneRgCIAEo",
            "CzI1Lmdvb2dsZS5jbG91ZC5vc2NvbmZpZy5hZ2VudGVuZHBvaW50LnYxLlJl",
            "dHJ5U3RyYXRlZ3kSQAoDYXB0GAMgASgLMjMuZ29vZ2xlLmNsb3VkLm9zY29u",
            "ZmlnLmFnZW50ZW5kcG9pbnQudjEuQXB0U2V0dGluZ3MSQAoDeXVtGAQgASgL",
            "MjMuZ29vZ2xlLmNsb3VkLm9zY29uZmlnLmFnZW50ZW5kcG9pbnQudjEuWXVt",
            "U2V0dGluZ3MSQAoDZ29vGAUgASgLMjMuZ29vZ2xlLmNsb3VkLm9zY29uZmln",
            "LmFnZW50ZW5kcG9pbnQudjEuR29vU2V0dGluZ3MSRgoGenlwcGVyGAYgASgL",
            "MjYuZ29vZ2xlLmNsb3VkLm9zY29uZmlnLmFnZW50ZW5kcG9pbnQudjEuWnlw",
            "cGVyU2V0dGluZ3MSVQoOd2luZG93c191cGRhdGUYByABKAsyPS5nb29nbGUu",
            "Y2xvdWQub3Njb25maWcuYWdlbnRlbmRwb2ludC52MS5XaW5kb3dzVXBkYXRl",
            "U2V0dGluZ3MSQgoIcHJlX3N0ZXAYCCABKAsyMC5nb29nbGUuY2xvdWQub3Nj",
            "b25maWcuYWdlbnRlbmRwb2ludC52MS5FeGVjU3RlcBJDCglwb3N0X3N0ZXAY",
            "CSABKAsyMC5nb29nbGUuY2xvdWQub3Njb25maWcuYWdlbnRlbmRwb2ludC52",
            "MS5FeGVjU3RlcCJRCgxSZWJvb3RDb25maWcSHQoZUkVCT09UX0NPTkZJR19V",
            "TlNQRUNJRklFRBAAEgsKB0RFRkFVTFQQARIKCgZBTFdBWVMQAhIJCgVORVZF",
            "UhADIrgBCgtBcHRTZXR0aW5ncxJGCgR0eXBlGAEgASgOMjguZ29vZ2xlLmNs",
            "b3VkLm9zY29uZmlnLmFnZW50ZW5kcG9pbnQudjEuQXB0U2V0dGluZ3MuVHlw",
            "ZRIQCghleGNsdWRlcxgCIAMoCRIaChJleGNsdXNpdmVfcGFja2FnZXMYAyAD",
            "KAkiMwoEVHlwZRIUChBUWVBFX1VOU1BFQ0lGSUVEEAASCAoERElTVBABEgsK",
            "B1VQR1JBREUQAiJeCgtZdW1TZXR0aW5ncxIQCghzZWN1cml0eRgBIAEoCBIP",
            "CgdtaW5pbWFsGAIgASgIEhAKCGV4Y2x1ZGVzGAMgAygJEhoKEmV4Y2x1c2l2",
            "ZV9wYWNrYWdlcxgEIAMoCSINCgtHb29TZXR0aW5ncyKRAQoOWnlwcGVyU2V0",
            "dGluZ3MSFQoNd2l0aF9vcHRpb25hbBgBIAEoCBITCgt3aXRoX3VwZGF0ZRgC",
            "IAEoCBISCgpjYXRlZ29yaWVzGAMgAygJEhIKCnNldmVyaXRpZXMYBCADKAkS",
            "EAoIZXhjbHVkZXMYBSADKAkSGQoRZXhjbHVzaXZlX3BhdGNoZXMYBiADKAki",
            "4wIKFVdpbmRvd3NVcGRhdGVTZXR0aW5ncxJlCg9jbGFzc2lmaWNhdGlvbnMY",
            "ASADKA4yTC5nb29nbGUuY2xvdWQub3Njb25maWcuYWdlbnRlbmRwb2ludC52",
            "MS5XaW5kb3dzVXBkYXRlU2V0dGluZ3MuQ2xhc3NpZmljYXRpb24SEAoIZXhj",
            "bHVkZXMYAiADKAkSGQoRZXhjbHVzaXZlX3BhdGNoZXMYAyADKAkitQEKDkNs",
            "YXNzaWZpY2F0aW9uEh4KGkNMQVNTSUZJQ0FUSU9OX1VOU1BFQ0lGSUVEEAAS",
            "DAoIQ1JJVElDQUwQARIMCghTRUNVUklUWRACEg4KCkRFRklOSVRJT04QAxIK",
            "CgZEUklWRVIQBBIQCgxGRUFUVVJFX1BBQ0sQBRIQCgxTRVJWSUNFX1BBQ0sQ",
            "BhIICgRUT09MEAcSEQoNVVBEQVRFX1JPTExVUBAIEgoKBlVQREFURRAJIiAK",
            "DVJldHJ5U3RyYXRlZ3kSDwoHZW5hYmxlZBgBIAEoCCK8AQoIRXhlY1N0ZXAS",
            "VgoWbGludXhfZXhlY19zdGVwX2NvbmZpZxgBIAEoCzI2Lmdvb2dsZS5jbG91",
            "ZC5vc2NvbmZpZy5hZ2VudGVuZHBvaW50LnYxLkV4ZWNTdGVwQ29uZmlnElgK",
            "GHdpbmRvd3NfZXhlY19zdGVwX2NvbmZpZxgCIAEoCzI2Lmdvb2dsZS5jbG91",
            "ZC5vc2NvbmZpZy5hZ2VudGVuZHBvaW50LnYxLkV4ZWNTdGVwQ29uZmlnIrwC",
            "Cg5FeGVjU3RlcENvbmZpZxIUCgpsb2NhbF9wYXRoGAEgASgJSAASRwoKZ2Nz",
            "X29iamVjdBgCIAEoCzIxLmdvb2dsZS5jbG91ZC5vc2NvbmZpZy5hZ2VudGVu",
            "ZHBvaW50LnYxLkdjc09iamVjdEgAEh0KFWFsbG93ZWRfc3VjY2Vzc19jb2Rl",
            "cxgDIAMoBRJXCgtpbnRlcnByZXRlchgEIAEoDjJCLmdvb2dsZS5jbG91ZC5v",
            "c2NvbmZpZy5hZ2VudGVuZHBvaW50LnYxLkV4ZWNTdGVwQ29uZmlnLkludGVy",
            "cHJldGVyIkUKC0ludGVycHJldGVyEhsKF0lOVEVSUFJFVEVSX1VOU1BFQ0lG",
            "SUVEEAASCQoFU0hFTEwQARIOCgpQT1dFUlNIRUxMEAJCDAoKZXhlY3V0YWJs",
            "ZSJGCglHY3NPYmplY3QSDgoGYnVja2V0GAEgASgJEg4KBm9iamVjdBgCIAEo",
            "CRIZChFnZW5lcmF0aW9uX251bWJlchgDIAEoA0KMAQoqY29tLmdvb2dsZS5j",
            "bG91ZC5vc2NvbmZpZy5hZ2VudGVuZHBvaW50LnYxQglQYXRjaEpvYnNaU2dv",
            "b2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvY2xvdWQvb3Nj",
            "b25maWcvYWdlbnRlbmRwb2ludC92MTthZ2VudGVuZHBvaW50YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig), global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Parser, new[]{ "RebootConfig", "RetryStrategy", "Apt", "Yum", "Goo", "Zypper", "WindowsUpdate", "PreStep", "PostStep" }, null, new[]{ typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings), global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Parser, new[]{ "Type", "Excludes", "ExclusivePackages" }, null, new[]{ typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.YumSettings), global::Google.Cloud.Osconfig.Agentendpoint.V1.YumSettings.Parser, new[]{ "Security", "Minimal", "Excludes", "ExclusivePackages" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.GooSettings), global::Google.Cloud.Osconfig.Agentendpoint.V1.GooSettings.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.ZypperSettings), global::Google.Cloud.Osconfig.Agentendpoint.V1.ZypperSettings.Parser, new[]{ "WithOptional", "WithUpdate", "Categories", "Severities", "Excludes", "ExclusivePatches" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings), global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings.Parser, new[]{ "Classifications", "Excludes", "ExclusivePatches" }, null, new[]{ typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings.Types.Classification) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.RetryStrategy), global::Google.Cloud.Osconfig.Agentendpoint.V1.RetryStrategy.Parser, new[]{ "Enabled" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep), global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep.Parser, new[]{ "LinuxExecStepConfig", "WindowsExecStepConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig), global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Parser, new[]{ "LocalPath", "GcsObject", "AllowedSuccessCodes", "Interpreter" }, new[]{ "Executable" }, new[]{ typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject), global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject.Parser, new[]{ "Bucket", "Object", "GenerationNumber" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Patch configuration specifications. Contains details on how to
  /// apply patches to a VM instance.
  /// </summary>
  public sealed partial class PatchConfig : pb::IMessage<PatchConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PatchConfig> _parser = new pb::MessageParser<PatchConfig>(() => new PatchConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PatchConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PatchConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PatchConfig(PatchConfig other) : this() {
      rebootConfig_ = other.rebootConfig_;
      retryStrategy_ = other.retryStrategy_ != null ? other.retryStrategy_.Clone() : null;
      apt_ = other.apt_ != null ? other.apt_.Clone() : null;
      yum_ = other.yum_ != null ? other.yum_.Clone() : null;
      goo_ = other.goo_ != null ? other.goo_.Clone() : null;
      zypper_ = other.zypper_ != null ? other.zypper_.Clone() : null;
      windowsUpdate_ = other.windowsUpdate_ != null ? other.windowsUpdate_.Clone() : null;
      preStep_ = other.preStep_ != null ? other.preStep_.Clone() : null;
      postStep_ = other.postStep_ != null ? other.postStep_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PatchConfig Clone() {
      return new PatchConfig(this);
    }

    /// <summary>Field number for the "reboot_config" field.</summary>
    public const int RebootConfigFieldNumber = 1;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig rebootConfig_ = global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig.Unspecified;
    /// <summary>
    /// Post-patch reboot settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig RebootConfig {
      get { return rebootConfig_; }
      set {
        rebootConfig_ = value;
      }
    }

    /// <summary>Field number for the "retry_strategy" field.</summary>
    public const int RetryStrategyFieldNumber = 2;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.RetryStrategy retryStrategy_;
    /// <summary>
    /// Retry strategy can be defined to have the agent retry patching
    /// during the window if patching fails. If omitted, the agent will use its
    /// default retry strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.RetryStrategy RetryStrategy {
      get { return retryStrategy_; }
      set {
        retryStrategy_ = value;
      }
    }

    /// <summary>Field number for the "apt" field.</summary>
    public const int AptFieldNumber = 3;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings apt_;
    /// <summary>
    /// Apt update settings. Use this override the default apt patch rules.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings Apt {
      get { return apt_; }
      set {
        apt_ = value;
      }
    }

    /// <summary>Field number for the "yum" field.</summary>
    public const int YumFieldNumber = 4;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.YumSettings yum_;
    /// <summary>
    /// Yum update settings. Use this override the default yum patch rules.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.YumSettings Yum {
      get { return yum_; }
      set {
        yum_ = value;
      }
    }

    /// <summary>Field number for the "goo" field.</summary>
    public const int GooFieldNumber = 5;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.GooSettings goo_;
    /// <summary>
    /// Goo update settings. Use this override the default goo patch rules.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.GooSettings Goo {
      get { return goo_; }
      set {
        goo_ = value;
      }
    }

    /// <summary>Field number for the "zypper" field.</summary>
    public const int ZypperFieldNumber = 6;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.ZypperSettings zypper_;
    /// <summary>
    /// Zypper update settings. Use this override the default zypper patch rules.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.ZypperSettings Zypper {
      get { return zypper_; }
      set {
        zypper_ = value;
      }
    }

    /// <summary>Field number for the "windows_update" field.</summary>
    public const int WindowsUpdateFieldNumber = 7;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings windowsUpdate_;
    /// <summary>
    /// Windows update settings. Use this override the default windows patch rules.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings WindowsUpdate {
      get { return windowsUpdate_; }
      set {
        windowsUpdate_ = value;
      }
    }

    /// <summary>Field number for the "pre_step" field.</summary>
    public const int PreStepFieldNumber = 8;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep preStep_;
    /// <summary>
    /// The ExecStep to run before the patch update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep PreStep {
      get { return preStep_; }
      set {
        preStep_ = value;
      }
    }

    /// <summary>Field number for the "post_step" field.</summary>
    public const int PostStepFieldNumber = 9;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep postStep_;
    /// <summary>
    /// The ExecStep to run after the patch update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep PostStep {
      get { return postStep_; }
      set {
        postStep_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PatchConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PatchConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RebootConfig != other.RebootConfig) return false;
      if (!object.Equals(RetryStrategy, other.RetryStrategy)) return false;
      if (!object.Equals(Apt, other.Apt)) return false;
      if (!object.Equals(Yum, other.Yum)) return false;
      if (!object.Equals(Goo, other.Goo)) return false;
      if (!object.Equals(Zypper, other.Zypper)) return false;
      if (!object.Equals(WindowsUpdate, other.WindowsUpdate)) return false;
      if (!object.Equals(PreStep, other.PreStep)) return false;
      if (!object.Equals(PostStep, other.PostStep)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RebootConfig != global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig.Unspecified) hash ^= RebootConfig.GetHashCode();
      if (retryStrategy_ != null) hash ^= RetryStrategy.GetHashCode();
      if (apt_ != null) hash ^= Apt.GetHashCode();
      if (yum_ != null) hash ^= Yum.GetHashCode();
      if (goo_ != null) hash ^= Goo.GetHashCode();
      if (zypper_ != null) hash ^= Zypper.GetHashCode();
      if (windowsUpdate_ != null) hash ^= WindowsUpdate.GetHashCode();
      if (preStep_ != null) hash ^= PreStep.GetHashCode();
      if (postStep_ != null) hash ^= PostStep.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RebootConfig != global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RebootConfig);
      }
      if (retryStrategy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RetryStrategy);
      }
      if (apt_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Apt);
      }
      if (yum_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Yum);
      }
      if (goo_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Goo);
      }
      if (zypper_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Zypper);
      }
      if (windowsUpdate_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(WindowsUpdate);
      }
      if (preStep_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(PreStep);
      }
      if (postStep_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(PostStep);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RebootConfig != global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RebootConfig);
      }
      if (retryStrategy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RetryStrategy);
      }
      if (apt_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Apt);
      }
      if (yum_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Yum);
      }
      if (goo_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Goo);
      }
      if (zypper_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Zypper);
      }
      if (windowsUpdate_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(WindowsUpdate);
      }
      if (preStep_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(PreStep);
      }
      if (postStep_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(PostStep);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RebootConfig != global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RebootConfig);
      }
      if (retryStrategy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryStrategy);
      }
      if (apt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Apt);
      }
      if (yum_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Yum);
      }
      if (goo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Goo);
      }
      if (zypper_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Zypper);
      }
      if (windowsUpdate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WindowsUpdate);
      }
      if (preStep_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PreStep);
      }
      if (postStep_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PostStep);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PatchConfig other) {
      if (other == null) {
        return;
      }
      if (other.RebootConfig != global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig.Unspecified) {
        RebootConfig = other.RebootConfig;
      }
      if (other.retryStrategy_ != null) {
        if (retryStrategy_ == null) {
          RetryStrategy = new global::Google.Cloud.Osconfig.Agentendpoint.V1.RetryStrategy();
        }
        RetryStrategy.MergeFrom(other.RetryStrategy);
      }
      if (other.apt_ != null) {
        if (apt_ == null) {
          Apt = new global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings();
        }
        Apt.MergeFrom(other.Apt);
      }
      if (other.yum_ != null) {
        if (yum_ == null) {
          Yum = new global::Google.Cloud.Osconfig.Agentendpoint.V1.YumSettings();
        }
        Yum.MergeFrom(other.Yum);
      }
      if (other.goo_ != null) {
        if (goo_ == null) {
          Goo = new global::Google.Cloud.Osconfig.Agentendpoint.V1.GooSettings();
        }
        Goo.MergeFrom(other.Goo);
      }
      if (other.zypper_ != null) {
        if (zypper_ == null) {
          Zypper = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ZypperSettings();
        }
        Zypper.MergeFrom(other.Zypper);
      }
      if (other.windowsUpdate_ != null) {
        if (windowsUpdate_ == null) {
          WindowsUpdate = new global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings();
        }
        WindowsUpdate.MergeFrom(other.WindowsUpdate);
      }
      if (other.preStep_ != null) {
        if (preStep_ == null) {
          PreStep = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep();
        }
        PreStep.MergeFrom(other.PreStep);
      }
      if (other.postStep_ != null) {
        if (postStep_ == null) {
          PostStep = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep();
        }
        PostStep.MergeFrom(other.PostStep);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RebootConfig = (global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig) input.ReadEnum();
            break;
          }
          case 18: {
            if (retryStrategy_ == null) {
              RetryStrategy = new global::Google.Cloud.Osconfig.Agentendpoint.V1.RetryStrategy();
            }
            input.ReadMessage(RetryStrategy);
            break;
          }
          case 26: {
            if (apt_ == null) {
              Apt = new global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings();
            }
            input.ReadMessage(Apt);
            break;
          }
          case 34: {
            if (yum_ == null) {
              Yum = new global::Google.Cloud.Osconfig.Agentendpoint.V1.YumSettings();
            }
            input.ReadMessage(Yum);
            break;
          }
          case 42: {
            if (goo_ == null) {
              Goo = new global::Google.Cloud.Osconfig.Agentendpoint.V1.GooSettings();
            }
            input.ReadMessage(Goo);
            break;
          }
          case 50: {
            if (zypper_ == null) {
              Zypper = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ZypperSettings();
            }
            input.ReadMessage(Zypper);
            break;
          }
          case 58: {
            if (windowsUpdate_ == null) {
              WindowsUpdate = new global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings();
            }
            input.ReadMessage(WindowsUpdate);
            break;
          }
          case 66: {
            if (preStep_ == null) {
              PreStep = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep();
            }
            input.ReadMessage(PreStep);
            break;
          }
          case 74: {
            if (postStep_ == null) {
              PostStep = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep();
            }
            input.ReadMessage(PostStep);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            RebootConfig = (global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchConfig.Types.RebootConfig) input.ReadEnum();
            break;
          }
          case 18: {
            if (retryStrategy_ == null) {
              RetryStrategy = new global::Google.Cloud.Osconfig.Agentendpoint.V1.RetryStrategy();
            }
            input.ReadMessage(RetryStrategy);
            break;
          }
          case 26: {
            if (apt_ == null) {
              Apt = new global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings();
            }
            input.ReadMessage(Apt);
            break;
          }
          case 34: {
            if (yum_ == null) {
              Yum = new global::Google.Cloud.Osconfig.Agentendpoint.V1.YumSettings();
            }
            input.ReadMessage(Yum);
            break;
          }
          case 42: {
            if (goo_ == null) {
              Goo = new global::Google.Cloud.Osconfig.Agentendpoint.V1.GooSettings();
            }
            input.ReadMessage(Goo);
            break;
          }
          case 50: {
            if (zypper_ == null) {
              Zypper = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ZypperSettings();
            }
            input.ReadMessage(Zypper);
            break;
          }
          case 58: {
            if (windowsUpdate_ == null) {
              WindowsUpdate = new global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings();
            }
            input.ReadMessage(WindowsUpdate);
            break;
          }
          case 66: {
            if (preStep_ == null) {
              PreStep = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep();
            }
            input.ReadMessage(PreStep);
            break;
          }
          case 74: {
            if (postStep_ == null) {
              PostStep = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStep();
            }
            input.ReadMessage(PostStep);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the PatchConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Post-patch reboot settings.
      /// </summary>
      public enum RebootConfig {
        /// <summary>
        /// The default behavior is DEFAULT.
        /// </summary>
        [pbr::OriginalName("REBOOT_CONFIG_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// The agent decides if a reboot is necessary by checking
        /// signals such as registry keys on Windows or `/var/run/reboot-required` on
        /// APT based systems. On RPM based systems, a set of core system package
        /// install times are compared with system boot time.
        /// </summary>
        [pbr::OriginalName("DEFAULT")] Default = 1,
        /// <summary>
        /// Always reboot the machine after the update completes.
        /// </summary>
        [pbr::OriginalName("ALWAYS")] Always = 2,
        /// <summary>
        /// Never reboot the machine after the update completes.
        /// </summary>
        [pbr::OriginalName("NEVER")] Never = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Apt patching will be performed by executing `apt-get update &amp;&amp; apt-get
  /// upgrade`. Additional options can be set to control how this is executed.
  /// </summary>
  public sealed partial class AptSettings : pb::IMessage<AptSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AptSettings> _parser = new pb::MessageParser<AptSettings>(() => new AptSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AptSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AptSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AptSettings(AptSettings other) : this() {
      type_ = other.type_;
      excludes_ = other.excludes_.Clone();
      exclusivePackages_ = other.exclusivePackages_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AptSettings Clone() {
      return new AptSettings(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type type_ = global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type.Unspecified;
    /// <summary>
    /// By changing the type to DIST, the patching will be performed
    /// using `apt-get dist-upgrade` instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "excludes" field.</summary>
    public const int ExcludesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_excludes_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> excludes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of packages to exclude from update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Excludes {
      get { return excludes_; }
    }

    /// <summary>Field number for the "exclusive_packages" field.</summary>
    public const int ExclusivePackagesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_exclusivePackages_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> exclusivePackages_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An exclusive list of packages to be updated. These are the only packages
    /// that will be updated. If these packages are not installed, they will be
    /// ignored. This field cannot be specified with any other patch configuration
    /// fields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ExclusivePackages {
      get { return exclusivePackages_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AptSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AptSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if(!excludes_.Equals(other.excludes_)) return false;
      if(!exclusivePackages_.Equals(other.exclusivePackages_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type.Unspecified) hash ^= Type.GetHashCode();
      hash ^= excludes_.GetHashCode();
      hash ^= exclusivePackages_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Type != global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      excludes_.WriteTo(output, _repeated_excludes_codec);
      exclusivePackages_.WriteTo(output, _repeated_exclusivePackages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Type != global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      excludes_.WriteTo(ref output, _repeated_excludes_codec);
      exclusivePackages_.WriteTo(ref output, _repeated_exclusivePackages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      size += excludes_.CalculateSize(_repeated_excludes_codec);
      size += exclusivePackages_.CalculateSize(_repeated_exclusivePackages_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AptSettings other) {
      if (other == null) {
        return;
      }
      if (other.Type != global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type.Unspecified) {
        Type = other.Type;
      }
      excludes_.Add(other.excludes_);
      exclusivePackages_.Add(other.exclusivePackages_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type) input.ReadEnum();
            break;
          }
          case 18: {
            excludes_.AddEntriesFrom(input, _repeated_excludes_codec);
            break;
          }
          case 26: {
            exclusivePackages_.AddEntriesFrom(input, _repeated_exclusivePackages_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::Google.Cloud.Osconfig.Agentendpoint.V1.AptSettings.Types.Type) input.ReadEnum();
            break;
          }
          case 18: {
            excludes_.AddEntriesFrom(ref input, _repeated_excludes_codec);
            break;
          }
          case 26: {
            exclusivePackages_.AddEntriesFrom(ref input, _repeated_exclusivePackages_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AptSettings message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Apt patch type.
      /// </summary>
      public enum Type {
        /// <summary>
        /// By default, upgrade will be performed.
        /// </summary>
        [pbr::OriginalName("TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Runs `apt-get dist-upgrade`.
        /// </summary>
        [pbr::OriginalName("DIST")] Dist = 1,
        /// <summary>
        /// Runs `apt-get upgrade`.
        /// </summary>
        [pbr::OriginalName("UPGRADE")] Upgrade = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Yum patching will be performed by executing `yum update`. Additional options
  /// can be set to control how this is executed.
  ///
  /// Note that not all settings are supported on all platforms.
  /// </summary>
  public sealed partial class YumSettings : pb::IMessage<YumSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<YumSettings> _parser = new pb::MessageParser<YumSettings>(() => new YumSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<YumSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public YumSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public YumSettings(YumSettings other) : this() {
      security_ = other.security_;
      minimal_ = other.minimal_;
      excludes_ = other.excludes_.Clone();
      exclusivePackages_ = other.exclusivePackages_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public YumSettings Clone() {
      return new YumSettings(this);
    }

    /// <summary>Field number for the "security" field.</summary>
    public const int SecurityFieldNumber = 1;
    private bool security_;
    /// <summary>
    /// Adds the `--security` flag to `yum update`. Not supported on
    /// all platforms.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Security {
      get { return security_; }
      set {
        security_ = value;
      }
    }

    /// <summary>Field number for the "minimal" field.</summary>
    public const int MinimalFieldNumber = 2;
    private bool minimal_;
    /// <summary>
    /// Will cause patch to run `yum update-minimal` instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Minimal {
      get { return minimal_; }
      set {
        minimal_ = value;
      }
    }

    /// <summary>Field number for the "excludes" field.</summary>
    public const int ExcludesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_excludes_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> excludes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of packages to exclude from update. These packages will be excluded by
    /// using the yum `--exclude` flag.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Excludes {
      get { return excludes_; }
    }

    /// <summary>Field number for the "exclusive_packages" field.</summary>
    public const int ExclusivePackagesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_exclusivePackages_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> exclusivePackages_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An exclusive list of packages to be updated. These are the only packages
    /// that will be updated. If these packages are not installed, they will be
    /// ignored. This field must not be specified with any other patch
    /// configuration fields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ExclusivePackages {
      get { return exclusivePackages_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as YumSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(YumSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Security != other.Security) return false;
      if (Minimal != other.Minimal) return false;
      if(!excludes_.Equals(other.excludes_)) return false;
      if(!exclusivePackages_.Equals(other.exclusivePackages_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Security != false) hash ^= Security.GetHashCode();
      if (Minimal != false) hash ^= Minimal.GetHashCode();
      hash ^= excludes_.GetHashCode();
      hash ^= exclusivePackages_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Security != false) {
        output.WriteRawTag(8);
        output.WriteBool(Security);
      }
      if (Minimal != false) {
        output.WriteRawTag(16);
        output.WriteBool(Minimal);
      }
      excludes_.WriteTo(output, _repeated_excludes_codec);
      exclusivePackages_.WriteTo(output, _repeated_exclusivePackages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Security != false) {
        output.WriteRawTag(8);
        output.WriteBool(Security);
      }
      if (Minimal != false) {
        output.WriteRawTag(16);
        output.WriteBool(Minimal);
      }
      excludes_.WriteTo(ref output, _repeated_excludes_codec);
      exclusivePackages_.WriteTo(ref output, _repeated_exclusivePackages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Security != false) {
        size += 1 + 1;
      }
      if (Minimal != false) {
        size += 1 + 1;
      }
      size += excludes_.CalculateSize(_repeated_excludes_codec);
      size += exclusivePackages_.CalculateSize(_repeated_exclusivePackages_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(YumSettings other) {
      if (other == null) {
        return;
      }
      if (other.Security != false) {
        Security = other.Security;
      }
      if (other.Minimal != false) {
        Minimal = other.Minimal;
      }
      excludes_.Add(other.excludes_);
      exclusivePackages_.Add(other.exclusivePackages_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Security = input.ReadBool();
            break;
          }
          case 16: {
            Minimal = input.ReadBool();
            break;
          }
          case 26: {
            excludes_.AddEntriesFrom(input, _repeated_excludes_codec);
            break;
          }
          case 34: {
            exclusivePackages_.AddEntriesFrom(input, _repeated_exclusivePackages_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Security = input.ReadBool();
            break;
          }
          case 16: {
            Minimal = input.ReadBool();
            break;
          }
          case 26: {
            excludes_.AddEntriesFrom(ref input, _repeated_excludes_codec);
            break;
          }
          case 34: {
            exclusivePackages_.AddEntriesFrom(ref input, _repeated_exclusivePackages_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Googet patching is performed by running `googet update`.
  /// </summary>
  public sealed partial class GooSettings : pb::IMessage<GooSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GooSettings> _parser = new pb::MessageParser<GooSettings>(() => new GooSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GooSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GooSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GooSettings(GooSettings other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GooSettings Clone() {
      return new GooSettings(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GooSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GooSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GooSettings other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Zypper patching is performed by running `zypper patch`.
  /// See also https://en.opensuse.org/SDB:Zypper_manual.
  /// </summary>
  public sealed partial class ZypperSettings : pb::IMessage<ZypperSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ZypperSettings> _parser = new pb::MessageParser<ZypperSettings>(() => new ZypperSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ZypperSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZypperSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZypperSettings(ZypperSettings other) : this() {
      withOptional_ = other.withOptional_;
      withUpdate_ = other.withUpdate_;
      categories_ = other.categories_.Clone();
      severities_ = other.severities_.Clone();
      excludes_ = other.excludes_.Clone();
      exclusivePatches_ = other.exclusivePatches_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZypperSettings Clone() {
      return new ZypperSettings(this);
    }

    /// <summary>Field number for the "with_optional" field.</summary>
    public const int WithOptionalFieldNumber = 1;
    private bool withOptional_;
    /// <summary>
    /// Adds the `--with-optional` flag to `zypper patch`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool WithOptional {
      get { return withOptional_; }
      set {
        withOptional_ = value;
      }
    }

    /// <summary>Field number for the "with_update" field.</summary>
    public const int WithUpdateFieldNumber = 2;
    private bool withUpdate_;
    /// <summary>
    /// Adds the `--with-update` flag, to `zypper patch`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool WithUpdate {
      get { return withUpdate_; }
      set {
        withUpdate_ = value;
      }
    }

    /// <summary>Field number for the "categories" field.</summary>
    public const int CategoriesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_categories_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> categories_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Install only patches with these categories.
    /// Common categories include security, recommended, and feature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Categories {
      get { return categories_; }
    }

    /// <summary>Field number for the "severities" field.</summary>
    public const int SeveritiesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_severities_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> severities_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Install only patches with these severities.
    /// Common severities include critical, important, moderate, and low.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Severities {
      get { return severities_; }
    }

    /// <summary>Field number for the "excludes" field.</summary>
    public const int ExcludesFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_excludes_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> excludes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of patches to exclude from update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Excludes {
      get { return excludes_; }
    }

    /// <summary>Field number for the "exclusive_patches" field.</summary>
    public const int ExclusivePatchesFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_exclusivePatches_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> exclusivePatches_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An exclusive list of patches to be updated. These are the only patches
    /// that will be installed using 'zypper patch patch:&lt;patch_name>' command.
    /// This field must not be used with any other patch configuration fields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ExclusivePatches {
      get { return exclusivePatches_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ZypperSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ZypperSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (WithOptional != other.WithOptional) return false;
      if (WithUpdate != other.WithUpdate) return false;
      if(!categories_.Equals(other.categories_)) return false;
      if(!severities_.Equals(other.severities_)) return false;
      if(!excludes_.Equals(other.excludes_)) return false;
      if(!exclusivePatches_.Equals(other.exclusivePatches_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (WithOptional != false) hash ^= WithOptional.GetHashCode();
      if (WithUpdate != false) hash ^= WithUpdate.GetHashCode();
      hash ^= categories_.GetHashCode();
      hash ^= severities_.GetHashCode();
      hash ^= excludes_.GetHashCode();
      hash ^= exclusivePatches_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (WithOptional != false) {
        output.WriteRawTag(8);
        output.WriteBool(WithOptional);
      }
      if (WithUpdate != false) {
        output.WriteRawTag(16);
        output.WriteBool(WithUpdate);
      }
      categories_.WriteTo(output, _repeated_categories_codec);
      severities_.WriteTo(output, _repeated_severities_codec);
      excludes_.WriteTo(output, _repeated_excludes_codec);
      exclusivePatches_.WriteTo(output, _repeated_exclusivePatches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (WithOptional != false) {
        output.WriteRawTag(8);
        output.WriteBool(WithOptional);
      }
      if (WithUpdate != false) {
        output.WriteRawTag(16);
        output.WriteBool(WithUpdate);
      }
      categories_.WriteTo(ref output, _repeated_categories_codec);
      severities_.WriteTo(ref output, _repeated_severities_codec);
      excludes_.WriteTo(ref output, _repeated_excludes_codec);
      exclusivePatches_.WriteTo(ref output, _repeated_exclusivePatches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (WithOptional != false) {
        size += 1 + 1;
      }
      if (WithUpdate != false) {
        size += 1 + 1;
      }
      size += categories_.CalculateSize(_repeated_categories_codec);
      size += severities_.CalculateSize(_repeated_severities_codec);
      size += excludes_.CalculateSize(_repeated_excludes_codec);
      size += exclusivePatches_.CalculateSize(_repeated_exclusivePatches_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ZypperSettings other) {
      if (other == null) {
        return;
      }
      if (other.WithOptional != false) {
        WithOptional = other.WithOptional;
      }
      if (other.WithUpdate != false) {
        WithUpdate = other.WithUpdate;
      }
      categories_.Add(other.categories_);
      severities_.Add(other.severities_);
      excludes_.Add(other.excludes_);
      exclusivePatches_.Add(other.exclusivePatches_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            WithOptional = input.ReadBool();
            break;
          }
          case 16: {
            WithUpdate = input.ReadBool();
            break;
          }
          case 26: {
            categories_.AddEntriesFrom(input, _repeated_categories_codec);
            break;
          }
          case 34: {
            severities_.AddEntriesFrom(input, _repeated_severities_codec);
            break;
          }
          case 42: {
            excludes_.AddEntriesFrom(input, _repeated_excludes_codec);
            break;
          }
          case 50: {
            exclusivePatches_.AddEntriesFrom(input, _repeated_exclusivePatches_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            WithOptional = input.ReadBool();
            break;
          }
          case 16: {
            WithUpdate = input.ReadBool();
            break;
          }
          case 26: {
            categories_.AddEntriesFrom(ref input, _repeated_categories_codec);
            break;
          }
          case 34: {
            severities_.AddEntriesFrom(ref input, _repeated_severities_codec);
            break;
          }
          case 42: {
            excludes_.AddEntriesFrom(ref input, _repeated_excludes_codec);
            break;
          }
          case 50: {
            exclusivePatches_.AddEntriesFrom(ref input, _repeated_exclusivePatches_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Windows patching is performed using the Windows Update Agent.
  /// </summary>
  public sealed partial class WindowsUpdateSettings : pb::IMessage<WindowsUpdateSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WindowsUpdateSettings> _parser = new pb::MessageParser<WindowsUpdateSettings>(() => new WindowsUpdateSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WindowsUpdateSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WindowsUpdateSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WindowsUpdateSettings(WindowsUpdateSettings other) : this() {
      classifications_ = other.classifications_.Clone();
      excludes_ = other.excludes_.Clone();
      exclusivePatches_ = other.exclusivePatches_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WindowsUpdateSettings Clone() {
      return new WindowsUpdateSettings(this);
    }

    /// <summary>Field number for the "classifications" field.</summary>
    public const int ClassificationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings.Types.Classification> _repeated_classifications_codec
        = pb::FieldCodec.ForEnum(10, x => (int) x, x => (global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings.Types.Classification) x);
    private readonly pbc::RepeatedField<global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings.Types.Classification> classifications_ = new pbc::RepeatedField<global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings.Types.Classification>();
    /// <summary>
    /// Only apply updates of these windows update classifications. If empty, all
    /// updates will be applied.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Osconfig.Agentendpoint.V1.WindowsUpdateSettings.Types.Classification> Classifications {
      get { return classifications_; }
    }

    /// <summary>Field number for the "excludes" field.</summary>
    public const int ExcludesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_excludes_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> excludes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of KBs to exclude from update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Excludes {
      get { return excludes_; }
    }

    /// <summary>Field number for the "exclusive_patches" field.</summary>
    public const int ExclusivePatchesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_exclusivePatches_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> exclusivePatches_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An exclusive list of kbs to be updated. These are the only patches
    /// that will be updated. This field must not be used with other
    /// patch configurations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ExclusivePatches {
      get { return exclusivePatches_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WindowsUpdateSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WindowsUpdateSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!classifications_.Equals(other.classifications_)) return false;
      if(!excludes_.Equals(other.excludes_)) return false;
      if(!exclusivePatches_.Equals(other.exclusivePatches_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= classifications_.GetHashCode();
      hash ^= excludes_.GetHashCode();
      hash ^= exclusivePatches_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      classifications_.WriteTo(output, _repeated_classifications_codec);
      excludes_.WriteTo(output, _repeated_excludes_codec);
      exclusivePatches_.WriteTo(output, _repeated_exclusivePatches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      classifications_.WriteTo(ref output, _repeated_classifications_codec);
      excludes_.WriteTo(ref output, _repeated_excludes_codec);
      exclusivePatches_.WriteTo(ref output, _repeated_exclusivePatches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += classifications_.CalculateSize(_repeated_classifications_codec);
      size += excludes_.CalculateSize(_repeated_excludes_codec);
      size += exclusivePatches_.CalculateSize(_repeated_exclusivePatches_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WindowsUpdateSettings other) {
      if (other == null) {
        return;
      }
      classifications_.Add(other.classifications_);
      excludes_.Add(other.excludes_);
      exclusivePatches_.Add(other.exclusivePatches_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            classifications_.AddEntriesFrom(input, _repeated_classifications_codec);
            break;
          }
          case 18: {
            excludes_.AddEntriesFrom(input, _repeated_excludes_codec);
            break;
          }
          case 26: {
            exclusivePatches_.AddEntriesFrom(input, _repeated_exclusivePatches_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            classifications_.AddEntriesFrom(ref input, _repeated_classifications_codec);
            break;
          }
          case 18: {
            excludes_.AddEntriesFrom(ref input, _repeated_excludes_codec);
            break;
          }
          case 26: {
            exclusivePatches_.AddEntriesFrom(ref input, _repeated_exclusivePatches_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the WindowsUpdateSettings message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Microsoft Windows update classifications as defined in
      /// [1]
      /// https://support.microsoft.com/en-us/help/824684/description-of-the-standard-terminology-that-is-used-to-describe-micro
      /// </summary>
      public enum Classification {
        /// <summary>
        /// Invalid. If classifications are included, they must be specified.
        /// </summary>
        [pbr::OriginalName("CLASSIFICATION_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// "A widely released fix for a specific problem that addresses a critical,
        /// non-security-related bug." [1]
        /// </summary>
        [pbr::OriginalName("CRITICAL")] Critical = 1,
        /// <summary>
        /// "A widely released fix for a product-specific, security-related
        /// vulnerability. Security vulnerabilities are rated by their severity. The
        /// severity rating is indicated in the Microsoft security bulletin as
        /// critical, important, moderate, or low." [1]
        /// </summary>
        [pbr::OriginalName("SECURITY")] Security = 2,
        /// <summary>
        /// "A widely released and frequent software update that contains additions
        /// to a product’s definition database. Definition databases are often used
        /// to detect objects that have specific attributes, such as malicious code,
        /// phishing websites, or junk mail." [1]
        /// </summary>
        [pbr::OriginalName("DEFINITION")] Definition = 3,
        /// <summary>
        /// "Software that controls the input and output of a device." [1]
        /// </summary>
        [pbr::OriginalName("DRIVER")] Driver = 4,
        /// <summary>
        /// "New product functionality that is first distributed outside the context
        /// of a product release and that is typically included in the next full
        /// product release." [1]
        /// </summary>
        [pbr::OriginalName("FEATURE_PACK")] FeaturePack = 5,
        /// <summary>
        /// "A tested, cumulative set of all hotfixes, security updates, critical
        /// updates, and updates. Additionally, service packs may contain additional
        /// fixes for problems that are found internally since the release of the
        /// product. Service packs my also contain a limited number of
        /// customer-requested design changes or features." [1]
        /// </summary>
        [pbr::OriginalName("SERVICE_PACK")] ServicePack = 6,
        /// <summary>
        /// "A utility or feature that helps complete a task or set of tasks." [1]
        /// </summary>
        [pbr::OriginalName("TOOL")] Tool = 7,
        /// <summary>
        /// "A tested, cumulative set of hotfixes, security updates, critical
        /// updates, and updates that are packaged together for easy deployment. A
        /// rollup generally targets a specific area, such as security, or a
        /// component of a product, such as Internet Information Services (IIS)." [1]
        /// </summary>
        [pbr::OriginalName("UPDATE_ROLLUP")] UpdateRollup = 8,
        /// <summary>
        /// "A widely released fix for a specific problem. An update addresses a
        /// noncritical, non-security-related bug." [1]
        /// </summary>
        [pbr::OriginalName("UPDATE")] Update = 9,
      }

    }
    #endregion

  }

  /// <summary>
  /// The strategy for retrying failed patches during the patch window.
  /// </summary>
  public sealed partial class RetryStrategy : pb::IMessage<RetryStrategy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RetryStrategy> _parser = new pb::MessageParser<RetryStrategy>(() => new RetryStrategy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RetryStrategy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RetryStrategy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RetryStrategy(RetryStrategy other) : this() {
      enabled_ = other.enabled_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RetryStrategy Clone() {
      return new RetryStrategy(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    /// <summary>
    /// If true, the agent will continue to try and patch until the window has
    /// ended.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RetryStrategy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RetryStrategy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RetryStrategy other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A step that runs an executable for a PatchJob.
  /// </summary>
  public sealed partial class ExecStep : pb::IMessage<ExecStep>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExecStep> _parser = new pb::MessageParser<ExecStep>(() => new ExecStep());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExecStep> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecStep() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecStep(ExecStep other) : this() {
      linuxExecStepConfig_ = other.linuxExecStepConfig_ != null ? other.linuxExecStepConfig_.Clone() : null;
      windowsExecStepConfig_ = other.windowsExecStepConfig_ != null ? other.windowsExecStepConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecStep Clone() {
      return new ExecStep(this);
    }

    /// <summary>Field number for the "linux_exec_step_config" field.</summary>
    public const int LinuxExecStepConfigFieldNumber = 1;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig linuxExecStepConfig_;
    /// <summary>
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig LinuxExecStepConfig {
      get { return linuxExecStepConfig_; }
      set {
        linuxExecStepConfig_ = value;
      }
    }

    /// <summary>Field number for the "windows_exec_step_config" field.</summary>
    public const int WindowsExecStepConfigFieldNumber = 2;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig windowsExecStepConfig_;
    /// <summary>
    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig WindowsExecStepConfig {
      get { return windowsExecStepConfig_; }
      set {
        windowsExecStepConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExecStep);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExecStep other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LinuxExecStepConfig, other.LinuxExecStepConfig)) return false;
      if (!object.Equals(WindowsExecStepConfig, other.WindowsExecStepConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (linuxExecStepConfig_ != null) hash ^= LinuxExecStepConfig.GetHashCode();
      if (windowsExecStepConfig_ != null) hash ^= WindowsExecStepConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (linuxExecStepConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LinuxExecStepConfig);
      }
      if (windowsExecStepConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(WindowsExecStepConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (linuxExecStepConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LinuxExecStepConfig);
      }
      if (windowsExecStepConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(WindowsExecStepConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (linuxExecStepConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LinuxExecStepConfig);
      }
      if (windowsExecStepConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WindowsExecStepConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExecStep other) {
      if (other == null) {
        return;
      }
      if (other.linuxExecStepConfig_ != null) {
        if (linuxExecStepConfig_ == null) {
          LinuxExecStepConfig = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig();
        }
        LinuxExecStepConfig.MergeFrom(other.LinuxExecStepConfig);
      }
      if (other.windowsExecStepConfig_ != null) {
        if (windowsExecStepConfig_ == null) {
          WindowsExecStepConfig = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig();
        }
        WindowsExecStepConfig.MergeFrom(other.WindowsExecStepConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (linuxExecStepConfig_ == null) {
              LinuxExecStepConfig = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig();
            }
            input.ReadMessage(LinuxExecStepConfig);
            break;
          }
          case 18: {
            if (windowsExecStepConfig_ == null) {
              WindowsExecStepConfig = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig();
            }
            input.ReadMessage(WindowsExecStepConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (linuxExecStepConfig_ == null) {
              LinuxExecStepConfig = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig();
            }
            input.ReadMessage(LinuxExecStepConfig);
            break;
          }
          case 18: {
            if (windowsExecStepConfig_ == null) {
              WindowsExecStepConfig = new global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig();
            }
            input.ReadMessage(WindowsExecStepConfig);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Common configurations for an ExecStep.
  /// </summary>
  public sealed partial class ExecStepConfig : pb::IMessage<ExecStepConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExecStepConfig> _parser = new pb::MessageParser<ExecStepConfig>(() => new ExecStepConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExecStepConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecStepConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecStepConfig(ExecStepConfig other) : this() {
      allowedSuccessCodes_ = other.allowedSuccessCodes_.Clone();
      interpreter_ = other.interpreter_;
      switch (other.ExecutableCase) {
        case ExecutableOneofCase.LocalPath:
          LocalPath = other.LocalPath;
          break;
        case ExecutableOneofCase.GcsObject:
          GcsObject = other.GcsObject.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecStepConfig Clone() {
      return new ExecStepConfig(this);
    }

    /// <summary>Field number for the "local_path" field.</summary>
    public const int LocalPathFieldNumber = 1;
    /// <summary>
    /// An absolute path to the executable on the VM.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string LocalPath {
      get { return executableCase_ == ExecutableOneofCase.LocalPath ? (string) executable_ : ""; }
      set {
        executable_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        executableCase_ = ExecutableOneofCase.LocalPath;
      }
    }

    /// <summary>Field number for the "gcs_object" field.</summary>
    public const int GcsObjectFieldNumber = 2;
    /// <summary>
    /// A GCS object containing the executable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject GcsObject {
      get { return executableCase_ == ExecutableOneofCase.GcsObject ? (global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject) executable_ : null; }
      set {
        executable_ = value;
        executableCase_ = value == null ? ExecutableOneofCase.None : ExecutableOneofCase.GcsObject;
      }
    }

    /// <summary>Field number for the "allowed_success_codes" field.</summary>
    public const int AllowedSuccessCodesFieldNumber = 3;
    private static readonly pb::FieldCodec<int> _repeated_allowedSuccessCodes_codec
        = pb::FieldCodec.ForInt32(26);
    private readonly pbc::RepeatedField<int> allowedSuccessCodes_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Defaults to [0]. A list of possible return values that the
    /// execution can return to indicate a success.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> AllowedSuccessCodes {
      get { return allowedSuccessCodes_; }
    }

    /// <summary>Field number for the "interpreter" field.</summary>
    public const int InterpreterFieldNumber = 4;
    private global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter interpreter_ = global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter.Unspecified;
    /// <summary>
    /// The script interpreter to use to run the script. If no interpreter is
    /// specified the script will be executed directly, which will likely
    /// only succeed for scripts with shebang lines.
    /// [Wikipedia shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter Interpreter {
      get { return interpreter_; }
      set {
        interpreter_ = value;
      }
    }

    private object executable_;
    /// <summary>Enum of possible cases for the "executable" oneof.</summary>
    public enum ExecutableOneofCase {
      None = 0,
      LocalPath = 1,
      GcsObject = 2,
    }
    private ExecutableOneofCase executableCase_ = ExecutableOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutableOneofCase ExecutableCase {
      get { return executableCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExecutable() {
      executableCase_ = ExecutableOneofCase.None;
      executable_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExecStepConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExecStepConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LocalPath != other.LocalPath) return false;
      if (!object.Equals(GcsObject, other.GcsObject)) return false;
      if(!allowedSuccessCodes_.Equals(other.allowedSuccessCodes_)) return false;
      if (Interpreter != other.Interpreter) return false;
      if (ExecutableCase != other.ExecutableCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (executableCase_ == ExecutableOneofCase.LocalPath) hash ^= LocalPath.GetHashCode();
      if (executableCase_ == ExecutableOneofCase.GcsObject) hash ^= GcsObject.GetHashCode();
      hash ^= allowedSuccessCodes_.GetHashCode();
      if (Interpreter != global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter.Unspecified) hash ^= Interpreter.GetHashCode();
      hash ^= (int) executableCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (executableCase_ == ExecutableOneofCase.LocalPath) {
        output.WriteRawTag(10);
        output.WriteString(LocalPath);
      }
      if (executableCase_ == ExecutableOneofCase.GcsObject) {
        output.WriteRawTag(18);
        output.WriteMessage(GcsObject);
      }
      allowedSuccessCodes_.WriteTo(output, _repeated_allowedSuccessCodes_codec);
      if (Interpreter != global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Interpreter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (executableCase_ == ExecutableOneofCase.LocalPath) {
        output.WriteRawTag(10);
        output.WriteString(LocalPath);
      }
      if (executableCase_ == ExecutableOneofCase.GcsObject) {
        output.WriteRawTag(18);
        output.WriteMessage(GcsObject);
      }
      allowedSuccessCodes_.WriteTo(ref output, _repeated_allowedSuccessCodes_codec);
      if (Interpreter != global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Interpreter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (executableCase_ == ExecutableOneofCase.LocalPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LocalPath);
      }
      if (executableCase_ == ExecutableOneofCase.GcsObject) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GcsObject);
      }
      size += allowedSuccessCodes_.CalculateSize(_repeated_allowedSuccessCodes_codec);
      if (Interpreter != global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Interpreter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExecStepConfig other) {
      if (other == null) {
        return;
      }
      allowedSuccessCodes_.Add(other.allowedSuccessCodes_);
      if (other.Interpreter != global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter.Unspecified) {
        Interpreter = other.Interpreter;
      }
      switch (other.ExecutableCase) {
        case ExecutableOneofCase.LocalPath:
          LocalPath = other.LocalPath;
          break;
        case ExecutableOneofCase.GcsObject:
          if (GcsObject == null) {
            GcsObject = new global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject();
          }
          GcsObject.MergeFrom(other.GcsObject);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            LocalPath = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject subBuilder = new global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject();
            if (executableCase_ == ExecutableOneofCase.GcsObject) {
              subBuilder.MergeFrom(GcsObject);
            }
            input.ReadMessage(subBuilder);
            GcsObject = subBuilder;
            break;
          }
          case 26:
          case 24: {
            allowedSuccessCodes_.AddEntriesFrom(input, _repeated_allowedSuccessCodes_codec);
            break;
          }
          case 32: {
            Interpreter = (global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            LocalPath = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject subBuilder = new global::Google.Cloud.Osconfig.Agentendpoint.V1.GcsObject();
            if (executableCase_ == ExecutableOneofCase.GcsObject) {
              subBuilder.MergeFrom(GcsObject);
            }
            input.ReadMessage(subBuilder);
            GcsObject = subBuilder;
            break;
          }
          case 26:
          case 24: {
            allowedSuccessCodes_.AddEntriesFrom(ref input, _repeated_allowedSuccessCodes_codec);
            break;
          }
          case 32: {
            Interpreter = (global::Google.Cloud.Osconfig.Agentendpoint.V1.ExecStepConfig.Types.Interpreter) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ExecStepConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The interpreter used to execute the a file.
      /// </summary>
      public enum Interpreter {
        /// <summary>
        /// Invalid for a Windows ExecStepConfig. For a Linux ExecStepConfig, the
        /// interpreter will be parsed from the shebang line of the script if
        /// unspecified.
        /// </summary>
        [pbr::OriginalName("INTERPRETER_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Indicates that the script will be run with /bin/sh on Linux and cmd
        /// on windows.
        /// </summary>
        [pbr::OriginalName("SHELL")] Shell = 1,
        /// <summary>
        /// Indicates that the file will be run with PowerShell.
        /// </summary>
        [pbr::OriginalName("POWERSHELL")] Powershell = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// GCS object representation.
  /// </summary>
  public sealed partial class GcsObject : pb::IMessage<GcsObject>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GcsObject> _parser = new pb::MessageParser<GcsObject>(() => new GcsObject());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GcsObject> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Osconfig.Agentendpoint.V1.PatchJobsReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GcsObject() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GcsObject(GcsObject other) : this() {
      bucket_ = other.bucket_;
      object_ = other.object_;
      generationNumber_ = other.generationNumber_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GcsObject Clone() {
      return new GcsObject(this);
    }

    /// <summary>Field number for the "bucket" field.</summary>
    public const int BucketFieldNumber = 1;
    private string bucket_ = "";
    /// <summary>
    /// Bucket of the GCS object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Bucket {
      get { return bucket_; }
      set {
        bucket_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "object" field.</summary>
    public const int ObjectFieldNumber = 2;
    private string object_ = "";
    /// <summary>
    /// Name of the GCS object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Object {
      get { return object_; }
      set {
        object_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "generation_number" field.</summary>
    public const int GenerationNumberFieldNumber = 3;
    private long generationNumber_;
    /// <summary>
    /// Generation number of the GCS object. This is used to ensure that the
    /// ExecStep specified by this PatchJob does not change.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long GenerationNumber {
      get { return generationNumber_; }
      set {
        generationNumber_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GcsObject);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GcsObject other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Bucket != other.Bucket) return false;
      if (Object != other.Object) return false;
      if (GenerationNumber != other.GenerationNumber) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Bucket.Length != 0) hash ^= Bucket.GetHashCode();
      if (Object.Length != 0) hash ^= Object.GetHashCode();
      if (GenerationNumber != 0L) hash ^= GenerationNumber.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Bucket.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Bucket);
      }
      if (Object.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Object);
      }
      if (GenerationNumber != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(GenerationNumber);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Bucket.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Bucket);
      }
      if (Object.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Object);
      }
      if (GenerationNumber != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(GenerationNumber);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Bucket.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Bucket);
      }
      if (Object.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Object);
      }
      if (GenerationNumber != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(GenerationNumber);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GcsObject other) {
      if (other == null) {
        return;
      }
      if (other.Bucket.Length != 0) {
        Bucket = other.Bucket;
      }
      if (other.Object.Length != 0) {
        Object = other.Object;
      }
      if (other.GenerationNumber != 0L) {
        GenerationNumber = other.GenerationNumber;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Bucket = input.ReadString();
            break;
          }
          case 18: {
            Object = input.ReadString();
            break;
          }
          case 24: {
            GenerationNumber = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Bucket = input.ReadString();
            break;
          }
          case 18: {
            Object = input.ReadString();
            break;
          }
          case 24: {
            GenerationNumber = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
