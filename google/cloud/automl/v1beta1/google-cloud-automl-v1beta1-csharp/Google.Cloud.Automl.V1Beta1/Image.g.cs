// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/automl/v1beta1/image.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Automl.V1Beta1 {

  /// <summary>Holder for reflection information generated from google/cloud/automl/v1beta1/image.proto</summary>
  public static partial class ImageReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/automl/v1beta1/image.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ImageReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cidnb29nbGUvY2xvdWQvYXV0b21sL3YxYmV0YTEvaW1hZ2UucHJvdG8SG2dv",
            "b2dsZS5jbG91ZC5hdXRvbWwudjFiZXRhMRoZZ29vZ2xlL2FwaS9yZXNvdXJj",
            "ZS5wcm90bxoxZ29vZ2xlL2Nsb3VkL2F1dG9tbC92MWJldGExL2Fubm90YXRp",
            "b25fc3BlYy5wcm90bxowZ29vZ2xlL2Nsb3VkL2F1dG9tbC92MWJldGExL2Ns",
            "YXNzaWZpY2F0aW9uLnByb3RvGh9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1w",
            "LnByb3RvGhxnb29nbGUvYXBpL2Fubm90YXRpb25zLnByb3RvInIKIkltYWdl",
            "Q2xhc3NpZmljYXRpb25EYXRhc2V0TWV0YWRhdGESTAoTY2xhc3NpZmljYXRp",
            "b25fdHlwZRgBIAEoDjIvLmdvb2dsZS5jbG91ZC5hdXRvbWwudjFiZXRhMS5D",
            "bGFzc2lmaWNhdGlvblR5cGUiJQojSW1hZ2VPYmplY3REZXRlY3Rpb25EYXRh",
            "c2V0TWV0YWRhdGEisgEKIEltYWdlQ2xhc3NpZmljYXRpb25Nb2RlbE1ldGFk",
            "YXRhEhUKDWJhc2VfbW9kZWxfaWQYASABKAkSFAoMdHJhaW5fYnVkZ2V0GAIg",
            "ASgDEhIKCnRyYWluX2Nvc3QYAyABKAMSEwoLc3RvcF9yZWFzb24YBSABKAkS",
            "EgoKbW9kZWxfdHlwZRgHIAEoCRIQCghub2RlX3FwcxgNIAEoARISCgpub2Rl",
            "X2NvdW50GA4gASgDIr4BCiFJbWFnZU9iamVjdERldGVjdGlvbk1vZGVsTWV0",
            "YWRhdGESEgoKbW9kZWxfdHlwZRgBIAEoCRISCgpub2RlX2NvdW50GAMgASgD",
            "EhAKCG5vZGVfcXBzGAQgASgBEhMKC3N0b3BfcmVhc29uGAUgASgJEiUKHXRy",
            "YWluX2J1ZGdldF9taWxsaV9ub2RlX2hvdXJzGAYgASgDEiMKG3RyYWluX2Nv",
            "c3RfbWlsbGlfbm9kZV9ob3VycxgHIAEoAyJACipJbWFnZUNsYXNzaWZpY2F0",
            "aW9uTW9kZWxEZXBsb3ltZW50TWV0YWRhdGESEgoKbm9kZV9jb3VudBgBIAEo",
            "AyJBCitJbWFnZU9iamVjdERldGVjdGlvbk1vZGVsRGVwbG95bWVudE1ldGFk",
            "YXRhEhIKCm5vZGVfY291bnQYASABKANCsQEKH2NvbS5nb29nbGUuY2xvdWQu",
            "YXV0b21sLnYxYmV0YTFCCkltYWdlUHJvdG9QAVpBZ29vZ2xlLmdvbGFuZy5v",
            "cmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9jbG91ZC9hdXRvbWwvdjFiZXRhMTth",
            "dXRvbWzKAhtHb29nbGVcQ2xvdWRcQXV0b01sXFYxYmV0YTHqAh5Hb29nbGU6",
            "OkNsb3VkOjpBdXRvTUw6OlYxYmV0YTFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.ResourceReflection.Descriptor, global::Google.Cloud.Automl.V1Beta1.AnnotationSpecReflection.Descriptor, global::Google.Cloud.Automl.V1Beta1.ClassificationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Automl.V1Beta1.ImageClassificationDatasetMetadata), global::Google.Cloud.Automl.V1Beta1.ImageClassificationDatasetMetadata.Parser, new[]{ "ClassificationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Automl.V1Beta1.ImageObjectDetectionDatasetMetadata), global::Google.Cloud.Automl.V1Beta1.ImageObjectDetectionDatasetMetadata.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Automl.V1Beta1.ImageClassificationModelMetadata), global::Google.Cloud.Automl.V1Beta1.ImageClassificationModelMetadata.Parser, new[]{ "BaseModelId", "TrainBudget", "TrainCost", "StopReason", "ModelType", "NodeQps", "NodeCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Automl.V1Beta1.ImageObjectDetectionModelMetadata), global::Google.Cloud.Automl.V1Beta1.ImageObjectDetectionModelMetadata.Parser, new[]{ "ModelType", "NodeCount", "NodeQps", "StopReason", "TrainBudgetMilliNodeHours", "TrainCostMilliNodeHours" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Automl.V1Beta1.ImageClassificationModelDeploymentMetadata), global::Google.Cloud.Automl.V1Beta1.ImageClassificationModelDeploymentMetadata.Parser, new[]{ "NodeCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Automl.V1Beta1.ImageObjectDetectionModelDeploymentMetadata), global::Google.Cloud.Automl.V1Beta1.ImageObjectDetectionModelDeploymentMetadata.Parser, new[]{ "NodeCount" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Dataset metadata that is specific to image classification.
  /// </summary>
  public sealed partial class ImageClassificationDatasetMetadata : pb::IMessage<ImageClassificationDatasetMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ImageClassificationDatasetMetadata> _parser = new pb::MessageParser<ImageClassificationDatasetMetadata>(() => new ImageClassificationDatasetMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageClassificationDatasetMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Automl.V1Beta1.ImageReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationDatasetMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationDatasetMetadata(ImageClassificationDatasetMetadata other) : this() {
      classificationType_ = other.classificationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationDatasetMetadata Clone() {
      return new ImageClassificationDatasetMetadata(this);
    }

    /// <summary>Field number for the "classification_type" field.</summary>
    public const int ClassificationTypeFieldNumber = 1;
    private global::Google.Cloud.Automl.V1Beta1.ClassificationType classificationType_ = global::Google.Cloud.Automl.V1Beta1.ClassificationType.Unspecified;
    /// <summary>
    /// Required. Type of the classification problem.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Automl.V1Beta1.ClassificationType ClassificationType {
      get { return classificationType_; }
      set {
        classificationType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageClassificationDatasetMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageClassificationDatasetMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClassificationType != other.ClassificationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ClassificationType != global::Google.Cloud.Automl.V1Beta1.ClassificationType.Unspecified) hash ^= ClassificationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ClassificationType != global::Google.Cloud.Automl.V1Beta1.ClassificationType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ClassificationType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ClassificationType != global::Google.Cloud.Automl.V1Beta1.ClassificationType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ClassificationType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ClassificationType != global::Google.Cloud.Automl.V1Beta1.ClassificationType.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ClassificationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageClassificationDatasetMetadata other) {
      if (other == null) {
        return;
      }
      if (other.ClassificationType != global::Google.Cloud.Automl.V1Beta1.ClassificationType.Unspecified) {
        ClassificationType = other.ClassificationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ClassificationType = (global::Google.Cloud.Automl.V1Beta1.ClassificationType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ClassificationType = (global::Google.Cloud.Automl.V1Beta1.ClassificationType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Dataset metadata specific to image object detection.
  /// </summary>
  public sealed partial class ImageObjectDetectionDatasetMetadata : pb::IMessage<ImageObjectDetectionDatasetMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ImageObjectDetectionDatasetMetadata> _parser = new pb::MessageParser<ImageObjectDetectionDatasetMetadata>(() => new ImageObjectDetectionDatasetMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageObjectDetectionDatasetMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Automl.V1Beta1.ImageReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionDatasetMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionDatasetMetadata(ImageObjectDetectionDatasetMetadata other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionDatasetMetadata Clone() {
      return new ImageObjectDetectionDatasetMetadata(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageObjectDetectionDatasetMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageObjectDetectionDatasetMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageObjectDetectionDatasetMetadata other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Model metadata for image classification.
  /// </summary>
  public sealed partial class ImageClassificationModelMetadata : pb::IMessage<ImageClassificationModelMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ImageClassificationModelMetadata> _parser = new pb::MessageParser<ImageClassificationModelMetadata>(() => new ImageClassificationModelMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageClassificationModelMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Automl.V1Beta1.ImageReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelMetadata(ImageClassificationModelMetadata other) : this() {
      baseModelId_ = other.baseModelId_;
      trainBudget_ = other.trainBudget_;
      trainCost_ = other.trainCost_;
      stopReason_ = other.stopReason_;
      modelType_ = other.modelType_;
      nodeQps_ = other.nodeQps_;
      nodeCount_ = other.nodeCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelMetadata Clone() {
      return new ImageClassificationModelMetadata(this);
    }

    /// <summary>Field number for the "base_model_id" field.</summary>
    public const int BaseModelIdFieldNumber = 1;
    private string baseModelId_ = "";
    /// <summary>
    /// Optional. The ID of the `base` model. If it is specified, the new model
    /// will be created based on the `base` model. Otherwise, the new model will be
    /// created from scratch. The `base` model must be in the same
    /// `project` and `location` as the new model to create, and have the same
    /// `model_type`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BaseModelId {
      get { return baseModelId_; }
      set {
        baseModelId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "train_budget" field.</summary>
    public const int TrainBudgetFieldNumber = 2;
    private long trainBudget_;
    /// <summary>
    /// Required. The train budget of creating this model, expressed in hours. The
    /// actual `train_cost` will be equal or less than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainBudget {
      get { return trainBudget_; }
      set {
        trainBudget_ = value;
      }
    }

    /// <summary>Field number for the "train_cost" field.</summary>
    public const int TrainCostFieldNumber = 3;
    private long trainCost_;
    /// <summary>
    /// Output only. The actual train cost of creating this model, expressed in
    /// hours. If this model is created from a `base` model, the train cost used
    /// to create the `base` model are not included.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainCost {
      get { return trainCost_; }
      set {
        trainCost_ = value;
      }
    }

    /// <summary>Field number for the "stop_reason" field.</summary>
    public const int StopReasonFieldNumber = 5;
    private string stopReason_ = "";
    /// <summary>
    /// Output only. The reason that this create model operation stopped,
    /// e.g. `BUDGET_REACHED`, `MODEL_CONVERGED`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StopReason {
      get { return stopReason_; }
      set {
        stopReason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_type" field.</summary>
    public const int ModelTypeFieldNumber = 7;
    private string modelType_ = "";
    /// <summary>
    /// Optional. Type of the model. The available values are:
    /// *   `cloud` - Model to be used via prediction calls to AutoML API.
    ///               This is the default value.
    /// *   `mobile-low-latency-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile or edge device
    ///               with TensorFlow afterwards. Expected to have low latency, but
    ///               may have lower prediction quality than other models.
    /// *   `mobile-versatile-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile or edge device
    ///               with TensorFlow afterwards.
    /// *   `mobile-high-accuracy-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile or edge device
    ///               with TensorFlow afterwards.  Expected to have a higher
    ///               latency, but should also have a higher prediction quality
    ///               than other models.
    /// *   `mobile-core-ml-low-latency-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile device with Core
    ///               ML afterwards. Expected to have low latency, but may have
    ///               lower prediction quality than other models.
    /// *   `mobile-core-ml-versatile-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile device with Core
    ///               ML afterwards.
    /// *   `mobile-core-ml-high-accuracy-1` - A model that, in addition to
    ///               providing prediction via AutoML API, can also be exported
    ///               (see [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile device with
    ///               Core ML afterwards.  Expected to have a higher latency, but
    ///               should also have a higher prediction quality than other
    ///               models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelType {
      get { return modelType_; }
      set {
        modelType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "node_qps" field.</summary>
    public const int NodeQpsFieldNumber = 13;
    private double nodeQps_;
    /// <summary>
    /// Output only. An approximate number of online prediction QPS that can
    /// be supported by this model per each node on which it is deployed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double NodeQps {
      get { return nodeQps_; }
      set {
        nodeQps_ = value;
      }
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 14;
    private long nodeCount_;
    /// <summary>
    /// Output only. The number of nodes this model is deployed on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the node_qps field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageClassificationModelMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageClassificationModelMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseModelId != other.BaseModelId) return false;
      if (TrainBudget != other.TrainBudget) return false;
      if (TrainCost != other.TrainCost) return false;
      if (StopReason != other.StopReason) return false;
      if (ModelType != other.ModelType) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(NodeQps, other.NodeQps)) return false;
      if (NodeCount != other.NodeCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseModelId.Length != 0) hash ^= BaseModelId.GetHashCode();
      if (TrainBudget != 0L) hash ^= TrainBudget.GetHashCode();
      if (TrainCost != 0L) hash ^= TrainCost.GetHashCode();
      if (StopReason.Length != 0) hash ^= StopReason.GetHashCode();
      if (ModelType.Length != 0) hash ^= ModelType.GetHashCode();
      if (NodeQps != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(NodeQps);
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseModelId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BaseModelId);
      }
      if (TrainBudget != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TrainBudget);
      }
      if (TrainCost != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TrainCost);
      }
      if (StopReason.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopReason);
      }
      if (ModelType.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(ModelType);
      }
      if (NodeQps != 0D) {
        output.WriteRawTag(105);
        output.WriteDouble(NodeQps);
      }
      if (NodeCount != 0L) {
        output.WriteRawTag(112);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseModelId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BaseModelId);
      }
      if (TrainBudget != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TrainBudget);
      }
      if (TrainCost != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TrainCost);
      }
      if (StopReason.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopReason);
      }
      if (ModelType.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(ModelType);
      }
      if (NodeQps != 0D) {
        output.WriteRawTag(105);
        output.WriteDouble(NodeQps);
      }
      if (NodeCount != 0L) {
        output.WriteRawTag(112);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseModelId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BaseModelId);
      }
      if (TrainBudget != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TrainBudget);
      }
      if (TrainCost != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TrainCost);
      }
      if (StopReason.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopReason);
      }
      if (ModelType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelType);
      }
      if (NodeQps != 0D) {
        size += 1 + 8;
      }
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageClassificationModelMetadata other) {
      if (other == null) {
        return;
      }
      if (other.BaseModelId.Length != 0) {
        BaseModelId = other.BaseModelId;
      }
      if (other.TrainBudget != 0L) {
        TrainBudget = other.TrainBudget;
      }
      if (other.TrainCost != 0L) {
        TrainCost = other.TrainCost;
      }
      if (other.StopReason.Length != 0) {
        StopReason = other.StopReason;
      }
      if (other.ModelType.Length != 0) {
        ModelType = other.ModelType;
      }
      if (other.NodeQps != 0D) {
        NodeQps = other.NodeQps;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            BaseModelId = input.ReadString();
            break;
          }
          case 16: {
            TrainBudget = input.ReadInt64();
            break;
          }
          case 24: {
            TrainCost = input.ReadInt64();
            break;
          }
          case 42: {
            StopReason = input.ReadString();
            break;
          }
          case 58: {
            ModelType = input.ReadString();
            break;
          }
          case 105: {
            NodeQps = input.ReadDouble();
            break;
          }
          case 112: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            BaseModelId = input.ReadString();
            break;
          }
          case 16: {
            TrainBudget = input.ReadInt64();
            break;
          }
          case 24: {
            TrainCost = input.ReadInt64();
            break;
          }
          case 42: {
            StopReason = input.ReadString();
            break;
          }
          case 58: {
            ModelType = input.ReadString();
            break;
          }
          case 105: {
            NodeQps = input.ReadDouble();
            break;
          }
          case 112: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Model metadata specific to image object detection.
  /// </summary>
  public sealed partial class ImageObjectDetectionModelMetadata : pb::IMessage<ImageObjectDetectionModelMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ImageObjectDetectionModelMetadata> _parser = new pb::MessageParser<ImageObjectDetectionModelMetadata>(() => new ImageObjectDetectionModelMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageObjectDetectionModelMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Automl.V1Beta1.ImageReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelMetadata(ImageObjectDetectionModelMetadata other) : this() {
      modelType_ = other.modelType_;
      nodeCount_ = other.nodeCount_;
      nodeQps_ = other.nodeQps_;
      stopReason_ = other.stopReason_;
      trainBudgetMilliNodeHours_ = other.trainBudgetMilliNodeHours_;
      trainCostMilliNodeHours_ = other.trainCostMilliNodeHours_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelMetadata Clone() {
      return new ImageObjectDetectionModelMetadata(this);
    }

    /// <summary>Field number for the "model_type" field.</summary>
    public const int ModelTypeFieldNumber = 1;
    private string modelType_ = "";
    /// <summary>
    /// Optional. Type of the model. The available values are:
    /// *   `cloud-high-accuracy-1` - (default) A model to be used via prediction
    ///               calls to AutoML API. Expected to have a higher latency, but
    ///               should also have a higher prediction quality than other
    ///               models.
    /// *   `cloud-low-latency-1` -  A model to be used via prediction
    ///               calls to AutoML API. Expected to have low latency, but may
    ///               have lower prediction quality than other models.
    /// *   `mobile-low-latency-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile or edge device
    ///               with TensorFlow afterwards. Expected to have low latency, but
    ///               may have lower prediction quality than other models.
    /// *   `mobile-versatile-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile or edge device
    ///               with TensorFlow afterwards.
    /// *   `mobile-high-accuracy-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1beta1.AutoMl.ExportModel]) and used on a mobile or edge device
    ///               with TensorFlow afterwards.  Expected to have a higher
    ///               latency, but should also have a higher prediction quality
    ///               than other models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelType {
      get { return modelType_; }
      set {
        modelType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 3;
    private long nodeCount_;
    /// <summary>
    /// Output only. The number of nodes this model is deployed on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the qps_per_node field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    /// <summary>Field number for the "node_qps" field.</summary>
    public const int NodeQpsFieldNumber = 4;
    private double nodeQps_;
    /// <summary>
    /// Output only. An approximate number of online prediction QPS that can
    /// be supported by this model per each node on which it is deployed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double NodeQps {
      get { return nodeQps_; }
      set {
        nodeQps_ = value;
      }
    }

    /// <summary>Field number for the "stop_reason" field.</summary>
    public const int StopReasonFieldNumber = 5;
    private string stopReason_ = "";
    /// <summary>
    /// Output only. The reason that this create model operation stopped,
    /// e.g. `BUDGET_REACHED`, `MODEL_CONVERGED`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StopReason {
      get { return stopReason_; }
      set {
        stopReason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "train_budget_milli_node_hours" field.</summary>
    public const int TrainBudgetMilliNodeHoursFieldNumber = 6;
    private long trainBudgetMilliNodeHours_;
    /// <summary>
    /// The train budget of creating this model, expressed in milli node
    /// hours i.e. 1,000 value in this field means 1 node hour. The actual
    /// `train_cost` will be equal or less than this value. If further model
    /// training ceases to provide any improvements, it will stop without using
    /// full budget and the stop_reason will be `MODEL_CONVERGED`.
    /// Note, node_hour  = actual_hour * number_of_nodes_invovled.
    /// For model type `cloud-high-accuracy-1`(default) and `cloud-low-latency-1`,
    /// the train budget must be between 20,000 and 900,000 milli node hours,
    /// inclusive. The default value is 216, 000 which represents one day in
    /// wall time.
    /// For model type `mobile-low-latency-1`, `mobile-versatile-1`,
    /// `mobile-high-accuracy-1`, `mobile-core-ml-low-latency-1`,
    /// `mobile-core-ml-versatile-1`, `mobile-core-ml-high-accuracy-1`, the train
    /// budget must be between 1,000 and 100,000 milli node hours, inclusive.
    /// The default value is 24, 000 which represents one day in wall time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainBudgetMilliNodeHours {
      get { return trainBudgetMilliNodeHours_; }
      set {
        trainBudgetMilliNodeHours_ = value;
      }
    }

    /// <summary>Field number for the "train_cost_milli_node_hours" field.</summary>
    public const int TrainCostMilliNodeHoursFieldNumber = 7;
    private long trainCostMilliNodeHours_;
    /// <summary>
    /// Output only. The actual train cost of creating this model, expressed in
    /// milli node hours, i.e. 1,000 value in this field means 1 node hour.
    /// Guaranteed to not exceed the train budget.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainCostMilliNodeHours {
      get { return trainCostMilliNodeHours_; }
      set {
        trainCostMilliNodeHours_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageObjectDetectionModelMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageObjectDetectionModelMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ModelType != other.ModelType) return false;
      if (NodeCount != other.NodeCount) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(NodeQps, other.NodeQps)) return false;
      if (StopReason != other.StopReason) return false;
      if (TrainBudgetMilliNodeHours != other.TrainBudgetMilliNodeHours) return false;
      if (TrainCostMilliNodeHours != other.TrainCostMilliNodeHours) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ModelType.Length != 0) hash ^= ModelType.GetHashCode();
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (NodeQps != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(NodeQps);
      if (StopReason.Length != 0) hash ^= StopReason.GetHashCode();
      if (TrainBudgetMilliNodeHours != 0L) hash ^= TrainBudgetMilliNodeHours.GetHashCode();
      if (TrainCostMilliNodeHours != 0L) hash ^= TrainCostMilliNodeHours.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ModelType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ModelType);
      }
      if (NodeCount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(NodeCount);
      }
      if (NodeQps != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(NodeQps);
      }
      if (StopReason.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopReason);
      }
      if (TrainBudgetMilliNodeHours != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(TrainBudgetMilliNodeHours);
      }
      if (TrainCostMilliNodeHours != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(TrainCostMilliNodeHours);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ModelType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ModelType);
      }
      if (NodeCount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(NodeCount);
      }
      if (NodeQps != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(NodeQps);
      }
      if (StopReason.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopReason);
      }
      if (TrainBudgetMilliNodeHours != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(TrainBudgetMilliNodeHours);
      }
      if (TrainCostMilliNodeHours != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(TrainCostMilliNodeHours);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ModelType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelType);
      }
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (NodeQps != 0D) {
        size += 1 + 8;
      }
      if (StopReason.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopReason);
      }
      if (TrainBudgetMilliNodeHours != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TrainBudgetMilliNodeHours);
      }
      if (TrainCostMilliNodeHours != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TrainCostMilliNodeHours);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageObjectDetectionModelMetadata other) {
      if (other == null) {
        return;
      }
      if (other.ModelType.Length != 0) {
        ModelType = other.ModelType;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      if (other.NodeQps != 0D) {
        NodeQps = other.NodeQps;
      }
      if (other.StopReason.Length != 0) {
        StopReason = other.StopReason;
      }
      if (other.TrainBudgetMilliNodeHours != 0L) {
        TrainBudgetMilliNodeHours = other.TrainBudgetMilliNodeHours;
      }
      if (other.TrainCostMilliNodeHours != 0L) {
        TrainCostMilliNodeHours = other.TrainCostMilliNodeHours;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ModelType = input.ReadString();
            break;
          }
          case 24: {
            NodeCount = input.ReadInt64();
            break;
          }
          case 33: {
            NodeQps = input.ReadDouble();
            break;
          }
          case 42: {
            StopReason = input.ReadString();
            break;
          }
          case 48: {
            TrainBudgetMilliNodeHours = input.ReadInt64();
            break;
          }
          case 56: {
            TrainCostMilliNodeHours = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ModelType = input.ReadString();
            break;
          }
          case 24: {
            NodeCount = input.ReadInt64();
            break;
          }
          case 33: {
            NodeQps = input.ReadDouble();
            break;
          }
          case 42: {
            StopReason = input.ReadString();
            break;
          }
          case 48: {
            TrainBudgetMilliNodeHours = input.ReadInt64();
            break;
          }
          case 56: {
            TrainCostMilliNodeHours = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Model deployment metadata specific to Image Classification.
  /// </summary>
  public sealed partial class ImageClassificationModelDeploymentMetadata : pb::IMessage<ImageClassificationModelDeploymentMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ImageClassificationModelDeploymentMetadata> _parser = new pb::MessageParser<ImageClassificationModelDeploymentMetadata>(() => new ImageClassificationModelDeploymentMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageClassificationModelDeploymentMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Automl.V1Beta1.ImageReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelDeploymentMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelDeploymentMetadata(ImageClassificationModelDeploymentMetadata other) : this() {
      nodeCount_ = other.nodeCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelDeploymentMetadata Clone() {
      return new ImageClassificationModelDeploymentMetadata(this);
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 1;
    private long nodeCount_;
    /// <summary>
    /// Input only. The number of nodes to deploy the model on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the model's
    ///
    /// [node_qps][google.cloud.automl.v1beta1.ImageClassificationModelMetadata.node_qps].
    /// Must be between 1 and 100, inclusive on both ends.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageClassificationModelDeploymentMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageClassificationModelDeploymentMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeCount != other.NodeCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (NodeCount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (NodeCount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageClassificationModelDeploymentMetadata other) {
      if (other == null) {
        return;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Model deployment metadata specific to Image Object Detection.
  /// </summary>
  public sealed partial class ImageObjectDetectionModelDeploymentMetadata : pb::IMessage<ImageObjectDetectionModelDeploymentMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ImageObjectDetectionModelDeploymentMetadata> _parser = new pb::MessageParser<ImageObjectDetectionModelDeploymentMetadata>(() => new ImageObjectDetectionModelDeploymentMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageObjectDetectionModelDeploymentMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Automl.V1Beta1.ImageReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelDeploymentMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelDeploymentMetadata(ImageObjectDetectionModelDeploymentMetadata other) : this() {
      nodeCount_ = other.nodeCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelDeploymentMetadata Clone() {
      return new ImageObjectDetectionModelDeploymentMetadata(this);
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 1;
    private long nodeCount_;
    /// <summary>
    /// Input only. The number of nodes to deploy the model on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the model's
    ///
    /// [qps_per_node][google.cloud.automl.v1beta1.ImageObjectDetectionModelMetadata.qps_per_node].
    /// Must be between 1 and 100, inclusive on both ends.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageObjectDetectionModelDeploymentMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageObjectDetectionModelDeploymentMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeCount != other.NodeCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (NodeCount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (NodeCount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageObjectDetectionModelDeploymentMetadata other) {
      if (other == null) {
        return;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
