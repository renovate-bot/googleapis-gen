// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/security/privateca/v1beta1/resources.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Security.PrivateCA.V1Beta1 {

  /// <summary>Holder for reflection information generated from google/cloud/security/privateca/v1beta1/resources.proto</summary>
  public static partial class ResourcesReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/security/privateca/v1beta1/resources.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ResourcesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cjdnb29nbGUvY2xvdWQvc2VjdXJpdHkvcHJpdmF0ZWNhL3YxYmV0YTEvcmVz",
            "b3VyY2VzLnByb3RvEidnb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNh",
            "LnYxYmV0YTEaH2dvb2dsZS9hcGkvZmllbGRfYmVoYXZpb3IucHJvdG8aGWdv",
            "b2dsZS9hcGkvcmVzb3VyY2UucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi9kdXJh",
            "dGlvbi5wcm90bxofZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90bxoe",
            "Z29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGhxnb29nbGUvYXBpL2Fu",
            "bm90YXRpb25zLnByb3RvIqgcChRDZXJ0aWZpY2F0ZUF1dGhvcml0eRIRCgRu",
            "YW1lGAEgASgJQgPgQQMSWAoEdHlwZRgCIAEoDjJCLmdvb2dsZS5jbG91ZC5z",
            "ZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZUF1dGhvcml0",
            "eS5UeXBlQgbgQQLgQQUSWAoEdGllchgDIAEoDjJCLmdvb2dsZS5jbG91ZC5z",
            "ZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZUF1dGhvcml0",
            "eS5UaWVyQgbgQQLgQQUSUgoGY29uZmlnGAQgASgLMjouZ29vZ2xlLmNsb3Vk",
            "LnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGExLkNlcnRpZmljYXRlQ29uZmln",
            "QgbgQQLgQQUSMAoIbGlmZXRpbWUYBSABKAsyGS5nb29nbGUucHJvdG9idWYu",
            "RHVyYXRpb25CA+BBAhJmCghrZXlfc3BlYxgGIAEoCzJMLmdvb2dsZS5jbG91",
            "ZC5zZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZUF1dGhv",
            "cml0eS5LZXlWZXJzaW9uU3BlY0IG4EEC4EEFEnkKEmNlcnRpZmljYXRlX3Bv",
            "bGljeRgHIAEoCzJYLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2Eu",
            "djFiZXRhMS5DZXJ0aWZpY2F0ZUF1dGhvcml0eS5DZXJ0aWZpY2F0ZUF1dGhv",
            "cml0eVBvbGljeUID4EEBEmoKD2lzc3Vpbmdfb3B0aW9ucxgIIAEoCzJMLmdv",
            "b2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5DZXJ0aWZp",
            "Y2F0ZUF1dGhvcml0eS5Jc3N1aW5nT3B0aW9uc0ID4EEBElsKEnN1Ym9yZGlu",
            "YXRlX2NvbmZpZxgTIAEoCzI6Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2",
            "YXRlY2EudjFiZXRhMS5TdWJvcmRpbmF0ZUNvbmZpZ0ID4EEBElcKBXN0YXRl",
            "GAogASgOMkMuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJl",
            "dGExLkNlcnRpZmljYXRlQXV0aG9yaXR5LlN0YXRlQgPgQQMSIAoTcGVtX2Nh",
            "X2NlcnRpZmljYXRlcxgJIAMoCUID4EEDEmkKG2NhX2NlcnRpZmljYXRlX2Rl",
            "c2NyaXB0aW9ucxgMIAMoCzI/Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2",
            "YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZURlc2NyaXB0aW9uQgPgQQMSFwoK",
            "Z2NzX2J1Y2tldBgNIAEoCUID4EEFEmIKC2FjY2Vzc191cmxzGA4gASgLMkgu",
            "Z29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGExLkNlcnRp",
            "ZmljYXRlQXV0aG9yaXR5LkFjY2Vzc1VybHNCA+BBAxI0CgtjcmVhdGVfdGlt",
            "ZRgPIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxI0Cgt1",
            "cGRhdGVfdGltZRgQIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBC",
            "A+BBAxI0CgtkZWxldGVfdGltZRgRIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5U",
            "aW1lc3RhbXBCA+BBAxJeCgZsYWJlbHMYEiADKAsySS5nb29nbGUuY2xvdWQu",
            "c2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuQ2VydGlmaWNhdGVBdXRob3Jp",
            "dHkuTGFiZWxzRW50cnlCA+BBARpXCg5Jc3N1aW5nT3B0aW9ucxIgChNpbmNs",
            "dWRlX2NhX2NlcnRfdXJsGAEgASgIQgPgQQISIwoWaW5jbHVkZV9jcmxfYWNj",
            "ZXNzX3VybBgCIAEoCEID4EECGr4JChpDZXJ0aWZpY2F0ZUF1dGhvcml0eVBv",
            "bGljeRKOAQoTYWxsb3dlZF9jb25maWdfbGlzdBgBIAEoCzJqLmdvb2dsZS5j",
            "bG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZUF1",
            "dGhvcml0eS5DZXJ0aWZpY2F0ZUF1dGhvcml0eVBvbGljeS5BbGxvd2VkQ29u",
            "ZmlnTGlzdEID4EEBSAASZgoXb3ZlcndyaXRlX2NvbmZpZ192YWx1ZXMYAiAB",
            "KAsyPi5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEu",
            "UmV1c2FibGVDb25maWdXcmFwcGVyQgPgQQFIABJiCiNhbGxvd2VkX2xvY2F0",
            "aW9uc19hbmRfb3JnYW5pemF0aW9ucxgDIAMoCzIwLmdvb2dsZS5jbG91ZC5z",
            "ZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5TdWJqZWN0QgPgQQESIQoUYWxs",
            "b3dlZF9jb21tb25fbmFtZXMYBCADKAlCA+BBARKKAQoMYWxsb3dlZF9zYW5z",
            "GAUgASgLMm8uZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJl",
            "dGExLkNlcnRpZmljYXRlQXV0aG9yaXR5LkNlcnRpZmljYXRlQXV0aG9yaXR5",
            "UG9saWN5LkFsbG93ZWRTdWJqZWN0QWx0TmFtZXNCA+BBARI4ChBtYXhpbXVt",
            "X2xpZmV0aW1lGAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgPg",
            "QQESiwEKFmFsbG93ZWRfaXNzdWFuY2VfbW9kZXMYCCABKAsyZi5nb29nbGUu",
            "Y2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuQ2VydGlmaWNhdGVB",
            "dXRob3JpdHkuQ2VydGlmaWNhdGVBdXRob3JpdHlQb2xpY3kuSXNzdWFuY2VN",
            "b2Rlc0ID4EEBGncKEUFsbG93ZWRDb25maWdMaXN0EmIKFWFsbG93ZWRfY29u",
            "ZmlnX3ZhbHVlcxgBIAMoCzI+Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2",
            "YXRlY2EudjFiZXRhMS5SZXVzYWJsZUNvbmZpZ1dyYXBwZXJCA+BBAhreAQoW",
            "QWxsb3dlZFN1YmplY3RBbHROYW1lcxIeChFhbGxvd2VkX2Ruc19uYW1lcxgB",
            "IAMoCUID4EEBEhkKDGFsbG93ZWRfdXJpcxgCIAMoCUID4EEBEiQKF2FsbG93",
            "ZWRfZW1haWxfYWRkcmVzc2VzGAMgAygJQgPgQQESGAoLYWxsb3dlZF9pcHMY",
            "BCADKAlCA+BBARIpChxhbGxvd19nbG9iYmluZ19kbnNfd2lsZGNhcmRzGAUg",
            "ASgIQgPgQQESHgoRYWxsb3dfY3VzdG9tX3NhbnMYBiABKAhCA+BBARpgCg1J",
            "c3N1YW5jZU1vZGVzEiUKGGFsbG93X2Nzcl9iYXNlZF9pc3N1YW5jZRgBIAEo",
            "CEID4EECEigKG2FsbG93X2NvbmZpZ19iYXNlZF9pc3N1YW5jZRgCIAEoCEID",
            "4EECQg8KDWNvbmZpZ19wb2xpY3kaRwoKQWNjZXNzVXJscxIhChljYV9jZXJ0",
            "aWZpY2F0ZV9hY2Nlc3NfdXJsGAEgASgJEhYKDmNybF9hY2Nlc3NfdXJsGAIg",
            "ASgJGq8BCg5LZXlWZXJzaW9uU3BlYxIkChVjbG91ZF9rbXNfa2V5X3ZlcnNp",
            "b24YASABKAlCA+BBAkgAEmkKCWFsZ29yaXRobRgCIAEoDjJPLmdvb2dsZS5j",
            "bG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZUF1",
            "dGhvcml0eS5TaWduSGFzaEFsZ29yaXRobUID4EECSABCDAoKS2V5VmVyc2lv",
            "bhotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6",
            "AjgBIj4KBFR5cGUSFAoQVFlQRV9VTlNQRUNJRklFRBAAEg8KC1NFTEZfU0lH",
            "TkVEEAESDwoLU1VCT1JESU5BVEUQAiI4CgRUaWVyEhQKEFRJRVJfVU5TUEVD",
            "SUZJRUQQABIOCgpFTlRFUlBSSVNFEAESCgoGREVWT1BTEAIiZwoFU3RhdGUS",
            "FQoRU1RBVEVfVU5TUEVDSUZJRUQQABILCgdFTkFCTEVEEAESDAoIRElTQUJM",
            "RUQQAhIWChJQRU5ESU5HX0FDVElWQVRJT04QAxIUChBQRU5ESU5HX0RFTEVU",
            "SU9OEAQi/AEKEVNpZ25IYXNoQWxnb3JpdGhtEiMKH1NJR05fSEFTSF9BTEdP",
            "UklUSE1fVU5TUEVDSUZJRUQQABIXChNSU0FfUFNTXzIwNDhfU0hBMjU2EAES",
            "FwoTUlNBX1BTU18zMDcyX1NIQTI1NhACEhcKE1JTQV9QU1NfNDA5Nl9TSEEy",
            "NTYQAxIZChVSU0FfUEtDUzFfMjA0OF9TSEEyNTYQBhIZChVSU0FfUEtDUzFf",
            "MzA3Ml9TSEEyNTYQBxIZChVSU0FfUEtDUzFfNDA5Nl9TSEEyNTYQCBISCg5F",
            "Q19QMjU2X1NIQTI1NhAEEhIKDkVDX1AzODRfU0hBMzg0EAU6iwHqQYcBCi1w",
            "cml2YXRlY2EuZ29vZ2xlYXBpcy5jb20vQ2VydGlmaWNhdGVBdXRob3JpdHkS",
            "VnByb2plY3RzL3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0aW9ufS9jZXJ0",
            "aWZpY2F0ZUF1dGhvcml0aWVzL3tjZXJ0aWZpY2F0ZV9hdXRob3JpdHl9IvkH",
            "ChlDZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0EhEKBG5hbWUYASABKAlCA+BB",
            "AxIcCg9zZXF1ZW5jZV9udW1iZXIYAiABKANCA+BBAxJ4ChRyZXZva2VkX2Nl",
            "cnRpZmljYXRlcxgDIAMoCzJVLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2",
            "YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0LlJldm9r",
            "ZWRDZXJ0aWZpY2F0ZUID4EEDEhQKB3BlbV9jcmwYBCABKAlCA+BBAxIXCgph",
            "Y2Nlc3NfdXJsGAUgASgJQgPgQQMSXAoFc3RhdGUYBiABKA4ySC5nb29nbGUu",
            "Y2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuQ2VydGlmaWNhdGVS",
            "ZXZvY2F0aW9uTGlzdC5TdGF0ZUID4EEDEjQKC2NyZWF0ZV90aW1lGAcgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjQKC3VwZGF0ZV90",
            "aW1lGAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEmMK",
            "BmxhYmVscxgJIAMoCzJOLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRl",
            "Y2EudjFiZXRhMS5DZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0LkxhYmVsc0Vu",
            "dHJ5QgPgQQEamgEKElJldm9rZWRDZXJ0aWZpY2F0ZRITCgtjZXJ0aWZpY2F0",
            "ZRgBIAEoCRIZChFoZXhfc2VyaWFsX251bWJlchgCIAEoCRJUChFyZXZvY2F0",
            "aW9uX3JlYXNvbhgDIAEoDjI5Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2",
            "YXRlY2EudjFiZXRhMS5SZXZvY2F0aW9uUmVhc29uGi0KC0xhYmVsc0VudHJ5",
            "EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiOgoFU3RhdGUSFQoR",
            "U1RBVEVfVU5TUEVDSUZJRUQQABIKCgZBQ1RJVkUQARIOCgpTVVBFUlNFREVE",
            "EAI6ygHqQcYBCjJwcml2YXRlY2EuZ29vZ2xlYXBpcy5jb20vQ2VydGlmaWNh",
            "dGVSZXZvY2F0aW9uTGlzdBKPAXByb2plY3RzL3twcm9qZWN0fS9sb2NhdGlv",
            "bnMve2xvY2F0aW9ufS9jZXJ0aWZpY2F0ZUF1dGhvcml0aWVzL3tjZXJ0aWZp",
            "Y2F0ZV9hdXRob3JpdHl9L2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3RzL3tj",
            "ZXJ0aWZpY2F0ZV9yZXZvY2F0aW9uX2xpc3R9IpoICgtDZXJ0aWZpY2F0ZRIR",
            "CgRuYW1lGAEgASgJQgPgQQMSFgoHcGVtX2NzchgCIAEoCUID4EEFSAASUQoG",
            "Y29uZmlnGAMgASgLMjouZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVj",
            "YS52MWJldGExLkNlcnRpZmljYXRlQ29uZmlnQgPgQQVIABIzCghsaWZldGlt",
            "ZRgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIG4EEC4EEFEmcK",
            "EnJldm9jYXRpb25fZGV0YWlscxgFIAEoCzJGLmdvb2dsZS5jbG91ZC5zZWN1",
            "cml0eS5wcml2YXRlY2EudjFiZXRhMS5DZXJ0aWZpY2F0ZS5SZXZvY2F0aW9u",
            "RGV0YWlsc0ID4EEDEhwKD3BlbV9jZXJ0aWZpY2F0ZRgGIAEoCUID4EEDEmUK",
            "F2NlcnRpZmljYXRlX2Rlc2NyaXB0aW9uGAcgASgLMj8uZ29vZ2xlLmNsb3Vk",
            "LnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGExLkNlcnRpZmljYXRlRGVzY3Jp",
            "cHRpb25CA+BBAxIiChVwZW1fY2VydGlmaWNhdGVfY2hhaW4YCCADKAlCA+BB",
            "AxI0CgtjcmVhdGVfdGltZRgJIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1l",
            "c3RhbXBCA+BBAxI0Cgt1cGRhdGVfdGltZRgKIAEoCzIaLmdvb2dsZS5wcm90",
            "b2J1Zi5UaW1lc3RhbXBCA+BBAxJVCgZsYWJlbHMYCyADKAsyQC5nb29nbGUu",
            "Y2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuQ2VydGlmaWNhdGUu",
            "TGFiZWxzRW50cnlCA+BBARqdAQoRUmV2b2NhdGlvbkRldGFpbHMSUwoQcmV2",
            "b2NhdGlvbl9zdGF0ZRgBIAEoDjI5Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5w",
            "cml2YXRlY2EudjFiZXRhMS5SZXZvY2F0aW9uUmVhc29uEjMKD3Jldm9jYXRp",
            "b25fdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAaLQoL",
            "TGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ATqd",
            "AepBmQEKJHByaXZhdGVjYS5nb29nbGVhcGlzLmNvbS9DZXJ0aWZpY2F0ZRJx",
            "cHJvamVjdHMve3Byb2plY3R9L2xvY2F0aW9ucy97bG9jYXRpb259L2NlcnRp",
            "ZmljYXRlQXV0aG9yaXRpZXMve2NlcnRpZmljYXRlX2F1dGhvcml0eX0vY2Vy",
            "dGlmaWNhdGVzL3tjZXJ0aWZpY2F0ZX1CFAoSY2VydGlmaWNhdGVfY29uZmln",
            "Iv8DCg5SZXVzYWJsZUNvbmZpZxIRCgRuYW1lGAEgASgJQgPgQQMSUgoGdmFs",
            "dWVzGAIgASgLMj0uZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52",
            "MWJldGExLlJldXNhYmxlQ29uZmlnVmFsdWVzQgPgQQISGAoLZGVzY3JpcHRp",
            "b24YAyABKAlCA+BBARI0CgtjcmVhdGVfdGltZRgEIAEoCzIaLmdvb2dsZS5w",
            "cm90b2J1Zi5UaW1lc3RhbXBCA+BBAxI0Cgt1cGRhdGVfdGltZRgFIAEoCzIa",
            "Lmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxJYCgZsYWJlbHMYBiAD",
            "KAsyQy5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEu",
            "UmV1c2FibGVDb25maWcuTGFiZWxzRW50cnlCA+BBARotCgtMYWJlbHNFbnRy",
            "eRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBOnfqQXQKJ3ByaXZh",
            "dGVjYS5nb29nbGVhcGlzLmNvbS9SZXVzYWJsZUNvbmZpZxJJcHJvamVjdHMv",
            "e3Byb2plY3R9L2xvY2F0aW9ucy97bG9jYXRpb259L3JldXNhYmxlQ29uZmln",
            "cy97cmV1c2FibGVfY29uZmlnfSKJBAoUUmV1c2FibGVDb25maWdWYWx1ZXMS",
            "SQoJa2V5X3VzYWdlGAEgASgLMjEuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnBy",
            "aXZhdGVjYS52MWJldGExLktleVVzYWdlQgPgQQESYAoKY2Ffb3B0aW9ucxgC",
            "IAEoCzJHLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjFiZXRh",
            "MS5SZXVzYWJsZUNvbmZpZ1ZhbHVlcy5DYU9wdGlvbnNCA+BBARJKCgpwb2xp",
            "Y3lfaWRzGAMgAygLMjEuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVj",
            "YS52MWJldGExLk9iamVjdElkQgPgQQESHQoQYWlhX29jc3Bfc2VydmVycxgE",
            "IAMoCUID4EEBEloKFWFkZGl0aW9uYWxfZXh0ZW5zaW9ucxgFIAMoCzI2Lmdv",
            "b2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5YNTA5RXh0",
            "ZW5zaW9uQgPgQQEafQoJQ2FPcHRpb25zEi4KBWlzX2NhGAEgASgLMhouZ29v",
            "Z2xlLnByb3RvYnVmLkJvb2xWYWx1ZUID4EEBEkAKFm1heF9pc3N1ZXJfcGF0",
            "aF9sZW5ndGgYAiABKAsyGy5nb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZUID",
            "4EEBIq4BChVSZXVzYWJsZUNvbmZpZ1dyYXBwZXISHgoPcmV1c2FibGVfY29u",
            "ZmlnGAEgASgJQgPgQQJIABJkChZyZXVzYWJsZV9jb25maWdfdmFsdWVzGAIg",
            "ASgLMj0uZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGEx",
            "LlJldXNhYmxlQ29uZmlnVmFsdWVzQgPgQQJIAEIPCg1jb25maWdfdmFsdWVz",
            "IvwBChFTdWJvcmRpbmF0ZUNvbmZpZxIkChVjZXJ0aWZpY2F0ZV9hdXRob3Jp",
            "dHkYASABKAlCA+BBAkgAEnIKEHBlbV9pc3N1ZXJfY2hhaW4YAiABKAsyUS5n",
            "b29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuU3Vib3Jk",
            "aW5hdGVDb25maWcuU3Vib3JkaW5hdGVDb25maWdDaGFpbkID4EECSAAaNwoW",
            "U3Vib3JkaW5hdGVDb25maWdDaGFpbhIdChBwZW1fY2VydGlmaWNhdGVzGAEg",
            "AygJQgPgQQJCFAoSc3Vib3JkaW5hdGVfY29uZmlnIrIBCglQdWJsaWNLZXkS",
            "TQoEdHlwZRgBIAEoDjI6Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRl",
            "Y2EudjFiZXRhMS5QdWJsaWNLZXkuS2V5VHlwZUID4EECEhAKA2tleRgCIAEo",
            "DEID4EECIkQKB0tleVR5cGUSGAoUS0VZX1RZUEVfVU5TUEVDSUZJRUQQABIP",
            "CgtQRU1fUlNBX0tFWRABEg4KClBFTV9FQ19LRVkQAiLyAwoRQ2VydGlmaWNh",
            "dGVDb25maWcSZQoOc3ViamVjdF9jb25maWcYASABKAsySC5nb29nbGUuY2xv",
            "dWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuQ2VydGlmaWNhdGVDb25m",
            "aWcuU3ViamVjdENvbmZpZ0ID4EECElwKD3JldXNhYmxlX2NvbmZpZxgCIAEo",
            "CzI+Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjFiZXRhMS5S",
            "ZXVzYWJsZUNvbmZpZ1dyYXBwZXJCA+BBAhJLCgpwdWJsaWNfa2V5GAMgASgL",
            "MjIuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGExLlB1",
            "YmxpY0tleUID4EEBGsoBCg1TdWJqZWN0Q29uZmlnEkYKB3N1YmplY3QYASAB",
            "KAsyMC5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEu",
            "U3ViamVjdEID4EECEhgKC2NvbW1vbl9uYW1lGAIgASgJQgPgQQESVwoQc3Vi",
            "amVjdF9hbHRfbmFtZRgDIAEoCzI4Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5w",
            "cml2YXRlY2EudjFiZXRhMS5TdWJqZWN0QWx0TmFtZXNCA+BBASLhCAoWQ2Vy",
            "dGlmaWNhdGVEZXNjcmlwdGlvbhJvChNzdWJqZWN0X2Rlc2NyaXB0aW9uGAEg",
            "ASgLMlIuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGEx",
            "LkNlcnRpZmljYXRlRGVzY3JpcHRpb24uU3ViamVjdERlc2NyaXB0aW9uElQK",
            "DWNvbmZpZ192YWx1ZXMYAiABKAsyPS5nb29nbGUuY2xvdWQuc2VjdXJpdHku",
            "cHJpdmF0ZWNhLnYxYmV0YTEuUmV1c2FibGVDb25maWdWYWx1ZXMSRgoKcHVi",
            "bGljX2tleRgDIAEoCzIyLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRl",
            "Y2EudjFiZXRhMS5QdWJsaWNLZXkSXQoOc3ViamVjdF9rZXlfaWQYBCABKAsy",
            "RS5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuQ2Vy",
            "dGlmaWNhdGVEZXNjcmlwdGlvbi5LZXlJZBJfChBhdXRob3JpdHlfa2V5X2lk",
            "GAUgASgLMkUuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJl",
            "dGExLkNlcnRpZmljYXRlRGVzY3JpcHRpb24uS2V5SWQSHwoXY3JsX2Rpc3Ry",
            "aWJ1dGlvbl9wb2ludHMYBiADKAkSJAocYWlhX2lzc3VpbmdfY2VydGlmaWNh",
            "dGVfdXJscxgHIAMoCRJwChBjZXJ0X2ZpbmdlcnByaW50GAggASgLMlYuZ29v",
            "Z2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGExLkNlcnRpZmlj",
            "YXRlRGVzY3JpcHRpb24uQ2VydGlmaWNhdGVGaW5nZXJwcmludBrxAgoSU3Vi",
            "amVjdERlc2NyaXB0aW9uEkEKB3N1YmplY3QYASABKAsyMC5nb29nbGUuY2xv",
            "dWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTEuU3ViamVjdBITCgtjb21t",
            "b25fbmFtZRgCIAEoCRJSChBzdWJqZWN0X2FsdF9uYW1lGAMgASgLMjguZ29v",
            "Z2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGExLlN1YmplY3RB",
            "bHROYW1lcxIZChFoZXhfc2VyaWFsX251bWJlchgEIAEoCRIrCghsaWZldGlt",
            "ZRgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIzCg9ub3RfYmVm",
            "b3JlX3RpbWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjIK",
            "Dm5vdF9hZnRlcl90aW1lGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVz",
            "dGFtcBocCgVLZXlJZBITCgZrZXlfaWQYASABKAlCA+BBARotChZDZXJ0aWZp",
            "Y2F0ZUZpbmdlcnByaW50EhMKC3NoYTI1Nl9oYXNoGAEgASgJIicKCE9iamVj",
            "dElkEhsKDm9iamVjdF9pZF9wYXRoGAEgAygFQgPgQQIihQEKDVg1MDlFeHRl",
            "bnNpb24SSQoJb2JqZWN0X2lkGAEgASgLMjEuZ29vZ2xlLmNsb3VkLnNlY3Vy",
            "aXR5LnByaXZhdGVjYS52MWJldGExLk9iamVjdElkQgPgQQISFQoIY3JpdGlj",
            "YWwYAiABKAhCA+BBAhISCgV2YWx1ZRgDIAEoDEID4EECIrEFCghLZXlVc2Fn",
            "ZRJZCg5iYXNlX2tleV91c2FnZRgBIAEoCzJBLmdvb2dsZS5jbG91ZC5zZWN1",
            "cml0eS5wcml2YXRlY2EudjFiZXRhMS5LZXlVc2FnZS5LZXlVc2FnZU9wdGlv",
            "bnMSZQoSZXh0ZW5kZWRfa2V5X3VzYWdlGAIgASgLMkkuZ29vZ2xlLmNsb3Vk",
            "LnNlY3VyaXR5LnByaXZhdGVjYS52MWJldGExLktleVVzYWdlLkV4dGVuZGVk",
            "S2V5VXNhZ2VPcHRpb25zElYKG3Vua25vd25fZXh0ZW5kZWRfa2V5X3VzYWdl",
            "cxgDIAMoCzIxLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjFi",
            "ZXRhMS5PYmplY3RJZBrnAQoPS2V5VXNhZ2VPcHRpb25zEhkKEWRpZ2l0YWxf",
            "c2lnbmF0dXJlGAEgASgIEhoKEmNvbnRlbnRfY29tbWl0bWVudBgCIAEoCBIY",
            "ChBrZXlfZW5jaXBoZXJtZW50GAMgASgIEhkKEWRhdGFfZW5jaXBoZXJtZW50",
            "GAQgASgIEhUKDWtleV9hZ3JlZW1lbnQYBSABKAgSEQoJY2VydF9zaWduGAYg",
            "ASgIEhAKCGNybF9zaWduGAcgASgIEhUKDWVuY2lwaGVyX29ubHkYCCABKAgS",
            "FQoNZGVjaXBoZXJfb25seRgJIAEoCBqgAQoXRXh0ZW5kZWRLZXlVc2FnZU9w",
            "dGlvbnMSEwoLc2VydmVyX2F1dGgYASABKAgSEwoLY2xpZW50X2F1dGgYAiAB",
            "KAgSFAoMY29kZV9zaWduaW5nGAMgASgIEhgKEGVtYWlsX3Byb3RlY3Rpb24Y",
            "BCABKAgSFQoNdGltZV9zdGFtcGluZxgFIAEoCBIUCgxvY3NwX3NpZ25pbmcY",
            "BiABKAgiowEKB1N1YmplY3QSFAoMY291bnRyeV9jb2RlGAEgASgJEhQKDG9y",
            "Z2FuaXphdGlvbhgCIAEoCRIbChNvcmdhbml6YXRpb25hbF91bml0GAMgASgJ",
            "EhAKCGxvY2FsaXR5GAQgASgJEhAKCHByb3ZpbmNlGAUgASgJEhYKDnN0cmVl",
            "dF9hZGRyZXNzGAYgASgJEhMKC3Bvc3RhbF9jb2RlGAcgASgJIq4BCg9TdWJq",
            "ZWN0QWx0TmFtZXMSEQoJZG5zX25hbWVzGAEgAygJEgwKBHVyaXMYAiADKAkS",
            "FwoPZW1haWxfYWRkcmVzc2VzGAMgAygJEhQKDGlwX2FkZHJlc3NlcxgEIAMo",
            "CRJLCgtjdXN0b21fc2FucxgFIAMoCzI2Lmdvb2dsZS5jbG91ZC5zZWN1cml0",
            "eS5wcml2YXRlY2EudjFiZXRhMS5YNTA5RXh0ZW5zaW9uKocCChBSZXZvY2F0",
            "aW9uUmVhc29uEiEKHVJFVk9DQVRJT05fUkVBU09OX1VOU1BFQ0lGSUVEEAAS",
            "EgoOS0VZX0NPTVBST01JU0UQARIkCiBDRVJUSUZJQ0FURV9BVVRIT1JJVFlf",
            "Q09NUFJPTUlTRRACEhcKE0FGRklMSUFUSU9OX0NIQU5HRUQQAxIOCgpTVVBF",
            "UlNFREVEEAQSGgoWQ0VTU0FUSU9OX09GX09QRVJBVElPThAFEhQKEENFUlRJ",
            "RklDQVRFX0hPTEQQBhIXChNQUklWSUxFR0VfV0lUSERSQVdOEAcSIgoeQVRU",
            "UklCVVRFX0FVVEhPUklUWV9DT01QUk9NSVNFEAhCnwIKK2NvbS5nb29nbGUu",
            "Y2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxYmV0YTFCF1ByaXZhdGVDYVJl",
            "c291cmNlc1Byb3RvUAFaUGdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dv",
            "b2dsZWFwaXMvY2xvdWQvc2VjdXJpdHkvcHJpdmF0ZWNhL3YxYmV0YTE7cHJp",
            "dmF0ZWNh+AEBqgInR29vZ2xlLkNsb3VkLlNlY3VyaXR5LlByaXZhdGVDQS5W",
            "MUJldGExygInR29vZ2xlXENsb3VkXFNlY3VyaXR5XFByaXZhdGVDQVxWMWJl",
            "dGEx6gIrR29vZ2xlOjpDbG91ZDo6U2VjdXJpdHk6OlByaXZhdGVDQTo6VjFi",
            "ZXRhMWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Parser, new[]{ "Name", "Type", "Tier", "Config", "Lifetime", "KeySpec", "CertificatePolicy", "IssuingOptions", "SubordinateConfig", "State", "PemCaCertificates", "CaCertificateDescriptions", "GcsBucket", "AccessUrls", "CreateTime", "UpdateTime", "DeleteTime", "Labels" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type), typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier), typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State), typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.SignHashAlgorithm) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.IssuingOptions), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.IssuingOptions.Parser, new[]{ "IncludeCaCertUrl", "IncludeCrlAccessUrl" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Parser, new[]{ "AllowedConfigList", "OverwriteConfigValues", "AllowedLocationsAndOrganizations", "AllowedCommonNames", "AllowedSans", "MaximumLifetime", "AllowedIssuanceModes" }, new[]{ "ConfigPolicy" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList.Parser, new[]{ "AllowedConfigValues" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedSubjectAltNames), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedSubjectAltNames.Parser, new[]{ "AllowedDnsNames", "AllowedUris", "AllowedEmailAddresses", "AllowedIps", "AllowGlobbingDnsWildcards", "AllowCustomSans" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.IssuanceModes), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.IssuanceModes.Parser, new[]{ "AllowCsrBasedIssuance", "AllowConfigBasedIssuance" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.AccessUrls), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.AccessUrls.Parser, new[]{ "CaCertificateAccessUrl", "CrlAccessUrl" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.KeyVersionSpec), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.KeyVersionSpec.Parser, new[]{ "CloudKmsKeyVersion", "Algorithm" }, new[]{ "KeyVersion" }, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Parser, new[]{ "Name", "SequenceNumber", "RevokedCertificates", "PemCrl", "AccessUrl", "State", "CreateTime", "UpdateTime", "Labels" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.RevokedCertificate), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.RevokedCertificate.Parser, new[]{ "Certificate", "HexSerialNumber", "RevocationReason" }, null, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate), global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Parser, new[]{ "Name", "PemCsr", "Config", "Lifetime", "RevocationDetails", "PemCertificate", "CertificateDescription", "PemCertificateChain", "CreateTime", "UpdateTime", "Labels" }, new[]{ "CertificateConfig" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Types.RevocationDetails), global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Types.RevocationDetails.Parser, new[]{ "RevocationState", "RevocationTime" }, null, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfig), global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfig.Parser, new[]{ "Name", "Values", "Description", "CreateTime", "UpdateTime", "Labels" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues), global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Parser, new[]{ "KeyUsage", "CaOptions", "PolicyIds", "AiaOcspServers", "AdditionalExtensions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Types.CaOptions), global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Types.CaOptions.Parser, new[]{ "IsCa", "MaxIssuerPathLength" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper), global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper.Parser, new[]{ "ReusableConfig", "ReusableConfigValues" }, new[]{ "ConfigValues" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig), global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Parser, new[]{ "CertificateAuthority", "PemIssuerChain" }, new[]{ "SubordinateConfig" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain), global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain.Parser, new[]{ "PemCertificates" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey), global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Parser, new[]{ "Type", "Key" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Parser, new[]{ "SubjectConfig", "ReusableConfig", "PublicKey" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Types.SubjectConfig), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Types.SubjectConfig.Parser, new[]{ "Subject", "CommonName", "SubjectAltName" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Parser, new[]{ "SubjectDescription", "ConfigValues", "PublicKey", "SubjectKeyId", "AuthorityKeyId", "CrlDistributionPoints", "AiaIssuingCertificateUrls", "CertFingerprint" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.SubjectDescription), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.SubjectDescription.Parser, new[]{ "Subject", "CommonName", "SubjectAltName", "HexSerialNumber", "Lifetime", "NotBeforeTime", "NotAfterTime" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId.Parser, new[]{ "KeyId_" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.CertificateFingerprint), global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.CertificateFingerprint.Parser, new[]{ "Sha256Hash" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId), global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId.Parser, new[]{ "ObjectIdPath" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension), global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension.Parser, new[]{ "ObjectId", "Critical", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage), global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Parser, new[]{ "BaseKeyUsage", "ExtendedKeyUsage", "UnknownExtendedKeyUsages" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.KeyUsageOptions), global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.KeyUsageOptions.Parser, new[]{ "DigitalSignature", "ContentCommitment", "KeyEncipherment", "DataEncipherment", "KeyAgreement", "CertSign", "CrlSign", "EncipherOnly", "DecipherOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.ExtendedKeyUsageOptions), global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.ExtendedKeyUsageOptions.Parser, new[]{ "ServerAuth", "ClientAuth", "CodeSigning", "EmailProtection", "TimeStamping", "OcspSigning" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject), global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject.Parser, new[]{ "CountryCode", "Organization", "OrganizationalUnit", "Locality", "Province", "StreetAddress", "PostalCode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames), global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames.Parser, new[]{ "DnsNames", "Uris", "EmailAddresses", "IpAddresses", "CustomSans" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// A [RevocationReason][google.cloud.security.privateca.v1beta1.RevocationReason] indicates whether a [Certificate][google.cloud.security.privateca.v1beta1.Certificate] has been revoked,
  /// and the reason for revocation. These correspond to standard revocation
  /// reasons from RFC 5280. Note that the enum labels and values in this
  /// definition are not the same ASN.1 values defined in RFC 5280. These values
  /// will be translated to the correct ASN.1 values when a CRL is created.
  /// </summary>
  public enum RevocationReason {
    /// <summary>
    /// Default unspecified value. This value does indicate that a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]
    /// has been revoked, but that a reason has not been recorded.
    /// </summary>
    [pbr::OriginalName("REVOCATION_REASON_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Key material for this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] may have leaked.
    /// </summary>
    [pbr::OriginalName("KEY_COMPROMISE")] KeyCompromise = 1,
    /// <summary>
    /// The key material for a certificate authority in the issuing path may have
    /// leaked.
    /// </summary>
    [pbr::OriginalName("CERTIFICATE_AUTHORITY_COMPROMISE")] CertificateAuthorityCompromise = 2,
    /// <summary>
    /// The subject or other attributes in this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] have changed.
    /// </summary>
    [pbr::OriginalName("AFFILIATION_CHANGED")] AffiliationChanged = 3,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] has been superseded.
    /// </summary>
    [pbr::OriginalName("SUPERSEDED")] Superseded = 4,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] or entities in the issuing path have ceased to
    /// operate.
    /// </summary>
    [pbr::OriginalName("CESSATION_OF_OPERATION")] CessationOfOperation = 5,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] should not be considered valid, it is expected that it
    /// may become valid in the future.
    /// </summary>
    [pbr::OriginalName("CERTIFICATE_HOLD")] CertificateHold = 6,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] no longer has permission to assert the listed
    /// attributes.
    /// </summary>
    [pbr::OriginalName("PRIVILEGE_WITHDRAWN")] PrivilegeWithdrawn = 7,
    /// <summary>
    /// The authority which determines appropriate attributes for a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]
    /// may have been compromised.
    /// </summary>
    [pbr::OriginalName("ATTRIBUTE_AUTHORITY_COMPROMISE")] AttributeAuthorityCompromise = 8,
  }

  #endregion

  #region Messages
  /// <summary>
  /// A [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] represents an individual Certificate Authority.
  /// A [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] can be used to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
  /// </summary>
  public sealed partial class CertificateAuthority : pb::IMessage<CertificateAuthority>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateAuthority> _parser = new pb::MessageParser<CertificateAuthority>(() => new CertificateAuthority());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateAuthority> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateAuthority() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateAuthority(CertificateAuthority other) : this() {
      name_ = other.name_;
      type_ = other.type_;
      tier_ = other.tier_;
      config_ = other.config_ != null ? other.config_.Clone() : null;
      lifetime_ = other.lifetime_ != null ? other.lifetime_.Clone() : null;
      keySpec_ = other.keySpec_ != null ? other.keySpec_.Clone() : null;
      certificatePolicy_ = other.certificatePolicy_ != null ? other.certificatePolicy_.Clone() : null;
      issuingOptions_ = other.issuingOptions_ != null ? other.issuingOptions_.Clone() : null;
      subordinateConfig_ = other.subordinateConfig_ != null ? other.subordinateConfig_.Clone() : null;
      state_ = other.state_;
      pemCaCertificates_ = other.pemCaCertificates_.Clone();
      caCertificateDescriptions_ = other.caCertificateDescriptions_.Clone();
      gcsBucket_ = other.gcsBucket_;
      accessUrls_ = other.accessUrls_ != null ? other.accessUrls_.Clone() : null;
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      deleteTime_ = other.deleteTime_ != null ? other.deleteTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateAuthority Clone() {
      return new CertificateAuthority(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource name for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] in the
    /// format `projects/*/locations/*/certificateAuthorities/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type type_ = global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type.Unspecified;
    /// <summary>
    /// Required. Immutable. The [Type][google.cloud.security.privateca.v1beta1.CertificateAuthority.Type] of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "tier" field.</summary>
    public const int TierFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier tier_ = global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier.Unspecified;
    /// <summary>
    /// Required. Immutable. The [Tier][google.cloud.security.privateca.v1beta1.CertificateAuthority.Tier] of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier Tier {
      get { return tier_; }
      set {
        tier_ = value;
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 4;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig config_;
    /// <summary>
    /// Required. Immutable. The config used to create a self-signed X.509 certificate or CSR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "lifetime" field.</summary>
    public const int LifetimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Duration lifetime_;
    /// <summary>
    /// Required. The desired lifetime of the CA certificate. Used to create the
    /// "not_before_time" and "not_after_time" fields inside an X.509
    /// certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Lifetime {
      get { return lifetime_; }
      set {
        lifetime_ = value;
      }
    }

    /// <summary>Field number for the "key_spec" field.</summary>
    public const int KeySpecFieldNumber = 6;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.KeyVersionSpec keySpec_;
    /// <summary>
    /// Required. Immutable. Used when issuing certificates for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. If this
    /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] is a self-signed CertificateAuthority, this key
    /// is also used to sign the self-signed CA certificate. Otherwise, it
    /// is used to sign a CSR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.KeyVersionSpec KeySpec {
      get { return keySpec_; }
      set {
        keySpec_ = value;
      }
    }

    /// <summary>Field number for the "certificate_policy" field.</summary>
    public const int CertificatePolicyFieldNumber = 7;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy certificatePolicy_;
    /// <summary>
    /// Optional. The [CertificateAuthorityPolicy][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy] to enforce when issuing
    /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] from this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy CertificatePolicy {
      get { return certificatePolicy_; }
      set {
        certificatePolicy_ = value;
      }
    }

    /// <summary>Field number for the "issuing_options" field.</summary>
    public const int IssuingOptionsFieldNumber = 8;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.IssuingOptions issuingOptions_;
    /// <summary>
    /// Optional. The [IssuingOptions][google.cloud.security.privateca.v1beta1.CertificateAuthority.IssuingOptions] to follow when issuing [Certificates][google.cloud.security.privateca.v1beta1.Certificate]
    /// from this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.IssuingOptions IssuingOptions {
      get { return issuingOptions_; }
      set {
        issuingOptions_ = value;
      }
    }

    /// <summary>Field number for the "subordinate_config" field.</summary>
    public const int SubordinateConfigFieldNumber = 19;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig subordinateConfig_;
    /// <summary>
    /// Optional. If this is a subordinate [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], this field will be set
    /// with the subordinate configuration, which describes its issuers. This may
    /// be updated, but this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must continue to validate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig SubordinateConfig {
      get { return subordinateConfig_; }
      set {
        subordinateConfig_ = value;
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 10;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State state_ = global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State.Unspecified;
    /// <summary>
    /// Output only. The [State][google.cloud.security.privateca.v1beta1.CertificateAuthority.State] for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "pem_ca_certificates" field.</summary>
    public const int PemCaCertificatesFieldNumber = 9;
    private static readonly pb::FieldCodec<string> _repeated_pemCaCertificates_codec
        = pb::FieldCodec.ForString(74);
    private readonly pbc::RepeatedField<string> pemCaCertificates_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Output only. This [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate chain, including the current
    /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate. Ordered such that the root issuer
    /// is the final element (consistent with RFC 5246). For a self-signed CA, this
    /// will only list the current [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> PemCaCertificates {
      get { return pemCaCertificates_; }
    }

    /// <summary>Field number for the "ca_certificate_descriptions" field.</summary>
    public const int CaCertificateDescriptionsFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription> _repeated_caCertificateDescriptions_codec
        = pb::FieldCodec.ForMessage(98, global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription> caCertificateDescriptions_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription>();
    /// <summary>
    /// Output only. A structured description of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CA certificate
    /// and its issuers. Ordered as self-to-root.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription> CaCertificateDescriptions {
      get { return caCertificateDescriptions_; }
    }

    /// <summary>Field number for the "gcs_bucket" field.</summary>
    public const int GcsBucketFieldNumber = 13;
    private string gcsBucket_ = "";
    /// <summary>
    /// Immutable. The name of a Cloud Storage bucket where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will
    /// publish content, such as the CA certificate and CRLs. This must be a bucket
    /// name, without any prefixes (such as `gs://`) or suffixes (such as
    /// `.googleapis.com`). For example, to use a bucket named `my-bucket`, you
    /// would simply specify `my-bucket`. If not specified, a managed bucket will
    /// be created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GcsBucket {
      get { return gcsBucket_; }
      set {
        gcsBucket_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "access_urls" field.</summary>
    public const int AccessUrlsFieldNumber = 14;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.AccessUrls accessUrls_;
    /// <summary>
    /// Output only. URLs for accessing content published by this CA, such as the CA certificate
    /// and CRLs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.AccessUrls AccessUrls {
      get { return accessUrls_; }
      set {
        accessUrls_ = value;
      }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 15;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] was updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "delete_time" field.</summary>
    public const int DeleteTimeFieldNumber = 17;
    private global::Google.Protobuf.WellKnownTypes.Timestamp deleteTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will be deleted, if
    /// scheduled for deletion.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp DeleteTime {
      get { return deleteTime_; }
      set {
        deleteTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 18;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 146);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateAuthority);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateAuthority other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Type != other.Type) return false;
      if (Tier != other.Tier) return false;
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(Lifetime, other.Lifetime)) return false;
      if (!object.Equals(KeySpec, other.KeySpec)) return false;
      if (!object.Equals(CertificatePolicy, other.CertificatePolicy)) return false;
      if (!object.Equals(IssuingOptions, other.IssuingOptions)) return false;
      if (!object.Equals(SubordinateConfig, other.SubordinateConfig)) return false;
      if (State != other.State) return false;
      if(!pemCaCertificates_.Equals(other.pemCaCertificates_)) return false;
      if(!caCertificateDescriptions_.Equals(other.caCertificateDescriptions_)) return false;
      if (GcsBucket != other.GcsBucket) return false;
      if (!object.Equals(AccessUrls, other.AccessUrls)) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!object.Equals(DeleteTime, other.DeleteTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type.Unspecified) hash ^= Type.GetHashCode();
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier.Unspecified) hash ^= Tier.GetHashCode();
      if (config_ != null) hash ^= Config.GetHashCode();
      if (lifetime_ != null) hash ^= Lifetime.GetHashCode();
      if (keySpec_ != null) hash ^= KeySpec.GetHashCode();
      if (certificatePolicy_ != null) hash ^= CertificatePolicy.GetHashCode();
      if (issuingOptions_ != null) hash ^= IssuingOptions.GetHashCode();
      if (subordinateConfig_ != null) hash ^= SubordinateConfig.GetHashCode();
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State.Unspecified) hash ^= State.GetHashCode();
      hash ^= pemCaCertificates_.GetHashCode();
      hash ^= caCertificateDescriptions_.GetHashCode();
      if (GcsBucket.Length != 0) hash ^= GcsBucket.GetHashCode();
      if (accessUrls_ != null) hash ^= AccessUrls.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      if (deleteTime_ != null) hash ^= DeleteTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Tier);
      }
      if (config_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Config);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Lifetime);
      }
      if (keySpec_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(KeySpec);
      }
      if (certificatePolicy_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CertificatePolicy);
      }
      if (issuingOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(IssuingOptions);
      }
      pemCaCertificates_.WriteTo(output, _repeated_pemCaCertificates_codec);
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State.Unspecified) {
        output.WriteRawTag(80);
        output.WriteEnum((int) State);
      }
      caCertificateDescriptions_.WriteTo(output, _repeated_caCertificateDescriptions_codec);
      if (GcsBucket.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(GcsBucket);
      }
      if (accessUrls_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(AccessUrls);
      }
      if (createTime_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(UpdateTime);
      }
      if (deleteTime_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(DeleteTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (subordinateConfig_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(SubordinateConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Tier);
      }
      if (config_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Config);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Lifetime);
      }
      if (keySpec_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(KeySpec);
      }
      if (certificatePolicy_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CertificatePolicy);
      }
      if (issuingOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(IssuingOptions);
      }
      pemCaCertificates_.WriteTo(ref output, _repeated_pemCaCertificates_codec);
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State.Unspecified) {
        output.WriteRawTag(80);
        output.WriteEnum((int) State);
      }
      caCertificateDescriptions_.WriteTo(ref output, _repeated_caCertificateDescriptions_codec);
      if (GcsBucket.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(GcsBucket);
      }
      if (accessUrls_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(AccessUrls);
      }
      if (createTime_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(UpdateTime);
      }
      if (deleteTime_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(DeleteTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (subordinateConfig_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(SubordinateConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Tier);
      }
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (lifetime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifetime);
      }
      if (keySpec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeySpec);
      }
      if (certificatePolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CertificatePolicy);
      }
      if (issuingOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IssuingOptions);
      }
      if (subordinateConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SubordinateConfig);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      size += pemCaCertificates_.CalculateSize(_repeated_pemCaCertificates_codec);
      size += caCertificateDescriptions_.CalculateSize(_repeated_caCertificateDescriptions_codec);
      if (GcsBucket.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GcsBucket);
      }
      if (accessUrls_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccessUrls);
      }
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      if (deleteTime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DeleteTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateAuthority other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type.Unspecified) {
        Type = other.Type;
      }
      if (other.Tier != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier.Unspecified) {
        Tier = other.Tier;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.lifetime_ != null) {
        if (lifetime_ == null) {
          Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Lifetime.MergeFrom(other.Lifetime);
      }
      if (other.keySpec_ != null) {
        if (keySpec_ == null) {
          KeySpec = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.KeyVersionSpec();
        }
        KeySpec.MergeFrom(other.KeySpec);
      }
      if (other.certificatePolicy_ != null) {
        if (certificatePolicy_ == null) {
          CertificatePolicy = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy();
        }
        CertificatePolicy.MergeFrom(other.CertificatePolicy);
      }
      if (other.issuingOptions_ != null) {
        if (issuingOptions_ == null) {
          IssuingOptions = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.IssuingOptions();
        }
        IssuingOptions.MergeFrom(other.IssuingOptions);
      }
      if (other.subordinateConfig_ != null) {
        if (subordinateConfig_ == null) {
          SubordinateConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig();
        }
        SubordinateConfig.MergeFrom(other.SubordinateConfig);
      }
      if (other.State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State.Unspecified) {
        State = other.State;
      }
      pemCaCertificates_.Add(other.pemCaCertificates_);
      caCertificateDescriptions_.Add(other.caCertificateDescriptions_);
      if (other.GcsBucket.Length != 0) {
        GcsBucket = other.GcsBucket;
      }
      if (other.accessUrls_ != null) {
        if (accessUrls_ == null) {
          AccessUrls = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.AccessUrls();
        }
        AccessUrls.MergeFrom(other.AccessUrls);
      }
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      if (other.deleteTime_ != null) {
        if (deleteTime_ == null) {
          DeleteTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        DeleteTime.MergeFrom(other.DeleteTime);
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Type = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type) input.ReadEnum();
            break;
          }
          case 24: {
            Tier = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier) input.ReadEnum();
            break;
          }
          case 34: {
            if (config_ == null) {
              Config = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 42: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 50: {
            if (keySpec_ == null) {
              KeySpec = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.KeyVersionSpec();
            }
            input.ReadMessage(KeySpec);
            break;
          }
          case 58: {
            if (certificatePolicy_ == null) {
              CertificatePolicy = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy();
            }
            input.ReadMessage(CertificatePolicy);
            break;
          }
          case 66: {
            if (issuingOptions_ == null) {
              IssuingOptions = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.IssuingOptions();
            }
            input.ReadMessage(IssuingOptions);
            break;
          }
          case 74: {
            pemCaCertificates_.AddEntriesFrom(input, _repeated_pemCaCertificates_codec);
            break;
          }
          case 80: {
            State = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State) input.ReadEnum();
            break;
          }
          case 98: {
            caCertificateDescriptions_.AddEntriesFrom(input, _repeated_caCertificateDescriptions_codec);
            break;
          }
          case 106: {
            GcsBucket = input.ReadString();
            break;
          }
          case 114: {
            if (accessUrls_ == null) {
              AccessUrls = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.AccessUrls();
            }
            input.ReadMessage(AccessUrls);
            break;
          }
          case 122: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 130: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 138: {
            if (deleteTime_ == null) {
              DeleteTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(DeleteTime);
            break;
          }
          case 146: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
          case 154: {
            if (subordinateConfig_ == null) {
              SubordinateConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig();
            }
            input.ReadMessage(SubordinateConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Type = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Type) input.ReadEnum();
            break;
          }
          case 24: {
            Tier = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.Tier) input.ReadEnum();
            break;
          }
          case 34: {
            if (config_ == null) {
              Config = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 42: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 50: {
            if (keySpec_ == null) {
              KeySpec = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.KeyVersionSpec();
            }
            input.ReadMessage(KeySpec);
            break;
          }
          case 58: {
            if (certificatePolicy_ == null) {
              CertificatePolicy = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy();
            }
            input.ReadMessage(CertificatePolicy);
            break;
          }
          case 66: {
            if (issuingOptions_ == null) {
              IssuingOptions = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.IssuingOptions();
            }
            input.ReadMessage(IssuingOptions);
            break;
          }
          case 74: {
            pemCaCertificates_.AddEntriesFrom(ref input, _repeated_pemCaCertificates_codec);
            break;
          }
          case 80: {
            State = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.State) input.ReadEnum();
            break;
          }
          case 98: {
            caCertificateDescriptions_.AddEntriesFrom(ref input, _repeated_caCertificateDescriptions_codec);
            break;
          }
          case 106: {
            GcsBucket = input.ReadString();
            break;
          }
          case 114: {
            if (accessUrls_ == null) {
              AccessUrls = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.AccessUrls();
            }
            input.ReadMessage(AccessUrls);
            break;
          }
          case 122: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 130: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 138: {
            if (deleteTime_ == null) {
              DeleteTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(DeleteTime);
            break;
          }
          case 146: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
          case 154: {
            if (subordinateConfig_ == null) {
              SubordinateConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig();
            }
            input.ReadMessage(SubordinateConfig);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateAuthority message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The type of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating its issuing chain.
      /// </summary>
      public enum Type {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Self-signed CA.
        /// </summary>
        [pbr::OriginalName("SELF_SIGNED")] SelfSigned = 1,
        /// <summary>
        /// Subordinate CA. Could be issued by a Private CA [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
        /// or an unmanaged CA.
        /// </summary>
        [pbr::OriginalName("SUBORDINATE")] Subordinate = 2,
      }

      /// <summary>
      /// The tier of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating its supported
      /// functionality and/or billing SKU.
      /// </summary>
      public enum Tier {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("TIER_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Enterprise tier.
        /// </summary>
        [pbr::OriginalName("ENTERPRISE")] Enterprise = 1,
        /// <summary>
        /// DevOps tier.
        /// </summary>
        [pbr::OriginalName("DEVOPS")] Devops = 2,
      }

      /// <summary>
      /// The state of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating if it can be used.
      /// </summary>
      public enum State {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("STATE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Certificates can be issued from this CA. CRLs will be generated for this
        /// CA.
        /// </summary>
        [pbr::OriginalName("ENABLED")] Enabled = 1,
        /// <summary>
        /// Certificates cannot be issued from this CA. CRLs will still be generated.
        /// </summary>
        [pbr::OriginalName("DISABLED")] Disabled = 2,
        /// <summary>
        /// Certificates cannot be issued from this CA. CRLs will not be generated.
        /// </summary>
        [pbr::OriginalName("PENDING_ACTIVATION")] PendingActivation = 3,
        /// <summary>
        /// Certificates cannot be issued from this CA. CRLs will not be generated.
        /// </summary>
        [pbr::OriginalName("PENDING_DELETION")] PendingDeletion = 4,
      }

      /// <summary>
      /// The algorithm of a Cloud KMS CryptoKeyVersion of a
      /// [CryptoKey][google.cloud.kms.v1.CryptoKey] with the
      /// [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose] value
      /// `ASYMMETRIC_SIGN`. These values correspond to the
      /// [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
      /// values. For RSA signing algorithms, the PSS algorithms should be preferred,
      /// use PKCS1 algorithms if required for compatibility. For further
      /// recommandations, see
      /// https://cloud.google.com/kms/docs/algorithms#algorithm_recommendations.
      /// </summary>
      public enum SignHashAlgorithm {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("SIGN_HASH_ALGORITHM_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PSS_2048_SHA256")] RsaPss2048Sha256 = 1,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PSS_3072_SHA256")] RsaPss3072Sha256 = 2,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PSS_4096_SHA256")] RsaPss4096Sha256 = 3,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PKCS1_2048_SHA256")] RsaPkcs12048Sha256 = 6,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PKCS1_3072_SHA256")] RsaPkcs13072Sha256 = 7,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PKCS1_4096_SHA256")] RsaPkcs14096Sha256 = 8,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256
        /// </summary>
        [pbr::OriginalName("EC_P256_SHA256")] EcP256Sha256 = 4,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384
        /// </summary>
        [pbr::OriginalName("EC_P384_SHA384")] EcP384Sha384 = 5,
      }

      /// <summary>
      /// Options that affect all certificates issued by a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
      /// </summary>
      public sealed partial class IssuingOptions : pb::IMessage<IssuingOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<IssuingOptions> _parser = new pb::MessageParser<IssuingOptions>(() => new IssuingOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<IssuingOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public IssuingOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public IssuingOptions(IssuingOptions other) : this() {
          includeCaCertUrl_ = other.includeCaCertUrl_;
          includeCrlAccessUrl_ = other.includeCrlAccessUrl_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public IssuingOptions Clone() {
          return new IssuingOptions(this);
        }

        /// <summary>Field number for the "include_ca_cert_url" field.</summary>
        public const int IncludeCaCertUrlFieldNumber = 1;
        private bool includeCaCertUrl_;
        /// <summary>
        /// Required. When true, includes a URL to the issuing CA certificate in the
        /// "authority information access" X.509 extension.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IncludeCaCertUrl {
          get { return includeCaCertUrl_; }
          set {
            includeCaCertUrl_ = value;
          }
        }

        /// <summary>Field number for the "include_crl_access_url" field.</summary>
        public const int IncludeCrlAccessUrlFieldNumber = 2;
        private bool includeCrlAccessUrl_;
        /// <summary>
        /// Required. When true, includes a URL to the CRL corresponding to certificates
        /// issued from a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
        /// CRLs will expire 7 days from their creation. However, we will rebuild
        /// daily. CRLs are also rebuilt shortly after a certificate is revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IncludeCrlAccessUrl {
          get { return includeCrlAccessUrl_; }
          set {
            includeCrlAccessUrl_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as IssuingOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(IssuingOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (IncludeCaCertUrl != other.IncludeCaCertUrl) return false;
          if (IncludeCrlAccessUrl != other.IncludeCrlAccessUrl) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (IncludeCaCertUrl != false) hash ^= IncludeCaCertUrl.GetHashCode();
          if (IncludeCrlAccessUrl != false) hash ^= IncludeCrlAccessUrl.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (IncludeCaCertUrl != false) {
            output.WriteRawTag(8);
            output.WriteBool(IncludeCaCertUrl);
          }
          if (IncludeCrlAccessUrl != false) {
            output.WriteRawTag(16);
            output.WriteBool(IncludeCrlAccessUrl);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (IncludeCaCertUrl != false) {
            output.WriteRawTag(8);
            output.WriteBool(IncludeCaCertUrl);
          }
          if (IncludeCrlAccessUrl != false) {
            output.WriteRawTag(16);
            output.WriteBool(IncludeCrlAccessUrl);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (IncludeCaCertUrl != false) {
            size += 1 + 1;
          }
          if (IncludeCrlAccessUrl != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(IssuingOptions other) {
          if (other == null) {
            return;
          }
          if (other.IncludeCaCertUrl != false) {
            IncludeCaCertUrl = other.IncludeCaCertUrl;
          }
          if (other.IncludeCrlAccessUrl != false) {
            IncludeCrlAccessUrl = other.IncludeCrlAccessUrl;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                IncludeCaCertUrl = input.ReadBool();
                break;
              }
              case 16: {
                IncludeCrlAccessUrl = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                IncludeCaCertUrl = input.ReadBool();
                break;
              }
              case 16: {
                IncludeCrlAccessUrl = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// The issuing policy for a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
      /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] will not be successfully issued from this
      /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] if they violate the policy.
      /// </summary>
      public sealed partial class CertificateAuthorityPolicy : pb::IMessage<CertificateAuthorityPolicy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CertificateAuthorityPolicy> _parser = new pb::MessageParser<CertificateAuthorityPolicy>(() => new CertificateAuthorityPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CertificateAuthorityPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateAuthorityPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateAuthorityPolicy(CertificateAuthorityPolicy other) : this() {
          allowedLocationsAndOrganizations_ = other.allowedLocationsAndOrganizations_.Clone();
          allowedCommonNames_ = other.allowedCommonNames_.Clone();
          allowedSans_ = other.allowedSans_ != null ? other.allowedSans_.Clone() : null;
          maximumLifetime_ = other.maximumLifetime_ != null ? other.maximumLifetime_.Clone() : null;
          allowedIssuanceModes_ = other.allowedIssuanceModes_ != null ? other.allowedIssuanceModes_.Clone() : null;
          switch (other.ConfigPolicyCase) {
            case ConfigPolicyOneofCase.AllowedConfigList:
              AllowedConfigList = other.AllowedConfigList.Clone();
              break;
            case ConfigPolicyOneofCase.OverwriteConfigValues:
              OverwriteConfigValues = other.OverwriteConfigValues.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateAuthorityPolicy Clone() {
          return new CertificateAuthorityPolicy(this);
        }

        /// <summary>Field number for the "allowed_config_list" field.</summary>
        public const int AllowedConfigListFieldNumber = 1;
        /// <summary>
        /// Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
        /// must match at least one listed [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] in the list.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList AllowedConfigList {
          get { return configPolicyCase_ == ConfigPolicyOneofCase.AllowedConfigList ? (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList) configPolicy_ : null; }
          set {
            configPolicy_ = value;
            configPolicyCase_ = value == null ? ConfigPolicyOneofCase.None : ConfigPolicyOneofCase.AllowedConfigList;
          }
        }

        /// <summary>Field number for the "overwrite_config_values" field.</summary>
        public const int OverwriteConfigValuesFieldNumber = 2;
        /// <summary>
        /// Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
        /// will use the provided configuration values, overwriting any requested
        /// configuration values.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper OverwriteConfigValues {
          get { return configPolicyCase_ == ConfigPolicyOneofCase.OverwriteConfigValues ? (global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper) configPolicy_ : null; }
          set {
            configPolicy_ = value;
            configPolicyCase_ = value == null ? ConfigPolicyOneofCase.None : ConfigPolicyOneofCase.OverwriteConfigValues;
          }
        }

        /// <summary>Field number for the "allowed_locations_and_organizations" field.</summary>
        public const int AllowedLocationsAndOrganizationsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject> _repeated_allowedLocationsAndOrganizations_codec
            = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject.Parser);
        private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject> allowedLocationsAndOrganizations_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject>();
        /// <summary>
        /// Optional. If any [Subject][google.cloud.security.privateca.v1beta1.Subject] is specified here, then all
        /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
        /// match at least one listed [Subject][google.cloud.security.privateca.v1beta1.Subject]. If a [Subject][google.cloud.security.privateca.v1beta1.Subject] has an empty
        /// field, any value will be allowed for that field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject> AllowedLocationsAndOrganizations {
          get { return allowedLocationsAndOrganizations_; }
        }

        /// <summary>Field number for the "allowed_common_names" field.</summary>
        public const int AllowedCommonNamesFieldNumber = 4;
        private static readonly pb::FieldCodec<string> _repeated_allowedCommonNames_codec
            = pb::FieldCodec.ForString(34);
        private readonly pbc::RepeatedField<string> allowedCommonNames_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Optional. If any value is specified here, then all
        /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
        /// match at least one listed value. If no value is specified, all values
        /// will be allowed for this fied. Glob patterns are also supported.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> AllowedCommonNames {
          get { return allowedCommonNames_; }
        }

        /// <summary>Field number for the "allowed_sans" field.</summary>
        public const int AllowedSansFieldNumber = 5;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedSubjectAltNames allowedSans_;
        /// <summary>
        /// Optional. If a [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames] is specified here, then all
        /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
        /// match [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames]. If no value or an empty value
        /// is specified, any value will be allowed for the [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames]
        /// field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedSubjectAltNames AllowedSans {
          get { return allowedSans_; }
          set {
            allowedSans_ = value;
          }
        }

        /// <summary>Field number for the "maximum_lifetime" field.</summary>
        public const int MaximumLifetimeFieldNumber = 6;
        private global::Google.Protobuf.WellKnownTypes.Duration maximumLifetime_;
        /// <summary>
        /// Optional. The maximum lifetime allowed by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. Note that
        /// if the any part if the issuing chain expires before a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]'s
        /// requested maximum_lifetime, the effective lifetime will be explicitly
        /// truncated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration MaximumLifetime {
          get { return maximumLifetime_; }
          set {
            maximumLifetime_ = value;
          }
        }

        /// <summary>Field number for the "allowed_issuance_modes" field.</summary>
        public const int AllowedIssuanceModesFieldNumber = 8;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.IssuanceModes allowedIssuanceModes_;
        /// <summary>
        /// Optional. If specified, then only methods allowed in the [IssuanceModes][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes] may be
        /// used to issue [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.IssuanceModes AllowedIssuanceModes {
          get { return allowedIssuanceModes_; }
          set {
            allowedIssuanceModes_ = value;
          }
        }

        private object configPolicy_;
        /// <summary>Enum of possible cases for the "config_policy" oneof.</summary>
        public enum ConfigPolicyOneofCase {
          None = 0,
          AllowedConfigList = 1,
          OverwriteConfigValues = 2,
        }
        private ConfigPolicyOneofCase configPolicyCase_ = ConfigPolicyOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConfigPolicyOneofCase ConfigPolicyCase {
          get { return configPolicyCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearConfigPolicy() {
          configPolicyCase_ = ConfigPolicyOneofCase.None;
          configPolicy_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CertificateAuthorityPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CertificateAuthorityPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(AllowedConfigList, other.AllowedConfigList)) return false;
          if (!object.Equals(OverwriteConfigValues, other.OverwriteConfigValues)) return false;
          if(!allowedLocationsAndOrganizations_.Equals(other.allowedLocationsAndOrganizations_)) return false;
          if(!allowedCommonNames_.Equals(other.allowedCommonNames_)) return false;
          if (!object.Equals(AllowedSans, other.AllowedSans)) return false;
          if (!object.Equals(MaximumLifetime, other.MaximumLifetime)) return false;
          if (!object.Equals(AllowedIssuanceModes, other.AllowedIssuanceModes)) return false;
          if (ConfigPolicyCase != other.ConfigPolicyCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (configPolicyCase_ == ConfigPolicyOneofCase.AllowedConfigList) hash ^= AllowedConfigList.GetHashCode();
          if (configPolicyCase_ == ConfigPolicyOneofCase.OverwriteConfigValues) hash ^= OverwriteConfigValues.GetHashCode();
          hash ^= allowedLocationsAndOrganizations_.GetHashCode();
          hash ^= allowedCommonNames_.GetHashCode();
          if (allowedSans_ != null) hash ^= AllowedSans.GetHashCode();
          if (maximumLifetime_ != null) hash ^= MaximumLifetime.GetHashCode();
          if (allowedIssuanceModes_ != null) hash ^= AllowedIssuanceModes.GetHashCode();
          hash ^= (int) configPolicyCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (configPolicyCase_ == ConfigPolicyOneofCase.AllowedConfigList) {
            output.WriteRawTag(10);
            output.WriteMessage(AllowedConfigList);
          }
          if (configPolicyCase_ == ConfigPolicyOneofCase.OverwriteConfigValues) {
            output.WriteRawTag(18);
            output.WriteMessage(OverwriteConfigValues);
          }
          allowedLocationsAndOrganizations_.WriteTo(output, _repeated_allowedLocationsAndOrganizations_codec);
          allowedCommonNames_.WriteTo(output, _repeated_allowedCommonNames_codec);
          if (allowedSans_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(AllowedSans);
          }
          if (maximumLifetime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(MaximumLifetime);
          }
          if (allowedIssuanceModes_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(AllowedIssuanceModes);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (configPolicyCase_ == ConfigPolicyOneofCase.AllowedConfigList) {
            output.WriteRawTag(10);
            output.WriteMessage(AllowedConfigList);
          }
          if (configPolicyCase_ == ConfigPolicyOneofCase.OverwriteConfigValues) {
            output.WriteRawTag(18);
            output.WriteMessage(OverwriteConfigValues);
          }
          allowedLocationsAndOrganizations_.WriteTo(ref output, _repeated_allowedLocationsAndOrganizations_codec);
          allowedCommonNames_.WriteTo(ref output, _repeated_allowedCommonNames_codec);
          if (allowedSans_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(AllowedSans);
          }
          if (maximumLifetime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(MaximumLifetime);
          }
          if (allowedIssuanceModes_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(AllowedIssuanceModes);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (configPolicyCase_ == ConfigPolicyOneofCase.AllowedConfigList) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedConfigList);
          }
          if (configPolicyCase_ == ConfigPolicyOneofCase.OverwriteConfigValues) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OverwriteConfigValues);
          }
          size += allowedLocationsAndOrganizations_.CalculateSize(_repeated_allowedLocationsAndOrganizations_codec);
          size += allowedCommonNames_.CalculateSize(_repeated_allowedCommonNames_codec);
          if (allowedSans_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedSans);
          }
          if (maximumLifetime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaximumLifetime);
          }
          if (allowedIssuanceModes_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedIssuanceModes);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CertificateAuthorityPolicy other) {
          if (other == null) {
            return;
          }
          allowedLocationsAndOrganizations_.Add(other.allowedLocationsAndOrganizations_);
          allowedCommonNames_.Add(other.allowedCommonNames_);
          if (other.allowedSans_ != null) {
            if (allowedSans_ == null) {
              AllowedSans = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedSubjectAltNames();
            }
            AllowedSans.MergeFrom(other.AllowedSans);
          }
          if (other.maximumLifetime_ != null) {
            if (maximumLifetime_ == null) {
              MaximumLifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaximumLifetime.MergeFrom(other.MaximumLifetime);
          }
          if (other.allowedIssuanceModes_ != null) {
            if (allowedIssuanceModes_ == null) {
              AllowedIssuanceModes = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.IssuanceModes();
            }
            AllowedIssuanceModes.MergeFrom(other.AllowedIssuanceModes);
          }
          switch (other.ConfigPolicyCase) {
            case ConfigPolicyOneofCase.AllowedConfigList:
              if (AllowedConfigList == null) {
                AllowedConfigList = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList();
              }
              AllowedConfigList.MergeFrom(other.AllowedConfigList);
              break;
            case ConfigPolicyOneofCase.OverwriteConfigValues:
              if (OverwriteConfigValues == null) {
                OverwriteConfigValues = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper();
              }
              OverwriteConfigValues.MergeFrom(other.OverwriteConfigValues);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList();
                if (configPolicyCase_ == ConfigPolicyOneofCase.AllowedConfigList) {
                  subBuilder.MergeFrom(AllowedConfigList);
                }
                input.ReadMessage(subBuilder);
                AllowedConfigList = subBuilder;
                break;
              }
              case 18: {
                global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper();
                if (configPolicyCase_ == ConfigPolicyOneofCase.OverwriteConfigValues) {
                  subBuilder.MergeFrom(OverwriteConfigValues);
                }
                input.ReadMessage(subBuilder);
                OverwriteConfigValues = subBuilder;
                break;
              }
              case 26: {
                allowedLocationsAndOrganizations_.AddEntriesFrom(input, _repeated_allowedLocationsAndOrganizations_codec);
                break;
              }
              case 34: {
                allowedCommonNames_.AddEntriesFrom(input, _repeated_allowedCommonNames_codec);
                break;
              }
              case 42: {
                if (allowedSans_ == null) {
                  AllowedSans = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedSubjectAltNames();
                }
                input.ReadMessage(AllowedSans);
                break;
              }
              case 50: {
                if (maximumLifetime_ == null) {
                  MaximumLifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaximumLifetime);
                break;
              }
              case 66: {
                if (allowedIssuanceModes_ == null) {
                  AllowedIssuanceModes = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.IssuanceModes();
                }
                input.ReadMessage(AllowedIssuanceModes);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedConfigList();
                if (configPolicyCase_ == ConfigPolicyOneofCase.AllowedConfigList) {
                  subBuilder.MergeFrom(AllowedConfigList);
                }
                input.ReadMessage(subBuilder);
                AllowedConfigList = subBuilder;
                break;
              }
              case 18: {
                global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper();
                if (configPolicyCase_ == ConfigPolicyOneofCase.OverwriteConfigValues) {
                  subBuilder.MergeFrom(OverwriteConfigValues);
                }
                input.ReadMessage(subBuilder);
                OverwriteConfigValues = subBuilder;
                break;
              }
              case 26: {
                allowedLocationsAndOrganizations_.AddEntriesFrom(ref input, _repeated_allowedLocationsAndOrganizations_codec);
                break;
              }
              case 34: {
                allowedCommonNames_.AddEntriesFrom(ref input, _repeated_allowedCommonNames_codec);
                break;
              }
              case 42: {
                if (allowedSans_ == null) {
                  AllowedSans = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.AllowedSubjectAltNames();
                }
                input.ReadMessage(AllowedSans);
                break;
              }
              case 50: {
                if (maximumLifetime_ == null) {
                  MaximumLifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaximumLifetime);
                break;
              }
              case 66: {
                if (allowedIssuanceModes_ == null) {
                  AllowedIssuanceModes = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Types.IssuanceModes();
                }
                input.ReadMessage(AllowedIssuanceModes);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the CertificateAuthorityPolicy message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class AllowedConfigList : pb::IMessage<AllowedConfigList>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<AllowedConfigList> _parser = new pb::MessageParser<AllowedConfigList>(() => new AllowedConfigList());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<AllowedConfigList> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedConfigList() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedConfigList(AllowedConfigList other) : this() {
              allowedConfigValues_ = other.allowedConfigValues_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedConfigList Clone() {
              return new AllowedConfigList(this);
            }

            /// <summary>Field number for the "allowed_config_values" field.</summary>
            public const int AllowedConfigValuesFieldNumber = 1;
            private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper> _repeated_allowedConfigValues_codec
                = pb::FieldCodec.ForMessage(10, global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper.Parser);
            private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper> allowedConfigValues_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper>();
            /// <summary>
            /// Required. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
            /// must match at least one listed [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper]. If a
            /// [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] has an empty field, any value will be
            /// allowed for that field.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper> AllowedConfigValues {
              get { return allowedConfigValues_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as AllowedConfigList);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(AllowedConfigList other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!allowedConfigValues_.Equals(other.allowedConfigValues_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= allowedConfigValues_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              allowedConfigValues_.WriteTo(output, _repeated_allowedConfigValues_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              allowedConfigValues_.WriteTo(ref output, _repeated_allowedConfigValues_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += allowedConfigValues_.CalculateSize(_repeated_allowedConfigValues_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(AllowedConfigList other) {
              if (other == null) {
                return;
              }
              allowedConfigValues_.Add(other.allowedConfigValues_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    allowedConfigValues_.AddEntriesFrom(input, _repeated_allowedConfigValues_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    allowedConfigValues_.AddEntriesFrom(ref input, _repeated_allowedConfigValues_codec);
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames] specifies the allowed values for
          /// [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames] by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] when issuing
          /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
          /// </summary>
          public sealed partial class AllowedSubjectAltNames : pb::IMessage<AllowedSubjectAltNames>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<AllowedSubjectAltNames> _parser = new pb::MessageParser<AllowedSubjectAltNames>(() => new AllowedSubjectAltNames());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<AllowedSubjectAltNames> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedSubjectAltNames() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedSubjectAltNames(AllowedSubjectAltNames other) : this() {
              allowedDnsNames_ = other.allowedDnsNames_.Clone();
              allowedUris_ = other.allowedUris_.Clone();
              allowedEmailAddresses_ = other.allowedEmailAddresses_.Clone();
              allowedIps_ = other.allowedIps_.Clone();
              allowGlobbingDnsWildcards_ = other.allowGlobbingDnsWildcards_;
              allowCustomSans_ = other.allowCustomSans_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedSubjectAltNames Clone() {
              return new AllowedSubjectAltNames(this);
            }

            /// <summary>Field number for the "allowed_dns_names" field.</summary>
            public const int AllowedDnsNamesFieldNumber = 1;
            private static readonly pb::FieldCodec<string> _repeated_allowedDnsNames_codec
                = pb::FieldCodec.ForString(10);
            private readonly pbc::RepeatedField<string> allowedDnsNames_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// Optional. Contains valid, fully-qualified host names. Glob patterns are also
            /// supported. To allow an explicit wildcard certificate, escape with
            /// backlash (i.e. "\*").
            /// E.g. for globbed entries: '*bar.com' will allow foo.bar.com, but not
            /// *.bar.com, unless the [allow_globbing_dns_wildcards][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames.allow_globbing_dns_wildcards] field is set.
            /// E.g. for wildcard entries: '\*.bar.com' will allow '*.bar.com', but not
            /// 'foo.bar.com'.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<string> AllowedDnsNames {
              get { return allowedDnsNames_; }
            }

            /// <summary>Field number for the "allowed_uris" field.</summary>
            public const int AllowedUrisFieldNumber = 2;
            private static readonly pb::FieldCodec<string> _repeated_allowedUris_codec
                = pb::FieldCodec.ForString(18);
            private readonly pbc::RepeatedField<string> allowedUris_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// Optional. Contains valid RFC 3986 URIs. Glob patterns are also supported. To
            /// match across path seperators (i.e. '/') use the double star glob
            /// pattern (i.e. '**').
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<string> AllowedUris {
              get { return allowedUris_; }
            }

            /// <summary>Field number for the "allowed_email_addresses" field.</summary>
            public const int AllowedEmailAddressesFieldNumber = 3;
            private static readonly pb::FieldCodec<string> _repeated_allowedEmailAddresses_codec
                = pb::FieldCodec.ForString(26);
            private readonly pbc::RepeatedField<string> allowedEmailAddresses_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// Optional. Contains valid RFC 2822 E-mail addresses. Glob patterns are also
            /// supported.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<string> AllowedEmailAddresses {
              get { return allowedEmailAddresses_; }
            }

            /// <summary>Field number for the "allowed_ips" field.</summary>
            public const int AllowedIpsFieldNumber = 4;
            private static readonly pb::FieldCodec<string> _repeated_allowedIps_codec
                = pb::FieldCodec.ForString(34);
            private readonly pbc::RepeatedField<string> allowedIps_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// Optional. Contains valid 32-bit IPv4 addresses and subnet ranges or RFC 4291 IPv6
            /// addresses and subnet ranges. Subnet ranges are specified using the
            /// '/' notation (e.g. 10.0.0.0/8, 2001:700:300:1800::/64). Glob patterns
            /// are supported only for ip address entries (i.e. not for subnet ranges).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<string> AllowedIps {
              get { return allowedIps_; }
            }

            /// <summary>Field number for the "allow_globbing_dns_wildcards" field.</summary>
            public const int AllowGlobbingDnsWildcardsFieldNumber = 5;
            private bool allowGlobbingDnsWildcards_;
            /// <summary>
            /// Optional. Specifies if glob patterns used for [allowed_dns_names][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames.allowed_dns_names] allows
            /// wildcard certificates.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool AllowGlobbingDnsWildcards {
              get { return allowGlobbingDnsWildcards_; }
              set {
                allowGlobbingDnsWildcards_ = value;
              }
            }

            /// <summary>Field number for the "allow_custom_sans" field.</summary>
            public const int AllowCustomSansFieldNumber = 6;
            private bool allowCustomSans_;
            /// <summary>
            /// Optional. Specifies if to allow custom X509Extension values.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool AllowCustomSans {
              get { return allowCustomSans_; }
              set {
                allowCustomSans_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as AllowedSubjectAltNames);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(AllowedSubjectAltNames other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!allowedDnsNames_.Equals(other.allowedDnsNames_)) return false;
              if(!allowedUris_.Equals(other.allowedUris_)) return false;
              if(!allowedEmailAddresses_.Equals(other.allowedEmailAddresses_)) return false;
              if(!allowedIps_.Equals(other.allowedIps_)) return false;
              if (AllowGlobbingDnsWildcards != other.AllowGlobbingDnsWildcards) return false;
              if (AllowCustomSans != other.AllowCustomSans) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= allowedDnsNames_.GetHashCode();
              hash ^= allowedUris_.GetHashCode();
              hash ^= allowedEmailAddresses_.GetHashCode();
              hash ^= allowedIps_.GetHashCode();
              if (AllowGlobbingDnsWildcards != false) hash ^= AllowGlobbingDnsWildcards.GetHashCode();
              if (AllowCustomSans != false) hash ^= AllowCustomSans.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              allowedDnsNames_.WriteTo(output, _repeated_allowedDnsNames_codec);
              allowedUris_.WriteTo(output, _repeated_allowedUris_codec);
              allowedEmailAddresses_.WriteTo(output, _repeated_allowedEmailAddresses_codec);
              allowedIps_.WriteTo(output, _repeated_allowedIps_codec);
              if (AllowGlobbingDnsWildcards != false) {
                output.WriteRawTag(40);
                output.WriteBool(AllowGlobbingDnsWildcards);
              }
              if (AllowCustomSans != false) {
                output.WriteRawTag(48);
                output.WriteBool(AllowCustomSans);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              allowedDnsNames_.WriteTo(ref output, _repeated_allowedDnsNames_codec);
              allowedUris_.WriteTo(ref output, _repeated_allowedUris_codec);
              allowedEmailAddresses_.WriteTo(ref output, _repeated_allowedEmailAddresses_codec);
              allowedIps_.WriteTo(ref output, _repeated_allowedIps_codec);
              if (AllowGlobbingDnsWildcards != false) {
                output.WriteRawTag(40);
                output.WriteBool(AllowGlobbingDnsWildcards);
              }
              if (AllowCustomSans != false) {
                output.WriteRawTag(48);
                output.WriteBool(AllowCustomSans);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += allowedDnsNames_.CalculateSize(_repeated_allowedDnsNames_codec);
              size += allowedUris_.CalculateSize(_repeated_allowedUris_codec);
              size += allowedEmailAddresses_.CalculateSize(_repeated_allowedEmailAddresses_codec);
              size += allowedIps_.CalculateSize(_repeated_allowedIps_codec);
              if (AllowGlobbingDnsWildcards != false) {
                size += 1 + 1;
              }
              if (AllowCustomSans != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(AllowedSubjectAltNames other) {
              if (other == null) {
                return;
              }
              allowedDnsNames_.Add(other.allowedDnsNames_);
              allowedUris_.Add(other.allowedUris_);
              allowedEmailAddresses_.Add(other.allowedEmailAddresses_);
              allowedIps_.Add(other.allowedIps_);
              if (other.AllowGlobbingDnsWildcards != false) {
                AllowGlobbingDnsWildcards = other.AllowGlobbingDnsWildcards;
              }
              if (other.AllowCustomSans != false) {
                AllowCustomSans = other.AllowCustomSans;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    allowedDnsNames_.AddEntriesFrom(input, _repeated_allowedDnsNames_codec);
                    break;
                  }
                  case 18: {
                    allowedUris_.AddEntriesFrom(input, _repeated_allowedUris_codec);
                    break;
                  }
                  case 26: {
                    allowedEmailAddresses_.AddEntriesFrom(input, _repeated_allowedEmailAddresses_codec);
                    break;
                  }
                  case 34: {
                    allowedIps_.AddEntriesFrom(input, _repeated_allowedIps_codec);
                    break;
                  }
                  case 40: {
                    AllowGlobbingDnsWildcards = input.ReadBool();
                    break;
                  }
                  case 48: {
                    AllowCustomSans = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    allowedDnsNames_.AddEntriesFrom(ref input, _repeated_allowedDnsNames_codec);
                    break;
                  }
                  case 18: {
                    allowedUris_.AddEntriesFrom(ref input, _repeated_allowedUris_codec);
                    break;
                  }
                  case 26: {
                    allowedEmailAddresses_.AddEntriesFrom(ref input, _repeated_allowedEmailAddresses_codec);
                    break;
                  }
                  case 34: {
                    allowedIps_.AddEntriesFrom(ref input, _repeated_allowedIps_codec);
                    break;
                  }
                  case 40: {
                    AllowGlobbingDnsWildcards = input.ReadBool();
                    break;
                  }
                  case 48: {
                    AllowCustomSans = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// [IssuanceModes][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes] specifies the allowed ways in which
          /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] may be requested from this
          /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
          /// </summary>
          public sealed partial class IssuanceModes : pb::IMessage<IssuanceModes>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<IssuanceModes> _parser = new pb::MessageParser<IssuanceModes>(() => new IssuanceModes());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<IssuanceModes> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.CertificateAuthorityPolicy.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public IssuanceModes() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public IssuanceModes(IssuanceModes other) : this() {
              allowCsrBasedIssuance_ = other.allowCsrBasedIssuance_;
              allowConfigBasedIssuance_ = other.allowConfigBasedIssuance_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public IssuanceModes Clone() {
              return new IssuanceModes(this);
            }

            /// <summary>Field number for the "allow_csr_based_issuance" field.</summary>
            public const int AllowCsrBasedIssuanceFieldNumber = 1;
            private bool allowCsrBasedIssuance_;
            /// <summary>
            /// Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate] by
            /// specifying a CSR.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool AllowCsrBasedIssuance {
              get { return allowCsrBasedIssuance_; }
              set {
                allowCsrBasedIssuance_ = value;
              }
            }

            /// <summary>Field number for the "allow_config_based_issuance" field.</summary>
            public const int AllowConfigBasedIssuanceFieldNumber = 2;
            private bool allowConfigBasedIssuance_;
            /// <summary>
            /// Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate] by
            /// specifying a [CertificateConfig][google.cloud.security.privateca.v1beta1.CertificateConfig].
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool AllowConfigBasedIssuance {
              get { return allowConfigBasedIssuance_; }
              set {
                allowConfigBasedIssuance_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as IssuanceModes);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(IssuanceModes other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (AllowCsrBasedIssuance != other.AllowCsrBasedIssuance) return false;
              if (AllowConfigBasedIssuance != other.AllowConfigBasedIssuance) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (AllowCsrBasedIssuance != false) hash ^= AllowCsrBasedIssuance.GetHashCode();
              if (AllowConfigBasedIssuance != false) hash ^= AllowConfigBasedIssuance.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (AllowCsrBasedIssuance != false) {
                output.WriteRawTag(8);
                output.WriteBool(AllowCsrBasedIssuance);
              }
              if (AllowConfigBasedIssuance != false) {
                output.WriteRawTag(16);
                output.WriteBool(AllowConfigBasedIssuance);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (AllowCsrBasedIssuance != false) {
                output.WriteRawTag(8);
                output.WriteBool(AllowCsrBasedIssuance);
              }
              if (AllowConfigBasedIssuance != false) {
                output.WriteRawTag(16);
                output.WriteBool(AllowConfigBasedIssuance);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (AllowCsrBasedIssuance != false) {
                size += 1 + 1;
              }
              if (AllowConfigBasedIssuance != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(IssuanceModes other) {
              if (other == null) {
                return;
              }
              if (other.AllowCsrBasedIssuance != false) {
                AllowCsrBasedIssuance = other.AllowCsrBasedIssuance;
              }
              if (other.AllowConfigBasedIssuance != false) {
                AllowConfigBasedIssuance = other.AllowConfigBasedIssuance;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    AllowCsrBasedIssuance = input.ReadBool();
                    break;
                  }
                  case 16: {
                    AllowConfigBasedIssuance = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    AllowCsrBasedIssuance = input.ReadBool();
                    break;
                  }
                  case 16: {
                    AllowConfigBasedIssuance = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      /// URLs where a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will publish content.
      /// </summary>
      public sealed partial class AccessUrls : pb::IMessage<AccessUrls>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AccessUrls> _parser = new pb::MessageParser<AccessUrls>(() => new AccessUrls());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AccessUrls> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessUrls() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessUrls(AccessUrls other) : this() {
          caCertificateAccessUrl_ = other.caCertificateAccessUrl_;
          crlAccessUrl_ = other.crlAccessUrl_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessUrls Clone() {
          return new AccessUrls(this);
        }

        /// <summary>Field number for the "ca_certificate_access_url" field.</summary>
        public const int CaCertificateAccessUrlFieldNumber = 1;
        private string caCertificateAccessUrl_ = "";
        /// <summary>
        /// The URL where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CA certificate is
        /// published. This will only be set for CAs that have been activated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CaCertificateAccessUrl {
          get { return caCertificateAccessUrl_; }
          set {
            caCertificateAccessUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "crl_access_url" field.</summary>
        public const int CrlAccessUrlFieldNumber = 2;
        private string crlAccessUrl_ = "";
        /// <summary>
        /// The URL where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CRLs are published. This
        /// will only be set for CAs that have been activated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CrlAccessUrl {
          get { return crlAccessUrl_; }
          set {
            crlAccessUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AccessUrls);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AccessUrls other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (CaCertificateAccessUrl != other.CaCertificateAccessUrl) return false;
          if (CrlAccessUrl != other.CrlAccessUrl) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (CaCertificateAccessUrl.Length != 0) hash ^= CaCertificateAccessUrl.GetHashCode();
          if (CrlAccessUrl.Length != 0) hash ^= CrlAccessUrl.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (CaCertificateAccessUrl.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(CaCertificateAccessUrl);
          }
          if (CrlAccessUrl.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CrlAccessUrl);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (CaCertificateAccessUrl.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(CaCertificateAccessUrl);
          }
          if (CrlAccessUrl.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CrlAccessUrl);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (CaCertificateAccessUrl.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CaCertificateAccessUrl);
          }
          if (CrlAccessUrl.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CrlAccessUrl);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AccessUrls other) {
          if (other == null) {
            return;
          }
          if (other.CaCertificateAccessUrl.Length != 0) {
            CaCertificateAccessUrl = other.CaCertificateAccessUrl;
          }
          if (other.CrlAccessUrl.Length != 0) {
            CrlAccessUrl = other.CrlAccessUrl;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                CaCertificateAccessUrl = input.ReadString();
                break;
              }
              case 18: {
                CrlAccessUrl = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                CaCertificateAccessUrl = input.ReadString();
                break;
              }
              case 18: {
                CrlAccessUrl = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A Cloud KMS key configuration that a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will use.
      /// </summary>
      public sealed partial class KeyVersionSpec : pb::IMessage<KeyVersionSpec>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyVersionSpec> _parser = new pb::MessageParser<KeyVersionSpec>(() => new KeyVersionSpec());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<KeyVersionSpec> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionSpec() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionSpec(KeyVersionSpec other) : this() {
          switch (other.KeyVersionCase) {
            case KeyVersionOneofCase.CloudKmsKeyVersion:
              CloudKmsKeyVersion = other.CloudKmsKeyVersion;
              break;
            case KeyVersionOneofCase.Algorithm:
              Algorithm = other.Algorithm;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionSpec Clone() {
          return new KeyVersionSpec(this);
        }

        /// <summary>Field number for the "cloud_kms_key_version" field.</summary>
        public const int CloudKmsKeyVersionFieldNumber = 1;
        /// <summary>
        /// Required. The resource name for an existing Cloud KMS CryptoKeyVersion in the
        /// format
        /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
        /// This option enables full flexibility in the key's capabilities and
        /// properties.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CloudKmsKeyVersion {
          get { return keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion ? (string) keyVersion_ : ""; }
          set {
            keyVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            keyVersionCase_ = KeyVersionOneofCase.CloudKmsKeyVersion;
          }
        }

        /// <summary>Field number for the "algorithm" field.</summary>
        public const int AlgorithmFieldNumber = 2;
        /// <summary>
        /// Required. The algorithm to use for creating a managed Cloud KMS key for a for a
        /// simplified experience. All managed keys will be have their
        /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] as `HSM`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.SignHashAlgorithm Algorithm {
          get { return keyVersionCase_ == KeyVersionOneofCase.Algorithm ? (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.SignHashAlgorithm) keyVersion_ : global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateAuthority.Types.SignHashAlgorithm.Unspecified; }
          set {
            keyVersion_ = value;
            keyVersionCase_ = KeyVersionOneofCase.Algorithm;
          }
        }

        private object keyVersion_;
        /// <summary>Enum of possible cases for the "KeyVersion" oneof.</summary>
        public enum KeyVersionOneofCase {
          None = 0,
          CloudKmsKeyVersion = 1,
          Algorithm = 2,
        }
        private KeyVersionOneofCase keyVersionCase_ = KeyVersionOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionOneofCase KeyVersionCase {
          get { return keyVersionCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearKeyVersion() {
          keyVersionCase_ = KeyVersionOneofCase.None;
          keyVersion_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as KeyVersionSpec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(KeyVersionSpec other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (CloudKmsKeyVersion != other.CloudKmsKeyVersion) return false;
          if (Algorithm != other.Algorithm) return false;
          if (KeyVersionCase != other.KeyVersionCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) hash ^= CloudKmsKeyVersion.GetHashCode();
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) hash ^= Algorithm.GetHashCode();
          hash ^= (int) keyVersionCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) {
            output.WriteRawTag(10);
            output.WriteString(CloudKmsKeyVersion);
          }
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Algorithm);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) {
            output.WriteRawTag(10);
            output.WriteString(CloudKmsKeyVersion);
          }
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Algorithm);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CloudKmsKeyVersion);
          }
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Algorithm);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(KeyVersionSpec other) {
          if (other == null) {
            return;
          }
          switch (other.KeyVersionCase) {
            case KeyVersionOneofCase.CloudKmsKeyVersion:
              CloudKmsKeyVersion = other.CloudKmsKeyVersion;
              break;
            case KeyVersionOneofCase.Algorithm:
              Algorithm = other.Algorithm;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                CloudKmsKeyVersion = input.ReadString();
                break;
              }
              case 16: {
                keyVersion_ = input.ReadEnum();
                keyVersionCase_ = KeyVersionOneofCase.Algorithm;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                CloudKmsKeyVersion = input.ReadString();
                break;
              }
              case 16: {
                keyVersion_ = input.ReadEnum();
                keyVersionCase_ = KeyVersionOneofCase.Algorithm;
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] corresponds to a signed X.509 certificate
  /// Revocation List (CRL). A CRL contains the serial numbers of certificates that
  /// should no longer be trusted.
  /// </summary>
  public sealed partial class CertificateRevocationList : pb::IMessage<CertificateRevocationList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateRevocationList> _parser = new pb::MessageParser<CertificateRevocationList>(() => new CertificateRevocationList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateRevocationList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateRevocationList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateRevocationList(CertificateRevocationList other) : this() {
      name_ = other.name_;
      sequenceNumber_ = other.sequenceNumber_;
      revokedCertificates_ = other.revokedCertificates_.Clone();
      pemCrl_ = other.pemCrl_;
      accessUrl_ = other.accessUrl_;
      state_ = other.state_;
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateRevocationList Clone() {
      return new CertificateRevocationList(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource path for this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] in
    /// the format
    /// `projects/*/locations/*/certificateAuthorities/*/
    ///    certificateRevocationLists/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sequence_number" field.</summary>
    public const int SequenceNumberFieldNumber = 2;
    private long sequenceNumber_;
    /// <summary>
    /// Output only. The CRL sequence number that appears in pem_crl.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long SequenceNumber {
      get { return sequenceNumber_; }
      set {
        sequenceNumber_ = value;
      }
    }

    /// <summary>Field number for the "revoked_certificates" field.</summary>
    public const int RevokedCertificatesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.RevokedCertificate> _repeated_revokedCertificates_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.RevokedCertificate.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.RevokedCertificate> revokedCertificates_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.RevokedCertificate>();
    /// <summary>
    /// Output only. The revoked serial numbers that appear in pem_crl.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.RevokedCertificate> RevokedCertificates {
      get { return revokedCertificates_; }
    }

    /// <summary>Field number for the "pem_crl" field.</summary>
    public const int PemCrlFieldNumber = 4;
    private string pemCrl_ = "";
    /// <summary>
    /// Output only. The PEM-encoded X.509 CRL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PemCrl {
      get { return pemCrl_; }
      set {
        pemCrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "access_url" field.</summary>
    public const int AccessUrlFieldNumber = 5;
    private string accessUrl_ = "";
    /// <summary>
    /// Output only. The location where 'pem_crl' can be accessed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AccessUrl {
      get { return accessUrl_; }
      set {
        accessUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 6;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State state_ = global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State.Unspecified;
    /// <summary>
    /// Output only. The [State][google.cloud.security.privateca.v1beta1.CertificateRevocationList.State] for this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] was updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 9;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 74);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateRevocationList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateRevocationList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (SequenceNumber != other.SequenceNumber) return false;
      if(!revokedCertificates_.Equals(other.revokedCertificates_)) return false;
      if (PemCrl != other.PemCrl) return false;
      if (AccessUrl != other.AccessUrl) return false;
      if (State != other.State) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (SequenceNumber != 0L) hash ^= SequenceNumber.GetHashCode();
      hash ^= revokedCertificates_.GetHashCode();
      if (PemCrl.Length != 0) hash ^= PemCrl.GetHashCode();
      if (AccessUrl.Length != 0) hash ^= AccessUrl.GetHashCode();
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State.Unspecified) hash ^= State.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (SequenceNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SequenceNumber);
      }
      revokedCertificates_.WriteTo(output, _repeated_revokedCertificates_codec);
      if (PemCrl.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PemCrl);
      }
      if (AccessUrl.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(AccessUrl);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) State);
      }
      if (createTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (SequenceNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SequenceNumber);
      }
      revokedCertificates_.WriteTo(ref output, _repeated_revokedCertificates_codec);
      if (PemCrl.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PemCrl);
      }
      if (AccessUrl.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(AccessUrl);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) State);
      }
      if (createTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (SequenceNumber != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SequenceNumber);
      }
      size += revokedCertificates_.CalculateSize(_repeated_revokedCertificates_codec);
      if (PemCrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PemCrl);
      }
      if (AccessUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AccessUrl);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateRevocationList other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.SequenceNumber != 0L) {
        SequenceNumber = other.SequenceNumber;
      }
      revokedCertificates_.Add(other.revokedCertificates_);
      if (other.PemCrl.Length != 0) {
        PemCrl = other.PemCrl;
      }
      if (other.AccessUrl.Length != 0) {
        AccessUrl = other.AccessUrl;
      }
      if (other.State != global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State.Unspecified) {
        State = other.State;
      }
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            SequenceNumber = input.ReadInt64();
            break;
          }
          case 26: {
            revokedCertificates_.AddEntriesFrom(input, _repeated_revokedCertificates_codec);
            break;
          }
          case 34: {
            PemCrl = input.ReadString();
            break;
          }
          case 42: {
            AccessUrl = input.ReadString();
            break;
          }
          case 48: {
            State = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State) input.ReadEnum();
            break;
          }
          case 58: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 66: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 74: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            SequenceNumber = input.ReadInt64();
            break;
          }
          case 26: {
            revokedCertificates_.AddEntriesFrom(ref input, _repeated_revokedCertificates_codec);
            break;
          }
          case 34: {
            PemCrl = input.ReadString();
            break;
          }
          case 42: {
            AccessUrl = input.ReadString();
            break;
          }
          case 48: {
            State = (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Types.State) input.ReadEnum();
            break;
          }
          case 58: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 66: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 74: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateRevocationList message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The state of a [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList], indicating if it is current.
      /// </summary>
      public enum State {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("STATE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// The [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] is up to date.
        /// </summary>
        [pbr::OriginalName("ACTIVE")] Active = 1,
        /// <summary>
        /// The [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] is no longer current.
        /// </summary>
        [pbr::OriginalName("SUPERSEDED")] Superseded = 2,
      }

      /// <summary>
      /// Describes a revoked [Certificate][google.cloud.security.privateca.v1beta1.Certificate].
      /// </summary>
      public sealed partial class RevokedCertificate : pb::IMessage<RevokedCertificate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RevokedCertificate> _parser = new pb::MessageParser<RevokedCertificate>(() => new RevokedCertificate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RevokedCertificate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateRevocationList.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevokedCertificate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevokedCertificate(RevokedCertificate other) : this() {
          certificate_ = other.certificate_;
          hexSerialNumber_ = other.hexSerialNumber_;
          revocationReason_ = other.revocationReason_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevokedCertificate Clone() {
          return new RevokedCertificate(this);
        }

        /// <summary>Field number for the "certificate" field.</summary>
        public const int CertificateFieldNumber = 1;
        private string certificate_ = "";
        /// <summary>
        /// The resource path for the [Certificate][google.cloud.security.privateca.v1beta1.Certificate] in the format
        /// `projects/*/locations/*/certificateAuthorities/*/certificates/*`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Certificate {
          get { return certificate_; }
          set {
            certificate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "hex_serial_number" field.</summary>
        public const int HexSerialNumberFieldNumber = 2;
        private string hexSerialNumber_ = "";
        /// <summary>
        /// The serial number of the [Certificate][google.cloud.security.privateca.v1beta1.Certificate].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string HexSerialNumber {
          get { return hexSerialNumber_; }
          set {
            hexSerialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "revocation_reason" field.</summary>
        public const int RevocationReasonFieldNumber = 3;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason revocationReason_ = global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified;
        /// <summary>
        /// The reason the [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason RevocationReason {
          get { return revocationReason_; }
          set {
            revocationReason_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RevokedCertificate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RevokedCertificate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Certificate != other.Certificate) return false;
          if (HexSerialNumber != other.HexSerialNumber) return false;
          if (RevocationReason != other.RevocationReason) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Certificate.Length != 0) hash ^= Certificate.GetHashCode();
          if (HexSerialNumber.Length != 0) hash ^= HexSerialNumber.GetHashCode();
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) hash ^= RevocationReason.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Certificate.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Certificate);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(HexSerialNumber);
          }
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            output.WriteRawTag(24);
            output.WriteEnum((int) RevocationReason);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Certificate.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Certificate);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(HexSerialNumber);
          }
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            output.WriteRawTag(24);
            output.WriteEnum((int) RevocationReason);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Certificate.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Certificate);
          }
          if (HexSerialNumber.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(HexSerialNumber);
          }
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RevocationReason);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RevokedCertificate other) {
          if (other == null) {
            return;
          }
          if (other.Certificate.Length != 0) {
            Certificate = other.Certificate;
          }
          if (other.HexSerialNumber.Length != 0) {
            HexSerialNumber = other.HexSerialNumber;
          }
          if (other.RevocationReason != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            RevocationReason = other.RevocationReason;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Certificate = input.ReadString();
                break;
              }
              case 18: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 24: {
                RevocationReason = (global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Certificate = input.ReadString();
                break;
              }
              case 18: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 24: {
                RevocationReason = (global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [Certificate][google.cloud.security.privateca.v1beta1.Certificate] corresponds to a signed X.509 certificate issued by a
  /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  /// </summary>
  public sealed partial class Certificate : pb::IMessage<Certificate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Certificate> _parser = new pb::MessageParser<Certificate>(() => new Certificate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Certificate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Certificate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Certificate(Certificate other) : this() {
      name_ = other.name_;
      lifetime_ = other.lifetime_ != null ? other.lifetime_.Clone() : null;
      revocationDetails_ = other.revocationDetails_ != null ? other.revocationDetails_.Clone() : null;
      pemCertificate_ = other.pemCertificate_;
      certificateDescription_ = other.certificateDescription_ != null ? other.certificateDescription_.Clone() : null;
      pemCertificateChain_ = other.pemCertificateChain_.Clone();
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      switch (other.CertificateConfigCase) {
        case CertificateConfigOneofCase.PemCsr:
          PemCsr = other.PemCsr;
          break;
        case CertificateConfigOneofCase.Config:
          Config = other.Config.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Certificate Clone() {
      return new Certificate(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource path for this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] in the format
    /// `projects/*/locations/*/certificateAuthorities/*/certificates/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "pem_csr" field.</summary>
    public const int PemCsrFieldNumber = 2;
    /// <summary>
    /// Immutable. A pem-encoded X.509 certificate signing request (CSR).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PemCsr {
      get { return certificateConfigCase_ == CertificateConfigOneofCase.PemCsr ? (string) certificateConfig_ : ""; }
      set {
        certificateConfig_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        certificateConfigCase_ = CertificateConfigOneofCase.PemCsr;
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 3;
    /// <summary>
    /// Immutable. A description of the certificate and key that does not require X.509 or
    /// ASN.1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig Config {
      get { return certificateConfigCase_ == CertificateConfigOneofCase.Config ? (global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig) certificateConfig_ : null; }
      set {
        certificateConfig_ = value;
        certificateConfigCase_ = value == null ? CertificateConfigOneofCase.None : CertificateConfigOneofCase.Config;
      }
    }

    /// <summary>Field number for the "lifetime" field.</summary>
    public const int LifetimeFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration lifetime_;
    /// <summary>
    /// Required. Immutable. The desired lifetime of a certificate. Used to create the
    /// "not_before_time" and "not_after_time" fields inside an X.509
    /// certificate. Note that the lifetime may be truncated if it would extend
    /// past the life of any certificate authority in the issuing chain.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Lifetime {
      get { return lifetime_; }
      set {
        lifetime_ = value;
      }
    }

    /// <summary>Field number for the "revocation_details" field.</summary>
    public const int RevocationDetailsFieldNumber = 5;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Types.RevocationDetails revocationDetails_;
    /// <summary>
    /// Output only. Details regarding the revocation of this [Certificate][google.cloud.security.privateca.v1beta1.Certificate]. This
    /// [Certificate][google.cloud.security.privateca.v1beta1.Certificate] is considered revoked if and only if this field is present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Types.RevocationDetails RevocationDetails {
      get { return revocationDetails_; }
      set {
        revocationDetails_ = value;
      }
    }

    /// <summary>Field number for the "pem_certificate" field.</summary>
    public const int PemCertificateFieldNumber = 6;
    private string pemCertificate_ = "";
    /// <summary>
    /// Output only. The pem-encoded, signed X.509 certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PemCertificate {
      get { return pemCertificate_; }
      set {
        pemCertificate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "certificate_description" field.</summary>
    public const int CertificateDescriptionFieldNumber = 7;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription certificateDescription_;
    /// <summary>
    /// Output only. A structured description of the issued X.509 certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription CertificateDescription {
      get { return certificateDescription_; }
      set {
        certificateDescription_ = value;
      }
    }

    /// <summary>Field number for the "pem_certificate_chain" field.</summary>
    public const int PemCertificateChainFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_pemCertificateChain_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> pemCertificateChain_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Output only. The chain that may be used to verify the X.509 certificate. Expected to be
    /// in issuer-to-root order according to RFC 5246.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> PemCertificateChain {
      get { return pemCertificateChain_; }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 9;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 10;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 11;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 90);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    private object certificateConfig_;
    /// <summary>Enum of possible cases for the "certificate_config" oneof.</summary>
    public enum CertificateConfigOneofCase {
      None = 0,
      PemCsr = 2,
      Config = 3,
    }
    private CertificateConfigOneofCase certificateConfigCase_ = CertificateConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfigOneofCase CertificateConfigCase {
      get { return certificateConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCertificateConfig() {
      certificateConfigCase_ = CertificateConfigOneofCase.None;
      certificateConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Certificate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Certificate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (PemCsr != other.PemCsr) return false;
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(Lifetime, other.Lifetime)) return false;
      if (!object.Equals(RevocationDetails, other.RevocationDetails)) return false;
      if (PemCertificate != other.PemCertificate) return false;
      if (!object.Equals(CertificateDescription, other.CertificateDescription)) return false;
      if(!pemCertificateChain_.Equals(other.pemCertificateChain_)) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      if (CertificateConfigCase != other.CertificateConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) hash ^= PemCsr.GetHashCode();
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) hash ^= Config.GetHashCode();
      if (lifetime_ != null) hash ^= Lifetime.GetHashCode();
      if (revocationDetails_ != null) hash ^= RevocationDetails.GetHashCode();
      if (PemCertificate.Length != 0) hash ^= PemCertificate.GetHashCode();
      if (certificateDescription_ != null) hash ^= CertificateDescription.GetHashCode();
      hash ^= pemCertificateChain_.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      hash ^= (int) certificateConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) {
        output.WriteRawTag(18);
        output.WriteString(PemCsr);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
        output.WriteRawTag(26);
        output.WriteMessage(Config);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lifetime);
      }
      if (revocationDetails_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RevocationDetails);
      }
      if (PemCertificate.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(PemCertificate);
      }
      if (certificateDescription_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CertificateDescription);
      }
      pemCertificateChain_.WriteTo(output, _repeated_pemCertificateChain_codec);
      if (createTime_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) {
        output.WriteRawTag(18);
        output.WriteString(PemCsr);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
        output.WriteRawTag(26);
        output.WriteMessage(Config);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lifetime);
      }
      if (revocationDetails_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RevocationDetails);
      }
      if (PemCertificate.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(PemCertificate);
      }
      if (certificateDescription_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CertificateDescription);
      }
      pemCertificateChain_.WriteTo(ref output, _repeated_pemCertificateChain_codec);
      if (createTime_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PemCsr);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (lifetime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifetime);
      }
      if (revocationDetails_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RevocationDetails);
      }
      if (PemCertificate.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PemCertificate);
      }
      if (certificateDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CertificateDescription);
      }
      size += pemCertificateChain_.CalculateSize(_repeated_pemCertificateChain_codec);
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Certificate other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.lifetime_ != null) {
        if (lifetime_ == null) {
          Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Lifetime.MergeFrom(other.Lifetime);
      }
      if (other.revocationDetails_ != null) {
        if (revocationDetails_ == null) {
          RevocationDetails = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Types.RevocationDetails();
        }
        RevocationDetails.MergeFrom(other.RevocationDetails);
      }
      if (other.PemCertificate.Length != 0) {
        PemCertificate = other.PemCertificate;
      }
      if (other.certificateDescription_ != null) {
        if (certificateDescription_ == null) {
          CertificateDescription = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription();
        }
        CertificateDescription.MergeFrom(other.CertificateDescription);
      }
      pemCertificateChain_.Add(other.pemCertificateChain_);
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      labels_.Add(other.labels_);
      switch (other.CertificateConfigCase) {
        case CertificateConfigOneofCase.PemCsr:
          PemCsr = other.PemCsr;
          break;
        case CertificateConfigOneofCase.Config:
          if (Config == null) {
            Config = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig();
          }
          Config.MergeFrom(other.Config);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            PemCsr = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig();
            if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
              subBuilder.MergeFrom(Config);
            }
            input.ReadMessage(subBuilder);
            Config = subBuilder;
            break;
          }
          case 34: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 42: {
            if (revocationDetails_ == null) {
              RevocationDetails = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Types.RevocationDetails();
            }
            input.ReadMessage(RevocationDetails);
            break;
          }
          case 50: {
            PemCertificate = input.ReadString();
            break;
          }
          case 58: {
            if (certificateDescription_ == null) {
              CertificateDescription = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription();
            }
            input.ReadMessage(CertificateDescription);
            break;
          }
          case 66: {
            pemCertificateChain_.AddEntriesFrom(input, _repeated_pemCertificateChain_codec);
            break;
          }
          case 74: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 82: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 90: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            PemCsr = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig();
            if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
              subBuilder.MergeFrom(Config);
            }
            input.ReadMessage(subBuilder);
            Config = subBuilder;
            break;
          }
          case 34: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 42: {
            if (revocationDetails_ == null) {
              RevocationDetails = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Types.RevocationDetails();
            }
            input.ReadMessage(RevocationDetails);
            break;
          }
          case 50: {
            PemCertificate = input.ReadString();
            break;
          }
          case 58: {
            if (certificateDescription_ == null) {
              CertificateDescription = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription();
            }
            input.ReadMessage(CertificateDescription);
            break;
          }
          case 66: {
            pemCertificateChain_.AddEntriesFrom(ref input, _repeated_pemCertificateChain_codec);
            break;
          }
          case 74: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 82: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 90: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Certificate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes fields that are relavent to the revocation of a [Certificate][google.cloud.security.privateca.v1beta1.Certificate].
      /// </summary>
      public sealed partial class RevocationDetails : pb::IMessage<RevocationDetails>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RevocationDetails> _parser = new pb::MessageParser<RevocationDetails>(() => new RevocationDetails());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RevocationDetails> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.Certificate.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevocationDetails() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevocationDetails(RevocationDetails other) : this() {
          revocationState_ = other.revocationState_;
          revocationTime_ = other.revocationTime_ != null ? other.revocationTime_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevocationDetails Clone() {
          return new RevocationDetails(this);
        }

        /// <summary>Field number for the "revocation_state" field.</summary>
        public const int RevocationStateFieldNumber = 1;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason revocationState_ = global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified;
        /// <summary>
        /// Indicates why a [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason RevocationState {
          get { return revocationState_; }
          set {
            revocationState_ = value;
          }
        }

        /// <summary>Field number for the "revocation_time" field.</summary>
        public const int RevocationTimeFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Timestamp revocationTime_;
        /// <summary>
        /// The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp RevocationTime {
          get { return revocationTime_; }
          set {
            revocationTime_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RevocationDetails);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RevocationDetails other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (RevocationState != other.RevocationState) return false;
          if (!object.Equals(RevocationTime, other.RevocationTime)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) hash ^= RevocationState.GetHashCode();
          if (revocationTime_ != null) hash ^= RevocationTime.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) RevocationState);
          }
          if (revocationTime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(RevocationTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) RevocationState);
          }
          if (revocationTime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(RevocationTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RevocationState);
          }
          if (revocationTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RevocationTime);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RevocationDetails other) {
          if (other == null) {
            return;
          }
          if (other.RevocationState != global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason.Unspecified) {
            RevocationState = other.RevocationState;
          }
          if (other.revocationTime_ != null) {
            if (revocationTime_ == null) {
              RevocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            RevocationTime.MergeFrom(other.RevocationTime);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                RevocationState = (global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason) input.ReadEnum();
                break;
              }
              case 18: {
                if (revocationTime_ == null) {
                  RevocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(RevocationTime);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                RevocationState = (global::Google.Cloud.Security.PrivateCA.V1Beta1.RevocationReason) input.ReadEnum();
                break;
              }
              case 18: {
                if (revocationTime_ == null) {
                  RevocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(RevocationTime);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] refers to a managed [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues]. Those, in
  /// turn, are used to describe certain fields of an X.509 certificate, such as
  /// the key usage fields, fields specific to CA certificates, certificate policy
  /// extensions and custom extensions.
  /// </summary>
  public sealed partial class ReusableConfig : pb::IMessage<ReusableConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReusableConfig> _parser = new pb::MessageParser<ReusableConfig>(() => new ReusableConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReusableConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfig(ReusableConfig other) : this() {
      name_ = other.name_;
      values_ = other.values_ != null ? other.values_.Clone() : null;
      description_ = other.description_;
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfig Clone() {
      return new ReusableConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource path for this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] in the format
    /// `projects/*/locations/*/reusableConfigs/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues values_;
    /// <summary>
    /// Required. The config values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues Values {
      get { return values_; }
      set {
        values_ = value;
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 3;
    private string description_ = "";
    /// <summary>
    /// Optional. A human-readable description of scenarios these ReusableConfigValues may be
    /// compatible with.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] was updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 6;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 50);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReusableConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReusableConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Values, other.Values)) return false;
      if (Description != other.Description) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (values_ != null) hash ^= Values.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (values_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Values);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Description);
      }
      if (createTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (values_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Values);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Description);
      }
      if (createTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (values_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Values);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReusableConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.values_ != null) {
        if (values_ == null) {
          Values = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
        }
        Values.MergeFrom(other.Values);
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (values_ == null) {
              Values = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
            }
            input.ReadMessage(Values);
            break;
          }
          case 26: {
            Description = input.ReadString();
            break;
          }
          case 34: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 42: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 50: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (values_ == null) {
              Values = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
            }
            input.ReadMessage(Values);
            break;
          }
          case 26: {
            Description = input.ReadString();
            break;
          }
          case 34: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 42: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 50: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues] is used to describe certain fields of an
  /// X.509 certificate, such as the key usage fields, fields specific to CA
  /// certificates, certificate policy extensions and custom extensions.
  /// </summary>
  public sealed partial class ReusableConfigValues : pb::IMessage<ReusableConfigValues>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReusableConfigValues> _parser = new pb::MessageParser<ReusableConfigValues>(() => new ReusableConfigValues());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReusableConfigValues> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfigValues() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfigValues(ReusableConfigValues other) : this() {
      keyUsage_ = other.keyUsage_ != null ? other.keyUsage_.Clone() : null;
      caOptions_ = other.caOptions_ != null ? other.caOptions_.Clone() : null;
      policyIds_ = other.policyIds_.Clone();
      aiaOcspServers_ = other.aiaOcspServers_.Clone();
      additionalExtensions_ = other.additionalExtensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfigValues Clone() {
      return new ReusableConfigValues(this);
    }

    /// <summary>Field number for the "key_usage" field.</summary>
    public const int KeyUsageFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage keyUsage_;
    /// <summary>
    /// Optional. Indicates the intended use for keys that correspond to a certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage KeyUsage {
      get { return keyUsage_; }
      set {
        keyUsage_ = value;
      }
    }

    /// <summary>Field number for the "ca_options" field.</summary>
    public const int CaOptionsFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Types.CaOptions caOptions_;
    /// <summary>
    /// Optional. Describes options in this [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues] that are
    /// relevant in a CA certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Types.CaOptions CaOptions {
      get { return caOptions_; }
      set {
        caOptions_ = value;
      }
    }

    /// <summary>Field number for the "policy_ids" field.</summary>
    public const int PolicyIdsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId> _repeated_policyIds_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId> policyIds_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId>();
    /// <summary>
    /// Optional. Describes the X.509 certificate policy object identifiers, per
    /// https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId> PolicyIds {
      get { return policyIds_; }
    }

    /// <summary>Field number for the "aia_ocsp_servers" field.</summary>
    public const int AiaOcspServersFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_aiaOcspServers_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> aiaOcspServers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses
    /// that appear in the "Authority Information Access" extension in the
    /// certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AiaOcspServers {
      get { return aiaOcspServers_; }
    }

    /// <summary>Field number for the "additional_extensions" field.</summary>
    public const int AdditionalExtensionsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension> _repeated_additionalExtensions_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension> additionalExtensions_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension>();
    /// <summary>
    /// Optional. Describes custom X.509 extensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension> AdditionalExtensions {
      get { return additionalExtensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReusableConfigValues);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReusableConfigValues other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(KeyUsage, other.KeyUsage)) return false;
      if (!object.Equals(CaOptions, other.CaOptions)) return false;
      if(!policyIds_.Equals(other.policyIds_)) return false;
      if(!aiaOcspServers_.Equals(other.aiaOcspServers_)) return false;
      if(!additionalExtensions_.Equals(other.additionalExtensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (keyUsage_ != null) hash ^= KeyUsage.GetHashCode();
      if (caOptions_ != null) hash ^= CaOptions.GetHashCode();
      hash ^= policyIds_.GetHashCode();
      hash ^= aiaOcspServers_.GetHashCode();
      hash ^= additionalExtensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (keyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KeyUsage);
      }
      if (caOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CaOptions);
      }
      policyIds_.WriteTo(output, _repeated_policyIds_codec);
      aiaOcspServers_.WriteTo(output, _repeated_aiaOcspServers_codec);
      additionalExtensions_.WriteTo(output, _repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (keyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KeyUsage);
      }
      if (caOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CaOptions);
      }
      policyIds_.WriteTo(ref output, _repeated_policyIds_codec);
      aiaOcspServers_.WriteTo(ref output, _repeated_aiaOcspServers_codec);
      additionalExtensions_.WriteTo(ref output, _repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (keyUsage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyUsage);
      }
      if (caOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CaOptions);
      }
      size += policyIds_.CalculateSize(_repeated_policyIds_codec);
      size += aiaOcspServers_.CalculateSize(_repeated_aiaOcspServers_codec);
      size += additionalExtensions_.CalculateSize(_repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReusableConfigValues other) {
      if (other == null) {
        return;
      }
      if (other.keyUsage_ != null) {
        if (keyUsage_ == null) {
          KeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage();
        }
        KeyUsage.MergeFrom(other.KeyUsage);
      }
      if (other.caOptions_ != null) {
        if (caOptions_ == null) {
          CaOptions = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Types.CaOptions();
        }
        CaOptions.MergeFrom(other.CaOptions);
      }
      policyIds_.Add(other.policyIds_);
      aiaOcspServers_.Add(other.aiaOcspServers_);
      additionalExtensions_.Add(other.additionalExtensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (keyUsage_ == null) {
              KeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage();
            }
            input.ReadMessage(KeyUsage);
            break;
          }
          case 18: {
            if (caOptions_ == null) {
              CaOptions = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Types.CaOptions();
            }
            input.ReadMessage(CaOptions);
            break;
          }
          case 26: {
            policyIds_.AddEntriesFrom(input, _repeated_policyIds_codec);
            break;
          }
          case 34: {
            aiaOcspServers_.AddEntriesFrom(input, _repeated_aiaOcspServers_codec);
            break;
          }
          case 42: {
            additionalExtensions_.AddEntriesFrom(input, _repeated_additionalExtensions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (keyUsage_ == null) {
              KeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage();
            }
            input.ReadMessage(KeyUsage);
            break;
          }
          case 18: {
            if (caOptions_ == null) {
              CaOptions = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Types.CaOptions();
            }
            input.ReadMessage(CaOptions);
            break;
          }
          case 26: {
            policyIds_.AddEntriesFrom(ref input, _repeated_policyIds_codec);
            break;
          }
          case 34: {
            aiaOcspServers_.AddEntriesFrom(ref input, _repeated_aiaOcspServers_codec);
            break;
          }
          case 42: {
            additionalExtensions_.AddEntriesFrom(ref input, _repeated_additionalExtensions_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ReusableConfigValues message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes values that are relevant in a CA certificate.
      /// </summary>
      public sealed partial class CaOptions : pb::IMessage<CaOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CaOptions> _parser = new pb::MessageParser<CaOptions>(() => new CaOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CaOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CaOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CaOptions(CaOptions other) : this() {
          IsCa = other.IsCa;
          MaxIssuerPathLength = other.MaxIssuerPathLength;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CaOptions Clone() {
          return new CaOptions(this);
        }

        /// <summary>Field number for the "is_ca" field.</summary>
        public const int IsCaFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_isCa_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? isCa_;
        /// <summary>
        /// Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this
        /// value is missing, the extension will be omitted from the CA certificate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? IsCa {
          get { return isCa_; }
          set {
            isCa_ = value;
          }
        }


        /// <summary>Field number for the "max_issuer_path_length" field.</summary>
        public const int MaxIssuerPathLengthFieldNumber = 2;
        private static readonly pb::FieldCodec<int?> _single_maxIssuerPathLength_codec = pb::FieldCodec.ForStructWrapper<int>(18);
        private int? maxIssuerPathLength_;
        /// <summary>
        /// Optional. Refers to the path length restriction X.509 extension. For a CA
        /// certificate, this value describes the depth of subordinate CA
        /// certificates that are allowed.
        /// If this value is less than 0, the request will fail.
        /// If this value is missing, the max path length will be omitted from the
        /// CA certificate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int? MaxIssuerPathLength {
          get { return maxIssuerPathLength_; }
          set {
            maxIssuerPathLength_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CaOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CaOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (IsCa != other.IsCa) return false;
          if (MaxIssuerPathLength != other.MaxIssuerPathLength) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (isCa_ != null) hash ^= IsCa.GetHashCode();
          if (maxIssuerPathLength_ != null) hash ^= MaxIssuerPathLength.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (isCa_ != null) {
            _single_isCa_codec.WriteTagAndValue(output, IsCa);
          }
          if (maxIssuerPathLength_ != null) {
            _single_maxIssuerPathLength_codec.WriteTagAndValue(output, MaxIssuerPathLength);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (isCa_ != null) {
            _single_isCa_codec.WriteTagAndValue(ref output, IsCa);
          }
          if (maxIssuerPathLength_ != null) {
            _single_maxIssuerPathLength_codec.WriteTagAndValue(ref output, MaxIssuerPathLength);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (isCa_ != null) {
            size += _single_isCa_codec.CalculateSizeWithTag(IsCa);
          }
          if (maxIssuerPathLength_ != null) {
            size += _single_maxIssuerPathLength_codec.CalculateSizeWithTag(MaxIssuerPathLength);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CaOptions other) {
          if (other == null) {
            return;
          }
          if (other.isCa_ != null) {
            if (isCa_ == null || other.IsCa != false) {
              IsCa = other.IsCa;
            }
          }
          if (other.maxIssuerPathLength_ != null) {
            if (maxIssuerPathLength_ == null || other.MaxIssuerPathLength != 0) {
              MaxIssuerPathLength = other.MaxIssuerPathLength;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_isCa_codec.Read(input);
                if (isCa_ == null || value != false) {
                  IsCa = value;
                }
                break;
              }
              case 18: {
                int? value = _single_maxIssuerPathLength_codec.Read(input);
                if (maxIssuerPathLength_ == null || value != 0) {
                  MaxIssuerPathLength = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                bool? value = _single_isCa_codec.Read(ref input);
                if (isCa_ == null || value != false) {
                  IsCa = value;
                }
                break;
              }
              case 18: {
                int? value = _single_maxIssuerPathLength_codec.Read(ref input);
                if (maxIssuerPathLength_ == null || value != 0) {
                  MaxIssuerPathLength = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] describes values that may assist in creating an
  /// X.509 certificate, or a reference to a pre-defined set of values.
  /// </summary>
  public sealed partial class ReusableConfigWrapper : pb::IMessage<ReusableConfigWrapper>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReusableConfigWrapper> _parser = new pb::MessageParser<ReusableConfigWrapper>(() => new ReusableConfigWrapper());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReusableConfigWrapper> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfigWrapper() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfigWrapper(ReusableConfigWrapper other) : this() {
      switch (other.ConfigValuesCase) {
        case ConfigValuesOneofCase.ReusableConfig:
          ReusableConfig = other.ReusableConfig;
          break;
        case ConfigValuesOneofCase.ReusableConfigValues:
          ReusableConfigValues = other.ReusableConfigValues.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReusableConfigWrapper Clone() {
      return new ReusableConfigWrapper(this);
    }

    /// <summary>Field number for the "reusable_config" field.</summary>
    public const int ReusableConfigFieldNumber = 1;
    /// <summary>
    /// Required. A resource path to a [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] in the format
    /// `projects/*/locations/*/reusableConfigs/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ReusableConfig {
      get { return configValuesCase_ == ConfigValuesOneofCase.ReusableConfig ? (string) configValues_ : ""; }
      set {
        configValues_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        configValuesCase_ = ConfigValuesOneofCase.ReusableConfig;
      }
    }

    /// <summary>Field number for the "reusable_config_values" field.</summary>
    public const int ReusableConfigValuesFieldNumber = 2;
    /// <summary>
    /// Required. A user-specified inline [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues ReusableConfigValues {
      get { return configValuesCase_ == ConfigValuesOneofCase.ReusableConfigValues ? (global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues) configValues_ : null; }
      set {
        configValues_ = value;
        configValuesCase_ = value == null ? ConfigValuesOneofCase.None : ConfigValuesOneofCase.ReusableConfigValues;
      }
    }

    private object configValues_;
    /// <summary>Enum of possible cases for the "config_values" oneof.</summary>
    public enum ConfigValuesOneofCase {
      None = 0,
      ReusableConfig = 1,
      ReusableConfigValues = 2,
    }
    private ConfigValuesOneofCase configValuesCase_ = ConfigValuesOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigValuesOneofCase ConfigValuesCase {
      get { return configValuesCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConfigValues() {
      configValuesCase_ = ConfigValuesOneofCase.None;
      configValues_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReusableConfigWrapper);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReusableConfigWrapper other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ReusableConfig != other.ReusableConfig) return false;
      if (!object.Equals(ReusableConfigValues, other.ReusableConfigValues)) return false;
      if (ConfigValuesCase != other.ConfigValuesCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfig) hash ^= ReusableConfig.GetHashCode();
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfigValues) hash ^= ReusableConfigValues.GetHashCode();
      hash ^= (int) configValuesCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfig) {
        output.WriteRawTag(10);
        output.WriteString(ReusableConfig);
      }
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfigValues) {
        output.WriteRawTag(18);
        output.WriteMessage(ReusableConfigValues);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfig) {
        output.WriteRawTag(10);
        output.WriteString(ReusableConfig);
      }
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfigValues) {
        output.WriteRawTag(18);
        output.WriteMessage(ReusableConfigValues);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfig) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ReusableConfig);
      }
      if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfigValues) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReusableConfigValues);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReusableConfigWrapper other) {
      if (other == null) {
        return;
      }
      switch (other.ConfigValuesCase) {
        case ConfigValuesOneofCase.ReusableConfig:
          ReusableConfig = other.ReusableConfig;
          break;
        case ConfigValuesOneofCase.ReusableConfigValues:
          if (ReusableConfigValues == null) {
            ReusableConfigValues = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
          }
          ReusableConfigValues.MergeFrom(other.ReusableConfigValues);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ReusableConfig = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
            if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfigValues) {
              subBuilder.MergeFrom(ReusableConfigValues);
            }
            input.ReadMessage(subBuilder);
            ReusableConfigValues = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ReusableConfig = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
            if (configValuesCase_ == ConfigValuesOneofCase.ReusableConfigValues) {
              subBuilder.MergeFrom(ReusableConfigValues);
            }
            input.ReadMessage(subBuilder);
            ReusableConfigValues = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes a subordinate CA's issuers. This is either a resource path to a
  /// known issuing [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], or a PEM issuer certificate chain.
  /// </summary>
  public sealed partial class SubordinateConfig : pb::IMessage<SubordinateConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SubordinateConfig> _parser = new pb::MessageParser<SubordinateConfig>(() => new SubordinateConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SubordinateConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfig(SubordinateConfig other) : this() {
      switch (other.SubordinateConfigCase) {
        case SubordinateConfigOneofCase.CertificateAuthority:
          CertificateAuthority = other.CertificateAuthority;
          break;
        case SubordinateConfigOneofCase.PemIssuerChain:
          PemIssuerChain = other.PemIssuerChain.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfig Clone() {
      return new SubordinateConfig(this);
    }

    /// <summary>Field number for the "certificate_authority" field.</summary>
    public const int CertificateAuthorityFieldNumber = 1;
    /// <summary>
    /// Required. This can refer to a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] in the same project that
    /// was used to create a subordinate [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. This field
    /// is used for information and usability purposes only. The resource name
    /// is in the format `projects/*/locations/*/certificateAuthorities/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CertificateAuthority {
      get { return subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority ? (string) subordinateConfig_ : ""; }
      set {
        subordinateConfig_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        subordinateConfigCase_ = SubordinateConfigOneofCase.CertificateAuthority;
      }
    }

    /// <summary>Field number for the "pem_issuer_chain" field.</summary>
    public const int PemIssuerChainFieldNumber = 2;
    /// <summary>
    /// Required. Contains the PEM certificate chain for the issuers of this
    /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], but not pem certificate for this CA itself.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain PemIssuerChain {
      get { return subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain ? (global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain) subordinateConfig_ : null; }
      set {
        subordinateConfig_ = value;
        subordinateConfigCase_ = value == null ? SubordinateConfigOneofCase.None : SubordinateConfigOneofCase.PemIssuerChain;
      }
    }

    private object subordinateConfig_;
    /// <summary>Enum of possible cases for the "subordinate_config" oneof.</summary>
    public enum SubordinateConfigOneofCase {
      None = 0,
      CertificateAuthority = 1,
      PemIssuerChain = 2,
    }
    private SubordinateConfigOneofCase subordinateConfigCase_ = SubordinateConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfigOneofCase SubordinateConfigCase {
      get { return subordinateConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubordinateConfig() {
      subordinateConfigCase_ = SubordinateConfigOneofCase.None;
      subordinateConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SubordinateConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SubordinateConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CertificateAuthority != other.CertificateAuthority) return false;
      if (!object.Equals(PemIssuerChain, other.PemIssuerChain)) return false;
      if (SubordinateConfigCase != other.SubordinateConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) hash ^= CertificateAuthority.GetHashCode();
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) hash ^= PemIssuerChain.GetHashCode();
      hash ^= (int) subordinateConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) {
        output.WriteRawTag(10);
        output.WriteString(CertificateAuthority);
      }
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
        output.WriteRawTag(18);
        output.WriteMessage(PemIssuerChain);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) {
        output.WriteRawTag(10);
        output.WriteString(CertificateAuthority);
      }
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
        output.WriteRawTag(18);
        output.WriteMessage(PemIssuerChain);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CertificateAuthority);
      }
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PemIssuerChain);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SubordinateConfig other) {
      if (other == null) {
        return;
      }
      switch (other.SubordinateConfigCase) {
        case SubordinateConfigOneofCase.CertificateAuthority:
          CertificateAuthority = other.CertificateAuthority;
          break;
        case SubordinateConfigOneofCase.PemIssuerChain:
          if (PemIssuerChain == null) {
            PemIssuerChain = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain();
          }
          PemIssuerChain.MergeFrom(other.PemIssuerChain);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CertificateAuthority = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain();
            if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
              subBuilder.MergeFrom(PemIssuerChain);
            }
            input.ReadMessage(subBuilder);
            PemIssuerChain = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CertificateAuthority = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain subBuilder = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Types.SubordinateConfigChain();
            if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
              subBuilder.MergeFrom(PemIssuerChain);
            }
            input.ReadMessage(subBuilder);
            PemIssuerChain = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SubordinateConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// This message describes a subordinate CA's issuer certificate chain. This
      /// wrapper exists for compatibility reasons.
      /// </summary>
      public sealed partial class SubordinateConfigChain : pb::IMessage<SubordinateConfigChain>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SubordinateConfigChain> _parser = new pb::MessageParser<SubordinateConfigChain>(() => new SubordinateConfigChain());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SubordinateConfigChain> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.SubordinateConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubordinateConfigChain() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubordinateConfigChain(SubordinateConfigChain other) : this() {
          pemCertificates_ = other.pemCertificates_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubordinateConfigChain Clone() {
          return new SubordinateConfigChain(this);
        }

        /// <summary>Field number for the "pem_certificates" field.</summary>
        public const int PemCertificatesFieldNumber = 1;
        private static readonly pb::FieldCodec<string> _repeated_pemCertificates_codec
            = pb::FieldCodec.ForString(10);
        private readonly pbc::RepeatedField<string> pemCertificates_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Required. Expected to be in leaf-to-root order according to RFC 5246.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> PemCertificates {
          get { return pemCertificates_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SubordinateConfigChain);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SubordinateConfigChain other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!pemCertificates_.Equals(other.pemCertificates_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= pemCertificates_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          pemCertificates_.WriteTo(output, _repeated_pemCertificates_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          pemCertificates_.WriteTo(ref output, _repeated_pemCertificates_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += pemCertificates_.CalculateSize(_repeated_pemCertificates_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SubordinateConfigChain other) {
          if (other == null) {
            return;
          }
          pemCertificates_.Add(other.pemCertificates_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                pemCertificates_.AddEntriesFrom(input, _repeated_pemCertificates_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                pemCertificates_.AddEntriesFrom(ref input, _repeated_pemCertificates_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [PublicKey][google.cloud.security.privateca.v1beta1.PublicKey] describes a public key.
  /// </summary>
  public sealed partial class PublicKey : pb::IMessage<PublicKey>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PublicKey> _parser = new pb::MessageParser<PublicKey>(() => new PublicKey());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PublicKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PublicKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PublicKey(PublicKey other) : this() {
      type_ = other.type_;
      key_ = other.key_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PublicKey Clone() {
      return new PublicKey(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType type_ = global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType.Unspecified;
    /// <summary>
    /// Required. The type of public key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 2;
    private pb::ByteString key_ = pb::ByteString.Empty;
    /// <summary>
    /// Required. A public key. Padding and encoding varies by 'KeyType' and is described
    /// along with the KeyType values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Key {
      get { return key_; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PublicKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PublicKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Key != other.Key) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType.Unspecified) hash ^= Type.GetHashCode();
      if (Key.Length != 0) hash ^= Key.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (Key.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Key);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (Key.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Key);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Key.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Key);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PublicKey other) {
      if (other == null) {
        return;
      }
      if (other.Type != global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType.Unspecified) {
        Type = other.Type;
      }
      if (other.Key.Length != 0) {
        Key = other.Key;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType) input.ReadEnum();
            break;
          }
          case 18: {
            Key = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey.Types.KeyType) input.ReadEnum();
            break;
          }
          case 18: {
            Key = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the PublicKey message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Types of public keys that are supported.
      /// At a minimum, we support RSA and ECDSA, for the key sizes or curves listed:
      /// https://cloud.google.com/kms/docs/algorithms#asymmetric_signing_algorithms
      /// </summary>
      public enum KeyType {
        /// <summary>
        /// Default unspecified value.
        /// </summary>
        [pbr::OriginalName("KEY_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// A PEM-encoded PKCS#1/RFC 3447 RSAPrivateKey structure.
        /// </summary>
        [pbr::OriginalName("PEM_RSA_KEY")] PemRsaKey = 1,
        /// <summary>
        /// A PEM-encoded compressed NIST P-256/secp256r1/prime256v1 or P-384 key.
        /// </summary>
        [pbr::OriginalName("PEM_EC_KEY")] PemEcKey = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// A [CertificateConfig][google.cloud.security.privateca.v1beta1.CertificateConfig] describes an X.509 certificate or CSR that is to be
  /// created, as an alternative to using ASN.1.
  /// </summary>
  public sealed partial class CertificateConfig : pb::IMessage<CertificateConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateConfig> _parser = new pb::MessageParser<CertificateConfig>(() => new CertificateConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfig(CertificateConfig other) : this() {
      subjectConfig_ = other.subjectConfig_ != null ? other.subjectConfig_.Clone() : null;
      reusableConfig_ = other.reusableConfig_ != null ? other.reusableConfig_.Clone() : null;
      publicKey_ = other.publicKey_ != null ? other.publicKey_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfig Clone() {
      return new CertificateConfig(this);
    }

    /// <summary>Field number for the "subject_config" field.</summary>
    public const int SubjectConfigFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Types.SubjectConfig subjectConfig_;
    /// <summary>
    /// Required. Specifies some of the values in a certificate that are related to the
    /// subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Types.SubjectConfig SubjectConfig {
      get { return subjectConfig_; }
      set {
        subjectConfig_ = value;
      }
    }

    /// <summary>Field number for the "reusable_config" field.</summary>
    public const int ReusableConfigFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper reusableConfig_;
    /// <summary>
    /// Required. Describes how some of the technical fields in a certificate should be
    /// populated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper ReusableConfig {
      get { return reusableConfig_; }
      set {
        reusableConfig_ = value;
      }
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey publicKey_;
    /// <summary>
    /// Optional. The public key that corresponds to this config. This is, for example, used
    /// when issuing [Certificates][google.cloud.security.privateca.v1beta1.Certificate], but not when creating a
    /// self-signed [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] or [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] CSR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey PublicKey {
      get { return publicKey_; }
      set {
        publicKey_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SubjectConfig, other.SubjectConfig)) return false;
      if (!object.Equals(ReusableConfig, other.ReusableConfig)) return false;
      if (!object.Equals(PublicKey, other.PublicKey)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (subjectConfig_ != null) hash ^= SubjectConfig.GetHashCode();
      if (reusableConfig_ != null) hash ^= ReusableConfig.GetHashCode();
      if (publicKey_ != null) hash ^= PublicKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (subjectConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectConfig);
      }
      if (reusableConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReusableConfig);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (subjectConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectConfig);
      }
      if (reusableConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReusableConfig);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (subjectConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectConfig);
      }
      if (reusableConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReusableConfig);
      }
      if (publicKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PublicKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateConfig other) {
      if (other == null) {
        return;
      }
      if (other.subjectConfig_ != null) {
        if (subjectConfig_ == null) {
          SubjectConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Types.SubjectConfig();
        }
        SubjectConfig.MergeFrom(other.SubjectConfig);
      }
      if (other.reusableConfig_ != null) {
        if (reusableConfig_ == null) {
          ReusableConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper();
        }
        ReusableConfig.MergeFrom(other.ReusableConfig);
      }
      if (other.publicKey_ != null) {
        if (publicKey_ == null) {
          PublicKey = new global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey();
        }
        PublicKey.MergeFrom(other.PublicKey);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (subjectConfig_ == null) {
              SubjectConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Types.SubjectConfig();
            }
            input.ReadMessage(SubjectConfig);
            break;
          }
          case 18: {
            if (reusableConfig_ == null) {
              ReusableConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper();
            }
            input.ReadMessage(ReusableConfig);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (subjectConfig_ == null) {
              SubjectConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Types.SubjectConfig();
            }
            input.ReadMessage(SubjectConfig);
            break;
          }
          case 18: {
            if (reusableConfig_ == null) {
              ReusableConfig = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigWrapper();
            }
            input.ReadMessage(ReusableConfig);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// These values are used to create the distinguished name and subject
      /// alternative name fields in an X.509 certificate.
      /// </summary>
      public sealed partial class SubjectConfig : pb::IMessage<SubjectConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SubjectConfig> _parser = new pb::MessageParser<SubjectConfig>(() => new SubjectConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SubjectConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectConfig(SubjectConfig other) : this() {
          subject_ = other.subject_ != null ? other.subject_.Clone() : null;
          commonName_ = other.commonName_;
          subjectAltName_ = other.subjectAltName_ != null ? other.subjectAltName_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectConfig Clone() {
          return new SubjectConfig(this);
        }

        /// <summary>Field number for the "subject" field.</summary>
        public const int SubjectFieldNumber = 1;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject subject_;
        /// <summary>
        /// Required. Contains distinguished name fields such as the location and organization.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject Subject {
          get { return subject_; }
          set {
            subject_ = value;
          }
        }

        /// <summary>Field number for the "common_name" field.</summary>
        public const int CommonNameFieldNumber = 2;
        private string commonName_ = "";
        /// <summary>
        /// Optional. The "common name" of the distinguished name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CommonName {
          get { return commonName_; }
          set {
            commonName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "subject_alt_name" field.</summary>
        public const int SubjectAltNameFieldNumber = 3;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames subjectAltName_;
        /// <summary>
        /// Optional. The subject alternative name fields.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames SubjectAltName {
          get { return subjectAltName_; }
          set {
            subjectAltName_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SubjectConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SubjectConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Subject, other.Subject)) return false;
          if (CommonName != other.CommonName) return false;
          if (!object.Equals(SubjectAltName, other.SubjectAltName)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (subject_ != null) hash ^= Subject.GetHashCode();
          if (CommonName.Length != 0) hash ^= CommonName.GetHashCode();
          if (subjectAltName_ != null) hash ^= SubjectAltName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (CommonName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CommonName);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SubjectAltName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (CommonName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CommonName);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SubjectAltName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (subject_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Subject);
          }
          if (CommonName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CommonName);
          }
          if (subjectAltName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectAltName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SubjectConfig other) {
          if (other == null) {
            return;
          }
          if (other.subject_ != null) {
            if (subject_ == null) {
              Subject = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject();
            }
            Subject.MergeFrom(other.Subject);
          }
          if (other.CommonName.Length != 0) {
            CommonName = other.CommonName;
          }
          if (other.subjectAltName_ != null) {
            if (subjectAltName_ == null) {
              SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames();
            }
            SubjectAltName.MergeFrom(other.SubjectAltName);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                CommonName = input.ReadString();
                break;
              }
              case 26: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                CommonName = input.ReadString();
                break;
              }
              case 26: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [CertificateDescription][google.cloud.security.privateca.v1beta1.CertificateDescription] describes an X.509 certificate or CSR that has
  /// been issued, as an alternative to using ASN.1 / X.509.
  /// </summary>
  public sealed partial class CertificateDescription : pb::IMessage<CertificateDescription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateDescription> _parser = new pb::MessageParser<CertificateDescription>(() => new CertificateDescription());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateDescription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateDescription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateDescription(CertificateDescription other) : this() {
      subjectDescription_ = other.subjectDescription_ != null ? other.subjectDescription_.Clone() : null;
      configValues_ = other.configValues_ != null ? other.configValues_.Clone() : null;
      publicKey_ = other.publicKey_ != null ? other.publicKey_.Clone() : null;
      subjectKeyId_ = other.subjectKeyId_ != null ? other.subjectKeyId_.Clone() : null;
      authorityKeyId_ = other.authorityKeyId_ != null ? other.authorityKeyId_.Clone() : null;
      crlDistributionPoints_ = other.crlDistributionPoints_.Clone();
      aiaIssuingCertificateUrls_ = other.aiaIssuingCertificateUrls_.Clone();
      certFingerprint_ = other.certFingerprint_ != null ? other.certFingerprint_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateDescription Clone() {
      return new CertificateDescription(this);
    }

    /// <summary>Field number for the "subject_description" field.</summary>
    public const int SubjectDescriptionFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.SubjectDescription subjectDescription_;
    /// <summary>
    /// Describes some of the values in a certificate that are related to the
    /// subject and lifetime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.SubjectDescription SubjectDescription {
      get { return subjectDescription_; }
      set {
        subjectDescription_ = value;
      }
    }

    /// <summary>Field number for the "config_values" field.</summary>
    public const int ConfigValuesFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues configValues_;
    /// <summary>
    /// Describes some of the technical fields in a certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues ConfigValues {
      get { return configValues_; }
      set {
        configValues_ = value;
      }
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey publicKey_;
    /// <summary>
    /// The public key that corresponds to an issued certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey PublicKey {
      get { return publicKey_; }
      set {
        publicKey_ = value;
      }
    }

    /// <summary>Field number for the "subject_key_id" field.</summary>
    public const int SubjectKeyIdFieldNumber = 4;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId subjectKeyId_;
    /// <summary>
    /// Provides a means of identifiying certificates that contain a particular
    /// public key, per https://tools.ietf.org/html/rfc5280#section-4.2.1.2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId SubjectKeyId {
      get { return subjectKeyId_; }
      set {
        subjectKeyId_ = value;
      }
    }

    /// <summary>Field number for the "authority_key_id" field.</summary>
    public const int AuthorityKeyIdFieldNumber = 5;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId authorityKeyId_;
    /// <summary>
    /// Identifies the subject_key_id of the parent certificate, per
    /// https://tools.ietf.org/html/rfc5280#section-4.2.1.1
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId AuthorityKeyId {
      get { return authorityKeyId_; }
      set {
        authorityKeyId_ = value;
      }
    }

    /// <summary>Field number for the "crl_distribution_points" field.</summary>
    public const int CrlDistributionPointsFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_crlDistributionPoints_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> crlDistributionPoints_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Describes a list of locations to obtain CRL information, i.e.
    /// the DistributionPoint.fullName described by
    /// https://tools.ietf.org/html/rfc5280#section-4.2.1.13
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CrlDistributionPoints {
      get { return crlDistributionPoints_; }
    }

    /// <summary>Field number for the "aia_issuing_certificate_urls" field.</summary>
    public const int AiaIssuingCertificateUrlsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_aiaIssuingCertificateUrls_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> aiaIssuingCertificateUrls_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Describes lists of issuer CA certificate URLs that appear in the
    /// "Authority Information Access" extension in the certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AiaIssuingCertificateUrls {
      get { return aiaIssuingCertificateUrls_; }
    }

    /// <summary>Field number for the "cert_fingerprint" field.</summary>
    public const int CertFingerprintFieldNumber = 8;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.CertificateFingerprint certFingerprint_;
    /// <summary>
    /// The hash of the x.509 certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.CertificateFingerprint CertFingerprint {
      get { return certFingerprint_; }
      set {
        certFingerprint_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateDescription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateDescription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SubjectDescription, other.SubjectDescription)) return false;
      if (!object.Equals(ConfigValues, other.ConfigValues)) return false;
      if (!object.Equals(PublicKey, other.PublicKey)) return false;
      if (!object.Equals(SubjectKeyId, other.SubjectKeyId)) return false;
      if (!object.Equals(AuthorityKeyId, other.AuthorityKeyId)) return false;
      if(!crlDistributionPoints_.Equals(other.crlDistributionPoints_)) return false;
      if(!aiaIssuingCertificateUrls_.Equals(other.aiaIssuingCertificateUrls_)) return false;
      if (!object.Equals(CertFingerprint, other.CertFingerprint)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (subjectDescription_ != null) hash ^= SubjectDescription.GetHashCode();
      if (configValues_ != null) hash ^= ConfigValues.GetHashCode();
      if (publicKey_ != null) hash ^= PublicKey.GetHashCode();
      if (subjectKeyId_ != null) hash ^= SubjectKeyId.GetHashCode();
      if (authorityKeyId_ != null) hash ^= AuthorityKeyId.GetHashCode();
      hash ^= crlDistributionPoints_.GetHashCode();
      hash ^= aiaIssuingCertificateUrls_.GetHashCode();
      if (certFingerprint_ != null) hash ^= CertFingerprint.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (subjectDescription_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectDescription);
      }
      if (configValues_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ConfigValues);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (subjectKeyId_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SubjectKeyId);
      }
      if (authorityKeyId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AuthorityKeyId);
      }
      crlDistributionPoints_.WriteTo(output, _repeated_crlDistributionPoints_codec);
      aiaIssuingCertificateUrls_.WriteTo(output, _repeated_aiaIssuingCertificateUrls_codec);
      if (certFingerprint_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(CertFingerprint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (subjectDescription_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectDescription);
      }
      if (configValues_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ConfigValues);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (subjectKeyId_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SubjectKeyId);
      }
      if (authorityKeyId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AuthorityKeyId);
      }
      crlDistributionPoints_.WriteTo(ref output, _repeated_crlDistributionPoints_codec);
      aiaIssuingCertificateUrls_.WriteTo(ref output, _repeated_aiaIssuingCertificateUrls_codec);
      if (certFingerprint_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(CertFingerprint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (subjectDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectDescription);
      }
      if (configValues_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigValues);
      }
      if (publicKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PublicKey);
      }
      if (subjectKeyId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectKeyId);
      }
      if (authorityKeyId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthorityKeyId);
      }
      size += crlDistributionPoints_.CalculateSize(_repeated_crlDistributionPoints_codec);
      size += aiaIssuingCertificateUrls_.CalculateSize(_repeated_aiaIssuingCertificateUrls_codec);
      if (certFingerprint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CertFingerprint);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateDescription other) {
      if (other == null) {
        return;
      }
      if (other.subjectDescription_ != null) {
        if (subjectDescription_ == null) {
          SubjectDescription = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.SubjectDescription();
        }
        SubjectDescription.MergeFrom(other.SubjectDescription);
      }
      if (other.configValues_ != null) {
        if (configValues_ == null) {
          ConfigValues = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
        }
        ConfigValues.MergeFrom(other.ConfigValues);
      }
      if (other.publicKey_ != null) {
        if (publicKey_ == null) {
          PublicKey = new global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey();
        }
        PublicKey.MergeFrom(other.PublicKey);
      }
      if (other.subjectKeyId_ != null) {
        if (subjectKeyId_ == null) {
          SubjectKeyId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId();
        }
        SubjectKeyId.MergeFrom(other.SubjectKeyId);
      }
      if (other.authorityKeyId_ != null) {
        if (authorityKeyId_ == null) {
          AuthorityKeyId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId();
        }
        AuthorityKeyId.MergeFrom(other.AuthorityKeyId);
      }
      crlDistributionPoints_.Add(other.crlDistributionPoints_);
      aiaIssuingCertificateUrls_.Add(other.aiaIssuingCertificateUrls_);
      if (other.certFingerprint_ != null) {
        if (certFingerprint_ == null) {
          CertFingerprint = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.CertificateFingerprint();
        }
        CertFingerprint.MergeFrom(other.CertFingerprint);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (subjectDescription_ == null) {
              SubjectDescription = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.SubjectDescription();
            }
            input.ReadMessage(SubjectDescription);
            break;
          }
          case 18: {
            if (configValues_ == null) {
              ConfigValues = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
            }
            input.ReadMessage(ConfigValues);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
          case 34: {
            if (subjectKeyId_ == null) {
              SubjectKeyId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(SubjectKeyId);
            break;
          }
          case 42: {
            if (authorityKeyId_ == null) {
              AuthorityKeyId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(AuthorityKeyId);
            break;
          }
          case 50: {
            crlDistributionPoints_.AddEntriesFrom(input, _repeated_crlDistributionPoints_codec);
            break;
          }
          case 58: {
            aiaIssuingCertificateUrls_.AddEntriesFrom(input, _repeated_aiaIssuingCertificateUrls_codec);
            break;
          }
          case 66: {
            if (certFingerprint_ == null) {
              CertFingerprint = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.CertificateFingerprint();
            }
            input.ReadMessage(CertFingerprint);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (subjectDescription_ == null) {
              SubjectDescription = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.SubjectDescription();
            }
            input.ReadMessage(SubjectDescription);
            break;
          }
          case 18: {
            if (configValues_ == null) {
              ConfigValues = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ReusableConfigValues();
            }
            input.ReadMessage(ConfigValues);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1Beta1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
          case 34: {
            if (subjectKeyId_ == null) {
              SubjectKeyId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(SubjectKeyId);
            break;
          }
          case 42: {
            if (authorityKeyId_ == null) {
              AuthorityKeyId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(AuthorityKeyId);
            break;
          }
          case 50: {
            crlDistributionPoints_.AddEntriesFrom(ref input, _repeated_crlDistributionPoints_codec);
            break;
          }
          case 58: {
            aiaIssuingCertificateUrls_.AddEntriesFrom(ref input, _repeated_aiaIssuingCertificateUrls_codec);
            break;
          }
          case 66: {
            if (certFingerprint_ == null) {
              CertFingerprint = new global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Types.CertificateFingerprint();
            }
            input.ReadMessage(CertFingerprint);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateDescription message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// These values describe fields in an issued X.509 certificate such as the
      /// distinguished name, subject alternative names, serial number, and lifetime.
      /// </summary>
      public sealed partial class SubjectDescription : pb::IMessage<SubjectDescription>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SubjectDescription> _parser = new pb::MessageParser<SubjectDescription>(() => new SubjectDescription());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SubjectDescription> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectDescription() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectDescription(SubjectDescription other) : this() {
          subject_ = other.subject_ != null ? other.subject_.Clone() : null;
          commonName_ = other.commonName_;
          subjectAltName_ = other.subjectAltName_ != null ? other.subjectAltName_.Clone() : null;
          hexSerialNumber_ = other.hexSerialNumber_;
          lifetime_ = other.lifetime_ != null ? other.lifetime_.Clone() : null;
          notBeforeTime_ = other.notBeforeTime_ != null ? other.notBeforeTime_.Clone() : null;
          notAfterTime_ = other.notAfterTime_ != null ? other.notAfterTime_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectDescription Clone() {
          return new SubjectDescription(this);
        }

        /// <summary>Field number for the "subject" field.</summary>
        public const int SubjectFieldNumber = 1;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject subject_;
        /// <summary>
        /// Contains distinguished name fields such as the location and organization.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject Subject {
          get { return subject_; }
          set {
            subject_ = value;
          }
        }

        /// <summary>Field number for the "common_name" field.</summary>
        public const int CommonNameFieldNumber = 2;
        private string commonName_ = "";
        /// <summary>
        /// The "common name" of the distinguished name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CommonName {
          get { return commonName_; }
          set {
            commonName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "subject_alt_name" field.</summary>
        public const int SubjectAltNameFieldNumber = 3;
        private global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames subjectAltName_;
        /// <summary>
        /// The subject alternative name fields.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames SubjectAltName {
          get { return subjectAltName_; }
          set {
            subjectAltName_ = value;
          }
        }

        /// <summary>Field number for the "hex_serial_number" field.</summary>
        public const int HexSerialNumberFieldNumber = 4;
        private string hexSerialNumber_ = "";
        /// <summary>
        /// The serial number encoded in lowercase hexadecimal.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string HexSerialNumber {
          get { return hexSerialNumber_; }
          set {
            hexSerialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "lifetime" field.</summary>
        public const int LifetimeFieldNumber = 5;
        private global::Google.Protobuf.WellKnownTypes.Duration lifetime_;
        /// <summary>
        /// For convenience, the actual lifetime of an issued certificate.
        /// Corresponds to 'not_after_time' - 'not_before_time'.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration Lifetime {
          get { return lifetime_; }
          set {
            lifetime_ = value;
          }
        }

        /// <summary>Field number for the "not_before_time" field.</summary>
        public const int NotBeforeTimeFieldNumber = 6;
        private global::Google.Protobuf.WellKnownTypes.Timestamp notBeforeTime_;
        /// <summary>
        /// The time at which the certificate becomes valid.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp NotBeforeTime {
          get { return notBeforeTime_; }
          set {
            notBeforeTime_ = value;
          }
        }

        /// <summary>Field number for the "not_after_time" field.</summary>
        public const int NotAfterTimeFieldNumber = 7;
        private global::Google.Protobuf.WellKnownTypes.Timestamp notAfterTime_;
        /// <summary>
        /// The time at which the certificate expires.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp NotAfterTime {
          get { return notAfterTime_; }
          set {
            notAfterTime_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SubjectDescription);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SubjectDescription other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Subject, other.Subject)) return false;
          if (CommonName != other.CommonName) return false;
          if (!object.Equals(SubjectAltName, other.SubjectAltName)) return false;
          if (HexSerialNumber != other.HexSerialNumber) return false;
          if (!object.Equals(Lifetime, other.Lifetime)) return false;
          if (!object.Equals(NotBeforeTime, other.NotBeforeTime)) return false;
          if (!object.Equals(NotAfterTime, other.NotAfterTime)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (subject_ != null) hash ^= Subject.GetHashCode();
          if (CommonName.Length != 0) hash ^= CommonName.GetHashCode();
          if (subjectAltName_ != null) hash ^= SubjectAltName.GetHashCode();
          if (HexSerialNumber.Length != 0) hash ^= HexSerialNumber.GetHashCode();
          if (lifetime_ != null) hash ^= Lifetime.GetHashCode();
          if (notBeforeTime_ != null) hash ^= NotBeforeTime.GetHashCode();
          if (notAfterTime_ != null) hash ^= NotAfterTime.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (CommonName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CommonName);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SubjectAltName);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(HexSerialNumber);
          }
          if (lifetime_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(Lifetime);
          }
          if (notBeforeTime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(NotBeforeTime);
          }
          if (notAfterTime_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(NotAfterTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (CommonName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CommonName);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SubjectAltName);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(HexSerialNumber);
          }
          if (lifetime_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(Lifetime);
          }
          if (notBeforeTime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(NotBeforeTime);
          }
          if (notAfterTime_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(NotAfterTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (subject_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Subject);
          }
          if (CommonName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CommonName);
          }
          if (subjectAltName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectAltName);
          }
          if (HexSerialNumber.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(HexSerialNumber);
          }
          if (lifetime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifetime);
          }
          if (notBeforeTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotBeforeTime);
          }
          if (notAfterTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotAfterTime);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SubjectDescription other) {
          if (other == null) {
            return;
          }
          if (other.subject_ != null) {
            if (subject_ == null) {
              Subject = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject();
            }
            Subject.MergeFrom(other.Subject);
          }
          if (other.CommonName.Length != 0) {
            CommonName = other.CommonName;
          }
          if (other.subjectAltName_ != null) {
            if (subjectAltName_ == null) {
              SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames();
            }
            SubjectAltName.MergeFrom(other.SubjectAltName);
          }
          if (other.HexSerialNumber.Length != 0) {
            HexSerialNumber = other.HexSerialNumber;
          }
          if (other.lifetime_ != null) {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            Lifetime.MergeFrom(other.Lifetime);
          }
          if (other.notBeforeTime_ != null) {
            if (notBeforeTime_ == null) {
              NotBeforeTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            NotBeforeTime.MergeFrom(other.NotBeforeTime);
          }
          if (other.notAfterTime_ != null) {
            if (notAfterTime_ == null) {
              NotAfterTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            NotAfterTime.MergeFrom(other.NotAfterTime);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                CommonName = input.ReadString();
                break;
              }
              case 26: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
              case 34: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 42: {
                if (lifetime_ == null) {
                  Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Lifetime);
                break;
              }
              case 50: {
                if (notBeforeTime_ == null) {
                  NotBeforeTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotBeforeTime);
                break;
              }
              case 58: {
                if (notAfterTime_ == null) {
                  NotAfterTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotAfterTime);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1Beta1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                CommonName = input.ReadString();
                break;
              }
              case 26: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1Beta1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
              case 34: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 42: {
                if (lifetime_ == null) {
                  Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Lifetime);
                break;
              }
              case 50: {
                if (notBeforeTime_ == null) {
                  NotBeforeTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotBeforeTime);
                break;
              }
              case 58: {
                if (notAfterTime_ == null) {
                  NotAfterTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotAfterTime);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A KeyId identifies a specific public key, usually by hashing the public
      /// key.
      /// </summary>
      public sealed partial class KeyId : pb::IMessage<KeyId>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyId> _parser = new pb::MessageParser<KeyId>(() => new KeyId());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<KeyId> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyId() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyId(KeyId other) : this() {
          keyId_ = other.keyId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyId Clone() {
          return new KeyId(this);
        }

        /// <summary>Field number for the "key_id" field.</summary>
        public const int KeyId_FieldNumber = 1;
        private string keyId_ = "";
        /// <summary>
        /// Optional. The value of this KeyId encoded in lowercase hexadecimal. This is most
        /// likely the 160 bit SHA-1 hash of the public key.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string KeyId_ {
          get { return keyId_; }
          set {
            keyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as KeyId);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(KeyId other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (KeyId_ != other.KeyId_) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (KeyId_.Length != 0) hash ^= KeyId_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (KeyId_.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(KeyId_);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (KeyId_.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(KeyId_);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (KeyId_.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(KeyId_);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(KeyId other) {
          if (other == null) {
            return;
          }
          if (other.KeyId_.Length != 0) {
            KeyId_ = other.KeyId_;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                KeyId_ = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                KeyId_ = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A group of fingerprints for the x509 certificate.
      /// </summary>
      public sealed partial class CertificateFingerprint : pb::IMessage<CertificateFingerprint>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CertificateFingerprint> _parser = new pb::MessageParser<CertificateFingerprint>(() => new CertificateFingerprint());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CertificateFingerprint> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.CertificateDescription.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateFingerprint() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateFingerprint(CertificateFingerprint other) : this() {
          sha256Hash_ = other.sha256Hash_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateFingerprint Clone() {
          return new CertificateFingerprint(this);
        }

        /// <summary>Field number for the "sha256_hash" field.</summary>
        public const int Sha256HashFieldNumber = 1;
        private string sha256Hash_ = "";
        /// <summary>
        /// The SHA 256 hash, encoded in hexadecimal, of the DER x509 certificate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Sha256Hash {
          get { return sha256Hash_; }
          set {
            sha256Hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CertificateFingerprint);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CertificateFingerprint other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Sha256Hash != other.Sha256Hash) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Sha256Hash.Length != 0) hash ^= Sha256Hash.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Sha256Hash.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Sha256Hash);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Sha256Hash.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Sha256Hash);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Sha256Hash.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Sha256Hash);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CertificateFingerprint other) {
          if (other == null) {
            return;
          }
          if (other.Sha256Hash.Length != 0) {
            Sha256Hash = other.Sha256Hash;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Sha256Hash = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Sha256Hash = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// An [ObjectId][google.cloud.security.privateca.v1beta1.ObjectId] specifies an object identifier (OID). These provide context
  /// and describe types in ASN.1 messages.
  /// </summary>
  public sealed partial class ObjectId : pb::IMessage<ObjectId>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ObjectId> _parser = new pb::MessageParser<ObjectId>(() => new ObjectId());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ObjectId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectId(ObjectId other) : this() {
      objectIdPath_ = other.objectIdPath_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectId Clone() {
      return new ObjectId(this);
    }

    /// <summary>Field number for the "object_id_path" field.</summary>
    public const int ObjectIdPathFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_objectIdPath_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> objectIdPath_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Required. The parts of an OID path. The most significant parts of the path come
    /// first.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> ObjectIdPath {
      get { return objectIdPath_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ObjectId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ObjectId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!objectIdPath_.Equals(other.objectIdPath_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= objectIdPath_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      objectIdPath_.WriteTo(output, _repeated_objectIdPath_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      objectIdPath_.WriteTo(ref output, _repeated_objectIdPath_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += objectIdPath_.CalculateSize(_repeated_objectIdPath_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ObjectId other) {
      if (other == null) {
        return;
      }
      objectIdPath_.Add(other.objectIdPath_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            objectIdPath_.AddEntriesFrom(input, _repeated_objectIdPath_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            objectIdPath_.AddEntriesFrom(ref input, _repeated_objectIdPath_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// An [X509Extension][google.cloud.security.privateca.v1beta1.X509Extension] specifies an X.509 extension, which may be used in
  /// different parts of X.509 objects like certificates, CSRs, and CRLs.
  /// </summary>
  public sealed partial class X509Extension : pb::IMessage<X509Extension>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<X509Extension> _parser = new pb::MessageParser<X509Extension>(() => new X509Extension());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<X509Extension> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Extension() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Extension(X509Extension other) : this() {
      objectId_ = other.objectId_ != null ? other.objectId_.Clone() : null;
      critical_ = other.critical_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Extension Clone() {
      return new X509Extension(this);
    }

    /// <summary>Field number for the "object_id" field.</summary>
    public const int ObjectIdFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId objectId_;
    /// <summary>
    /// Required. The OID for this X.509 extension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId ObjectId {
      get { return objectId_; }
      set {
        objectId_ = value;
      }
    }

    /// <summary>Field number for the "critical" field.</summary>
    public const int CriticalFieldNumber = 2;
    private bool critical_;
    /// <summary>
    /// Required. Indicates whether or not this extension is critical (i.e., if the client
    /// does not know how to handle this extension, the client should consider this
    /// to be an error).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Critical {
      get { return critical_; }
      set {
        critical_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 3;
    private pb::ByteString value_ = pb::ByteString.Empty;
    /// <summary>
    /// Required. The value of this X.509 extension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as X509Extension);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(X509Extension other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ObjectId, other.ObjectId)) return false;
      if (Critical != other.Critical) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (objectId_ != null) hash ^= ObjectId.GetHashCode();
      if (Critical != false) hash ^= Critical.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (objectId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ObjectId);
      }
      if (Critical != false) {
        output.WriteRawTag(16);
        output.WriteBool(Critical);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (objectId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ObjectId);
      }
      if (Critical != false) {
        output.WriteRawTag(16);
        output.WriteBool(Critical);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (objectId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ObjectId);
      }
      if (Critical != false) {
        size += 1 + 1;
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(X509Extension other) {
      if (other == null) {
        return;
      }
      if (other.objectId_ != null) {
        if (objectId_ == null) {
          ObjectId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId();
        }
        ObjectId.MergeFrom(other.ObjectId);
      }
      if (other.Critical != false) {
        Critical = other.Critical;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (objectId_ == null) {
              ObjectId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId();
            }
            input.ReadMessage(ObjectId);
            break;
          }
          case 16: {
            Critical = input.ReadBool();
            break;
          }
          case 26: {
            Value = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (objectId_ == null) {
              ObjectId = new global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId();
            }
            input.ReadMessage(ObjectId);
            break;
          }
          case 16: {
            Critical = input.ReadBool();
            break;
          }
          case 26: {
            Value = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A [KeyUsage][google.cloud.security.privateca.v1beta1.KeyUsage] describes key usage values that may appear in an X.509
  /// certificate.
  /// </summary>
  public sealed partial class KeyUsage : pb::IMessage<KeyUsage>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyUsage> _parser = new pb::MessageParser<KeyUsage>(() => new KeyUsage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KeyUsage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeyUsage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeyUsage(KeyUsage other) : this() {
      baseKeyUsage_ = other.baseKeyUsage_ != null ? other.baseKeyUsage_.Clone() : null;
      extendedKeyUsage_ = other.extendedKeyUsage_ != null ? other.extendedKeyUsage_.Clone() : null;
      unknownExtendedKeyUsages_ = other.unknownExtendedKeyUsages_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeyUsage Clone() {
      return new KeyUsage(this);
    }

    /// <summary>Field number for the "base_key_usage" field.</summary>
    public const int BaseKeyUsageFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.KeyUsageOptions baseKeyUsage_;
    /// <summary>
    /// Describes high-level ways in which a key may be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.KeyUsageOptions BaseKeyUsage {
      get { return baseKeyUsage_; }
      set {
        baseKeyUsage_ = value;
      }
    }

    /// <summary>Field number for the "extended_key_usage" field.</summary>
    public const int ExtendedKeyUsageFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.ExtendedKeyUsageOptions extendedKeyUsage_;
    /// <summary>
    /// Detailed scenarios in which a key may be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.ExtendedKeyUsageOptions ExtendedKeyUsage {
      get { return extendedKeyUsage_; }
      set {
        extendedKeyUsage_ = value;
      }
    }

    /// <summary>Field number for the "unknown_extended_key_usages" field.</summary>
    public const int UnknownExtendedKeyUsagesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId> _repeated_unknownExtendedKeyUsages_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId> unknownExtendedKeyUsages_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId>();
    /// <summary>
    /// Used to describe extended key usages that are not listed in the
    /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.ExtendedKeyUsageOptions] message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.ObjectId> UnknownExtendedKeyUsages {
      get { return unknownExtendedKeyUsages_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KeyUsage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KeyUsage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(BaseKeyUsage, other.BaseKeyUsage)) return false;
      if (!object.Equals(ExtendedKeyUsage, other.ExtendedKeyUsage)) return false;
      if(!unknownExtendedKeyUsages_.Equals(other.unknownExtendedKeyUsages_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (baseKeyUsage_ != null) hash ^= BaseKeyUsage.GetHashCode();
      if (extendedKeyUsage_ != null) hash ^= ExtendedKeyUsage.GetHashCode();
      hash ^= unknownExtendedKeyUsages_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (baseKeyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(BaseKeyUsage);
      }
      if (extendedKeyUsage_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExtendedKeyUsage);
      }
      unknownExtendedKeyUsages_.WriteTo(output, _repeated_unknownExtendedKeyUsages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (baseKeyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(BaseKeyUsage);
      }
      if (extendedKeyUsage_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExtendedKeyUsage);
      }
      unknownExtendedKeyUsages_.WriteTo(ref output, _repeated_unknownExtendedKeyUsages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (baseKeyUsage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseKeyUsage);
      }
      if (extendedKeyUsage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExtendedKeyUsage);
      }
      size += unknownExtendedKeyUsages_.CalculateSize(_repeated_unknownExtendedKeyUsages_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KeyUsage other) {
      if (other == null) {
        return;
      }
      if (other.baseKeyUsage_ != null) {
        if (baseKeyUsage_ == null) {
          BaseKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.KeyUsageOptions();
        }
        BaseKeyUsage.MergeFrom(other.BaseKeyUsage);
      }
      if (other.extendedKeyUsage_ != null) {
        if (extendedKeyUsage_ == null) {
          ExtendedKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.ExtendedKeyUsageOptions();
        }
        ExtendedKeyUsage.MergeFrom(other.ExtendedKeyUsage);
      }
      unknownExtendedKeyUsages_.Add(other.unknownExtendedKeyUsages_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (baseKeyUsage_ == null) {
              BaseKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.KeyUsageOptions();
            }
            input.ReadMessage(BaseKeyUsage);
            break;
          }
          case 18: {
            if (extendedKeyUsage_ == null) {
              ExtendedKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.ExtendedKeyUsageOptions();
            }
            input.ReadMessage(ExtendedKeyUsage);
            break;
          }
          case 26: {
            unknownExtendedKeyUsages_.AddEntriesFrom(input, _repeated_unknownExtendedKeyUsages_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (baseKeyUsage_ == null) {
              BaseKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.KeyUsageOptions();
            }
            input.ReadMessage(BaseKeyUsage);
            break;
          }
          case 18: {
            if (extendedKeyUsage_ == null) {
              ExtendedKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Types.ExtendedKeyUsageOptions();
            }
            input.ReadMessage(ExtendedKeyUsage);
            break;
          }
          case 26: {
            unknownExtendedKeyUsages_.AddEntriesFrom(ref input, _repeated_unknownExtendedKeyUsages_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the KeyUsage message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// [KeyUsage.KeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.KeyUsageOptions] corresponds to the key usage values
      /// described in https://tools.ietf.org/html/rfc5280#section-4.2.1.3.
      /// </summary>
      public sealed partial class KeyUsageOptions : pb::IMessage<KeyUsageOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyUsageOptions> _parser = new pb::MessageParser<KeyUsageOptions>(() => new KeyUsageOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<KeyUsageOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyUsageOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyUsageOptions(KeyUsageOptions other) : this() {
          digitalSignature_ = other.digitalSignature_;
          contentCommitment_ = other.contentCommitment_;
          keyEncipherment_ = other.keyEncipherment_;
          dataEncipherment_ = other.dataEncipherment_;
          keyAgreement_ = other.keyAgreement_;
          certSign_ = other.certSign_;
          crlSign_ = other.crlSign_;
          encipherOnly_ = other.encipherOnly_;
          decipherOnly_ = other.decipherOnly_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyUsageOptions Clone() {
          return new KeyUsageOptions(this);
        }

        /// <summary>Field number for the "digital_signature" field.</summary>
        public const int DigitalSignatureFieldNumber = 1;
        private bool digitalSignature_;
        /// <summary>
        /// The key may be used for digital signatures.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DigitalSignature {
          get { return digitalSignature_; }
          set {
            digitalSignature_ = value;
          }
        }

        /// <summary>Field number for the "content_commitment" field.</summary>
        public const int ContentCommitmentFieldNumber = 2;
        private bool contentCommitment_;
        /// <summary>
        /// The key may be used for cryptographic commitments. Note that this may
        /// also be referred to as "non-repudiation".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ContentCommitment {
          get { return contentCommitment_; }
          set {
            contentCommitment_ = value;
          }
        }

        /// <summary>Field number for the "key_encipherment" field.</summary>
        public const int KeyEnciphermentFieldNumber = 3;
        private bool keyEncipherment_;
        /// <summary>
        /// The key may be used to encipher other keys.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool KeyEncipherment {
          get { return keyEncipherment_; }
          set {
            keyEncipherment_ = value;
          }
        }

        /// <summary>Field number for the "data_encipherment" field.</summary>
        public const int DataEnciphermentFieldNumber = 4;
        private bool dataEncipherment_;
        /// <summary>
        /// The key may be used to encipher data.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DataEncipherment {
          get { return dataEncipherment_; }
          set {
            dataEncipherment_ = value;
          }
        }

        /// <summary>Field number for the "key_agreement" field.</summary>
        public const int KeyAgreementFieldNumber = 5;
        private bool keyAgreement_;
        /// <summary>
        /// The key may be used in a key agreement protocol.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool KeyAgreement {
          get { return keyAgreement_; }
          set {
            keyAgreement_ = value;
          }
        }

        /// <summary>Field number for the "cert_sign" field.</summary>
        public const int CertSignFieldNumber = 6;
        private bool certSign_;
        /// <summary>
        /// The key may be used to sign certificates.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CertSign {
          get { return certSign_; }
          set {
            certSign_ = value;
          }
        }

        /// <summary>Field number for the "crl_sign" field.</summary>
        public const int CrlSignFieldNumber = 7;
        private bool crlSign_;
        /// <summary>
        /// The key may be used sign certificate revocation lists.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CrlSign {
          get { return crlSign_; }
          set {
            crlSign_ = value;
          }
        }

        /// <summary>Field number for the "encipher_only" field.</summary>
        public const int EncipherOnlyFieldNumber = 8;
        private bool encipherOnly_;
        /// <summary>
        /// The key may be used to encipher only.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool EncipherOnly {
          get { return encipherOnly_; }
          set {
            encipherOnly_ = value;
          }
        }

        /// <summary>Field number for the "decipher_only" field.</summary>
        public const int DecipherOnlyFieldNumber = 9;
        private bool decipherOnly_;
        /// <summary>
        /// The key may be used to decipher only.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DecipherOnly {
          get { return decipherOnly_; }
          set {
            decipherOnly_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as KeyUsageOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(KeyUsageOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DigitalSignature != other.DigitalSignature) return false;
          if (ContentCommitment != other.ContentCommitment) return false;
          if (KeyEncipherment != other.KeyEncipherment) return false;
          if (DataEncipherment != other.DataEncipherment) return false;
          if (KeyAgreement != other.KeyAgreement) return false;
          if (CertSign != other.CertSign) return false;
          if (CrlSign != other.CrlSign) return false;
          if (EncipherOnly != other.EncipherOnly) return false;
          if (DecipherOnly != other.DecipherOnly) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (DigitalSignature != false) hash ^= DigitalSignature.GetHashCode();
          if (ContentCommitment != false) hash ^= ContentCommitment.GetHashCode();
          if (KeyEncipherment != false) hash ^= KeyEncipherment.GetHashCode();
          if (DataEncipherment != false) hash ^= DataEncipherment.GetHashCode();
          if (KeyAgreement != false) hash ^= KeyAgreement.GetHashCode();
          if (CertSign != false) hash ^= CertSign.GetHashCode();
          if (CrlSign != false) hash ^= CrlSign.GetHashCode();
          if (EncipherOnly != false) hash ^= EncipherOnly.GetHashCode();
          if (DecipherOnly != false) hash ^= DecipherOnly.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (DigitalSignature != false) {
            output.WriteRawTag(8);
            output.WriteBool(DigitalSignature);
          }
          if (ContentCommitment != false) {
            output.WriteRawTag(16);
            output.WriteBool(ContentCommitment);
          }
          if (KeyEncipherment != false) {
            output.WriteRawTag(24);
            output.WriteBool(KeyEncipherment);
          }
          if (DataEncipherment != false) {
            output.WriteRawTag(32);
            output.WriteBool(DataEncipherment);
          }
          if (KeyAgreement != false) {
            output.WriteRawTag(40);
            output.WriteBool(KeyAgreement);
          }
          if (CertSign != false) {
            output.WriteRawTag(48);
            output.WriteBool(CertSign);
          }
          if (CrlSign != false) {
            output.WriteRawTag(56);
            output.WriteBool(CrlSign);
          }
          if (EncipherOnly != false) {
            output.WriteRawTag(64);
            output.WriteBool(EncipherOnly);
          }
          if (DecipherOnly != false) {
            output.WriteRawTag(72);
            output.WriteBool(DecipherOnly);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (DigitalSignature != false) {
            output.WriteRawTag(8);
            output.WriteBool(DigitalSignature);
          }
          if (ContentCommitment != false) {
            output.WriteRawTag(16);
            output.WriteBool(ContentCommitment);
          }
          if (KeyEncipherment != false) {
            output.WriteRawTag(24);
            output.WriteBool(KeyEncipherment);
          }
          if (DataEncipherment != false) {
            output.WriteRawTag(32);
            output.WriteBool(DataEncipherment);
          }
          if (KeyAgreement != false) {
            output.WriteRawTag(40);
            output.WriteBool(KeyAgreement);
          }
          if (CertSign != false) {
            output.WriteRawTag(48);
            output.WriteBool(CertSign);
          }
          if (CrlSign != false) {
            output.WriteRawTag(56);
            output.WriteBool(CrlSign);
          }
          if (EncipherOnly != false) {
            output.WriteRawTag(64);
            output.WriteBool(EncipherOnly);
          }
          if (DecipherOnly != false) {
            output.WriteRawTag(72);
            output.WriteBool(DecipherOnly);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (DigitalSignature != false) {
            size += 1 + 1;
          }
          if (ContentCommitment != false) {
            size += 1 + 1;
          }
          if (KeyEncipherment != false) {
            size += 1 + 1;
          }
          if (DataEncipherment != false) {
            size += 1 + 1;
          }
          if (KeyAgreement != false) {
            size += 1 + 1;
          }
          if (CertSign != false) {
            size += 1 + 1;
          }
          if (CrlSign != false) {
            size += 1 + 1;
          }
          if (EncipherOnly != false) {
            size += 1 + 1;
          }
          if (DecipherOnly != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(KeyUsageOptions other) {
          if (other == null) {
            return;
          }
          if (other.DigitalSignature != false) {
            DigitalSignature = other.DigitalSignature;
          }
          if (other.ContentCommitment != false) {
            ContentCommitment = other.ContentCommitment;
          }
          if (other.KeyEncipherment != false) {
            KeyEncipherment = other.KeyEncipherment;
          }
          if (other.DataEncipherment != false) {
            DataEncipherment = other.DataEncipherment;
          }
          if (other.KeyAgreement != false) {
            KeyAgreement = other.KeyAgreement;
          }
          if (other.CertSign != false) {
            CertSign = other.CertSign;
          }
          if (other.CrlSign != false) {
            CrlSign = other.CrlSign;
          }
          if (other.EncipherOnly != false) {
            EncipherOnly = other.EncipherOnly;
          }
          if (other.DecipherOnly != false) {
            DecipherOnly = other.DecipherOnly;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DigitalSignature = input.ReadBool();
                break;
              }
              case 16: {
                ContentCommitment = input.ReadBool();
                break;
              }
              case 24: {
                KeyEncipherment = input.ReadBool();
                break;
              }
              case 32: {
                DataEncipherment = input.ReadBool();
                break;
              }
              case 40: {
                KeyAgreement = input.ReadBool();
                break;
              }
              case 48: {
                CertSign = input.ReadBool();
                break;
              }
              case 56: {
                CrlSign = input.ReadBool();
                break;
              }
              case 64: {
                EncipherOnly = input.ReadBool();
                break;
              }
              case 72: {
                DecipherOnly = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                DigitalSignature = input.ReadBool();
                break;
              }
              case 16: {
                ContentCommitment = input.ReadBool();
                break;
              }
              case 24: {
                KeyEncipherment = input.ReadBool();
                break;
              }
              case 32: {
                DataEncipherment = input.ReadBool();
                break;
              }
              case 40: {
                KeyAgreement = input.ReadBool();
                break;
              }
              case 48: {
                CertSign = input.ReadBool();
                break;
              }
              case 56: {
                CrlSign = input.ReadBool();
                break;
              }
              case 64: {
                EncipherOnly = input.ReadBool();
                break;
              }
              case 72: {
                DecipherOnly = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.ExtendedKeyUsageOptions] has fields that correspond to
      /// certain common OIDs that could be specified as an extended key usage value.
      /// </summary>
      public sealed partial class ExtendedKeyUsageOptions : pb::IMessage<ExtendedKeyUsageOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ExtendedKeyUsageOptions> _parser = new pb::MessageParser<ExtendedKeyUsageOptions>(() => new ExtendedKeyUsageOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ExtendedKeyUsageOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.KeyUsage.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExtendedKeyUsageOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExtendedKeyUsageOptions(ExtendedKeyUsageOptions other) : this() {
          serverAuth_ = other.serverAuth_;
          clientAuth_ = other.clientAuth_;
          codeSigning_ = other.codeSigning_;
          emailProtection_ = other.emailProtection_;
          timeStamping_ = other.timeStamping_;
          ocspSigning_ = other.ocspSigning_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExtendedKeyUsageOptions Clone() {
          return new ExtendedKeyUsageOptions(this);
        }

        /// <summary>Field number for the "server_auth" field.</summary>
        public const int ServerAuthFieldNumber = 1;
        private bool serverAuth_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW
        /// server authentication", though regularly used for non-WWW TLS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ServerAuth {
          get { return serverAuth_; }
          set {
            serverAuth_ = value;
          }
        }

        /// <summary>Field number for the "client_auth" field.</summary>
        public const int ClientAuthFieldNumber = 2;
        private bool clientAuth_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW
        /// client authentication", though regularly used for non-WWW TLS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ClientAuth {
          get { return clientAuth_; }
          set {
            clientAuth_ = value;
          }
        }

        /// <summary>Field number for the "code_signing" field.</summary>
        public const int CodeSigningFieldNumber = 3;
        private bool codeSigning_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of
        /// downloadable executable code client authentication".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CodeSigning {
          get { return codeSigning_; }
          set {
            codeSigning_ = value;
          }
        }

        /// <summary>Field number for the "email_protection" field.</summary>
        public const int EmailProtectionFieldNumber = 4;
        private bool emailProtection_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email
        /// protection".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool EmailProtection {
          get { return emailProtection_; }
          set {
            emailProtection_ = value;
          }
        }

        /// <summary>Field number for the "time_stamping" field.</summary>
        public const int TimeStampingFieldNumber = 5;
        private bool timeStamping_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding
        /// the hash of an object to a time".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool TimeStamping {
          get { return timeStamping_; }
          set {
            timeStamping_ = value;
          }
        }

        /// <summary>Field number for the "ocsp_signing" field.</summary>
        public const int OcspSigningFieldNumber = 6;
        private bool ocspSigning_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing
        /// OCSP responses".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool OcspSigning {
          get { return ocspSigning_; }
          set {
            ocspSigning_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ExtendedKeyUsageOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ExtendedKeyUsageOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ServerAuth != other.ServerAuth) return false;
          if (ClientAuth != other.ClientAuth) return false;
          if (CodeSigning != other.CodeSigning) return false;
          if (EmailProtection != other.EmailProtection) return false;
          if (TimeStamping != other.TimeStamping) return false;
          if (OcspSigning != other.OcspSigning) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ServerAuth != false) hash ^= ServerAuth.GetHashCode();
          if (ClientAuth != false) hash ^= ClientAuth.GetHashCode();
          if (CodeSigning != false) hash ^= CodeSigning.GetHashCode();
          if (EmailProtection != false) hash ^= EmailProtection.GetHashCode();
          if (TimeStamping != false) hash ^= TimeStamping.GetHashCode();
          if (OcspSigning != false) hash ^= OcspSigning.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (ServerAuth != false) {
            output.WriteRawTag(8);
            output.WriteBool(ServerAuth);
          }
          if (ClientAuth != false) {
            output.WriteRawTag(16);
            output.WriteBool(ClientAuth);
          }
          if (CodeSigning != false) {
            output.WriteRawTag(24);
            output.WriteBool(CodeSigning);
          }
          if (EmailProtection != false) {
            output.WriteRawTag(32);
            output.WriteBool(EmailProtection);
          }
          if (TimeStamping != false) {
            output.WriteRawTag(40);
            output.WriteBool(TimeStamping);
          }
          if (OcspSigning != false) {
            output.WriteRawTag(48);
            output.WriteBool(OcspSigning);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (ServerAuth != false) {
            output.WriteRawTag(8);
            output.WriteBool(ServerAuth);
          }
          if (ClientAuth != false) {
            output.WriteRawTag(16);
            output.WriteBool(ClientAuth);
          }
          if (CodeSigning != false) {
            output.WriteRawTag(24);
            output.WriteBool(CodeSigning);
          }
          if (EmailProtection != false) {
            output.WriteRawTag(32);
            output.WriteBool(EmailProtection);
          }
          if (TimeStamping != false) {
            output.WriteRawTag(40);
            output.WriteBool(TimeStamping);
          }
          if (OcspSigning != false) {
            output.WriteRawTag(48);
            output.WriteBool(OcspSigning);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ServerAuth != false) {
            size += 1 + 1;
          }
          if (ClientAuth != false) {
            size += 1 + 1;
          }
          if (CodeSigning != false) {
            size += 1 + 1;
          }
          if (EmailProtection != false) {
            size += 1 + 1;
          }
          if (TimeStamping != false) {
            size += 1 + 1;
          }
          if (OcspSigning != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ExtendedKeyUsageOptions other) {
          if (other == null) {
            return;
          }
          if (other.ServerAuth != false) {
            ServerAuth = other.ServerAuth;
          }
          if (other.ClientAuth != false) {
            ClientAuth = other.ClientAuth;
          }
          if (other.CodeSigning != false) {
            CodeSigning = other.CodeSigning;
          }
          if (other.EmailProtection != false) {
            EmailProtection = other.EmailProtection;
          }
          if (other.TimeStamping != false) {
            TimeStamping = other.TimeStamping;
          }
          if (other.OcspSigning != false) {
            OcspSigning = other.OcspSigning;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ServerAuth = input.ReadBool();
                break;
              }
              case 16: {
                ClientAuth = input.ReadBool();
                break;
              }
              case 24: {
                CodeSigning = input.ReadBool();
                break;
              }
              case 32: {
                EmailProtection = input.ReadBool();
                break;
              }
              case 40: {
                TimeStamping = input.ReadBool();
                break;
              }
              case 48: {
                OcspSigning = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ServerAuth = input.ReadBool();
                break;
              }
              case 16: {
                ClientAuth = input.ReadBool();
                break;
              }
              case 24: {
                CodeSigning = input.ReadBool();
                break;
              }
              case 32: {
                EmailProtection = input.ReadBool();
                break;
              }
              case 40: {
                TimeStamping = input.ReadBool();
                break;
              }
              case 48: {
                OcspSigning = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// [Subject][google.cloud.security.privateca.v1beta1.Subject] describes parts of a distinguished name that, in turn,
  /// describes the subject of the certificate.
  /// </summary>
  public sealed partial class Subject : pb::IMessage<Subject>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Subject> _parser = new pb::MessageParser<Subject>(() => new Subject());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Subject> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Subject() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Subject(Subject other) : this() {
      countryCode_ = other.countryCode_;
      organization_ = other.organization_;
      organizationalUnit_ = other.organizationalUnit_;
      locality_ = other.locality_;
      province_ = other.province_;
      streetAddress_ = other.streetAddress_;
      postalCode_ = other.postalCode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Subject Clone() {
      return new Subject(this);
    }

    /// <summary>Field number for the "country_code" field.</summary>
    public const int CountryCodeFieldNumber = 1;
    private string countryCode_ = "";
    /// <summary>
    /// The country code of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CountryCode {
      get { return countryCode_; }
      set {
        countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "organization" field.</summary>
    public const int OrganizationFieldNumber = 2;
    private string organization_ = "";
    /// <summary>
    /// The organization of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Organization {
      get { return organization_; }
      set {
        organization_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "organizational_unit" field.</summary>
    public const int OrganizationalUnitFieldNumber = 3;
    private string organizationalUnit_ = "";
    /// <summary>
    /// The organizational_unit of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OrganizationalUnit {
      get { return organizationalUnit_; }
      set {
        organizationalUnit_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "locality" field.</summary>
    public const int LocalityFieldNumber = 4;
    private string locality_ = "";
    /// <summary>
    /// The locality or city of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Locality {
      get { return locality_; }
      set {
        locality_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "province" field.</summary>
    public const int ProvinceFieldNumber = 5;
    private string province_ = "";
    /// <summary>
    /// The province, territory, or regional state of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Province {
      get { return province_; }
      set {
        province_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "street_address" field.</summary>
    public const int StreetAddressFieldNumber = 6;
    private string streetAddress_ = "";
    /// <summary>
    /// The street address of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StreetAddress {
      get { return streetAddress_; }
      set {
        streetAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "postal_code" field.</summary>
    public const int PostalCodeFieldNumber = 7;
    private string postalCode_ = "";
    /// <summary>
    /// The postal code of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PostalCode {
      get { return postalCode_; }
      set {
        postalCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Subject);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Subject other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CountryCode != other.CountryCode) return false;
      if (Organization != other.Organization) return false;
      if (OrganizationalUnit != other.OrganizationalUnit) return false;
      if (Locality != other.Locality) return false;
      if (Province != other.Province) return false;
      if (StreetAddress != other.StreetAddress) return false;
      if (PostalCode != other.PostalCode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CountryCode.Length != 0) hash ^= CountryCode.GetHashCode();
      if (Organization.Length != 0) hash ^= Organization.GetHashCode();
      if (OrganizationalUnit.Length != 0) hash ^= OrganizationalUnit.GetHashCode();
      if (Locality.Length != 0) hash ^= Locality.GetHashCode();
      if (Province.Length != 0) hash ^= Province.GetHashCode();
      if (StreetAddress.Length != 0) hash ^= StreetAddress.GetHashCode();
      if (PostalCode.Length != 0) hash ^= PostalCode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CountryCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CountryCode);
      }
      if (Organization.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Organization);
      }
      if (OrganizationalUnit.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(OrganizationalUnit);
      }
      if (Locality.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Locality);
      }
      if (Province.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Province);
      }
      if (StreetAddress.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(StreetAddress);
      }
      if (PostalCode.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(PostalCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CountryCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CountryCode);
      }
      if (Organization.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Organization);
      }
      if (OrganizationalUnit.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(OrganizationalUnit);
      }
      if (Locality.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Locality);
      }
      if (Province.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Province);
      }
      if (StreetAddress.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(StreetAddress);
      }
      if (PostalCode.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(PostalCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CountryCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryCode);
      }
      if (Organization.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Organization);
      }
      if (OrganizationalUnit.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OrganizationalUnit);
      }
      if (Locality.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Locality);
      }
      if (Province.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Province);
      }
      if (StreetAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StreetAddress);
      }
      if (PostalCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PostalCode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Subject other) {
      if (other == null) {
        return;
      }
      if (other.CountryCode.Length != 0) {
        CountryCode = other.CountryCode;
      }
      if (other.Organization.Length != 0) {
        Organization = other.Organization;
      }
      if (other.OrganizationalUnit.Length != 0) {
        OrganizationalUnit = other.OrganizationalUnit;
      }
      if (other.Locality.Length != 0) {
        Locality = other.Locality;
      }
      if (other.Province.Length != 0) {
        Province = other.Province;
      }
      if (other.StreetAddress.Length != 0) {
        StreetAddress = other.StreetAddress;
      }
      if (other.PostalCode.Length != 0) {
        PostalCode = other.PostalCode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CountryCode = input.ReadString();
            break;
          }
          case 18: {
            Organization = input.ReadString();
            break;
          }
          case 26: {
            OrganizationalUnit = input.ReadString();
            break;
          }
          case 34: {
            Locality = input.ReadString();
            break;
          }
          case 42: {
            Province = input.ReadString();
            break;
          }
          case 50: {
            StreetAddress = input.ReadString();
            break;
          }
          case 58: {
            PostalCode = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CountryCode = input.ReadString();
            break;
          }
          case 18: {
            Organization = input.ReadString();
            break;
          }
          case 26: {
            OrganizationalUnit = input.ReadString();
            break;
          }
          case 34: {
            Locality = input.ReadString();
            break;
          }
          case 42: {
            Province = input.ReadString();
            break;
          }
          case 50: {
            StreetAddress = input.ReadString();
            break;
          }
          case 58: {
            PostalCode = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames] corresponds to a more modern way of listing what
  /// the asserted identity is in a certificate (i.e., compared to the "common
  /// name" in the distinguished name).
  /// </summary>
  public sealed partial class SubjectAltNames : pb::IMessage<SubjectAltNames>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SubjectAltNames> _parser = new pb::MessageParser<SubjectAltNames>(() => new SubjectAltNames());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SubjectAltNames> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1Beta1.ResourcesReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubjectAltNames() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubjectAltNames(SubjectAltNames other) : this() {
      dnsNames_ = other.dnsNames_.Clone();
      uris_ = other.uris_.Clone();
      emailAddresses_ = other.emailAddresses_.Clone();
      ipAddresses_ = other.ipAddresses_.Clone();
      customSans_ = other.customSans_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubjectAltNames Clone() {
      return new SubjectAltNames(this);
    }

    /// <summary>Field number for the "dns_names" field.</summary>
    public const int DnsNamesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_dnsNames_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> dnsNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid, fully-qualified host names.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> DnsNames {
      get { return dnsNames_; }
    }

    /// <summary>Field number for the "uris" field.</summary>
    public const int UrisFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_uris_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> uris_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid RFC 3986 URIs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Uris {
      get { return uris_; }
    }

    /// <summary>Field number for the "email_addresses" field.</summary>
    public const int EmailAddressesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_emailAddresses_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> emailAddresses_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid RFC 2822 E-mail addresses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> EmailAddresses {
      get { return emailAddresses_; }
    }

    /// <summary>Field number for the "ip_addresses" field.</summary>
    public const int IpAddressesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_ipAddresses_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> ipAddresses_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> IpAddresses {
      get { return ipAddresses_; }
    }

    /// <summary>Field number for the "custom_sans" field.</summary>
    public const int CustomSansFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension> _repeated_customSans_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension> customSans_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension>();
    /// <summary>
    /// Contains additional subject alternative name values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1Beta1.X509Extension> CustomSans {
      get { return customSans_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SubjectAltNames);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SubjectAltNames other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dnsNames_.Equals(other.dnsNames_)) return false;
      if(!uris_.Equals(other.uris_)) return false;
      if(!emailAddresses_.Equals(other.emailAddresses_)) return false;
      if(!ipAddresses_.Equals(other.ipAddresses_)) return false;
      if(!customSans_.Equals(other.customSans_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dnsNames_.GetHashCode();
      hash ^= uris_.GetHashCode();
      hash ^= emailAddresses_.GetHashCode();
      hash ^= ipAddresses_.GetHashCode();
      hash ^= customSans_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      dnsNames_.WriteTo(output, _repeated_dnsNames_codec);
      uris_.WriteTo(output, _repeated_uris_codec);
      emailAddresses_.WriteTo(output, _repeated_emailAddresses_codec);
      ipAddresses_.WriteTo(output, _repeated_ipAddresses_codec);
      customSans_.WriteTo(output, _repeated_customSans_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      dnsNames_.WriteTo(ref output, _repeated_dnsNames_codec);
      uris_.WriteTo(ref output, _repeated_uris_codec);
      emailAddresses_.WriteTo(ref output, _repeated_emailAddresses_codec);
      ipAddresses_.WriteTo(ref output, _repeated_ipAddresses_codec);
      customSans_.WriteTo(ref output, _repeated_customSans_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dnsNames_.CalculateSize(_repeated_dnsNames_codec);
      size += uris_.CalculateSize(_repeated_uris_codec);
      size += emailAddresses_.CalculateSize(_repeated_emailAddresses_codec);
      size += ipAddresses_.CalculateSize(_repeated_ipAddresses_codec);
      size += customSans_.CalculateSize(_repeated_customSans_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SubjectAltNames other) {
      if (other == null) {
        return;
      }
      dnsNames_.Add(other.dnsNames_);
      uris_.Add(other.uris_);
      emailAddresses_.Add(other.emailAddresses_);
      ipAddresses_.Add(other.ipAddresses_);
      customSans_.Add(other.customSans_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dnsNames_.AddEntriesFrom(input, _repeated_dnsNames_codec);
            break;
          }
          case 18: {
            uris_.AddEntriesFrom(input, _repeated_uris_codec);
            break;
          }
          case 26: {
            emailAddresses_.AddEntriesFrom(input, _repeated_emailAddresses_codec);
            break;
          }
          case 34: {
            ipAddresses_.AddEntriesFrom(input, _repeated_ipAddresses_codec);
            break;
          }
          case 42: {
            customSans_.AddEntriesFrom(input, _repeated_customSans_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            dnsNames_.AddEntriesFrom(ref input, _repeated_dnsNames_codec);
            break;
          }
          case 18: {
            uris_.AddEntriesFrom(ref input, _repeated_uris_codec);
            break;
          }
          case 26: {
            emailAddresses_.AddEntriesFrom(ref input, _repeated_emailAddresses_codec);
            break;
          }
          case 34: {
            ipAddresses_.AddEntriesFrom(ref input, _repeated_ipAddresses_codec);
            break;
          }
          case 42: {
            customSans_.AddEntriesFrom(ref input, _repeated_customSans_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
