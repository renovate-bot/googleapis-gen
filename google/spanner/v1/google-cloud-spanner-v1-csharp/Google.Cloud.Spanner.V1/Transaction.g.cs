// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/spanner/v1/transaction.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Spanner.V1 {

  /// <summary>Holder for reflection information generated from google/spanner/v1/transaction.proto</summary>
  public static partial class TransactionReflection {

    #region Descriptor
    /// <summary>File descriptor for google/spanner/v1/transaction.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TransactionReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiNnb29nbGUvc3Bhbm5lci92MS90cmFuc2FjdGlvbi5wcm90bxIRZ29vZ2xl",
            "LnNwYW5uZXIudjEaHmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxof",
            "Z29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90bxocZ29vZ2xlL2FwaS9h",
            "bm5vdGF0aW9ucy5wcm90byLDBAoSVHJhbnNhY3Rpb25PcHRpb25zEkUKCnJl",
            "YWRfd3JpdGUYASABKAsyLy5nb29nbGUuc3Bhbm5lci52MS5UcmFuc2FjdGlv",
            "bk9wdGlvbnMuUmVhZFdyaXRlSAASTwoPcGFydGl0aW9uZWRfZG1sGAMgASgL",
            "MjQuZ29vZ2xlLnNwYW5uZXIudjEuVHJhbnNhY3Rpb25PcHRpb25zLlBhcnRp",
            "dGlvbmVkRG1sSAASQwoJcmVhZF9vbmx5GAIgASgLMi4uZ29vZ2xlLnNwYW5u",
            "ZXIudjEuVHJhbnNhY3Rpb25PcHRpb25zLlJlYWRPbmx5SAAaCwoJUmVhZFdy",
            "aXRlGhAKDlBhcnRpdGlvbmVkRG1sGqgCCghSZWFkT25seRIQCgZzdHJvbmcY",
            "ASABKAhIABI4ChJtaW5fcmVhZF90aW1lc3RhbXAYAiABKAsyGi5nb29nbGUu",
            "cHJvdG9idWYuVGltZXN0YW1wSAASMgoNbWF4X3N0YWxlbmVzcxgDIAEoCzIZ",
            "Lmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkgAEjQKDnJlYWRfdGltZXN0YW1w",
            "GAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAEjQKD2V4YWN0",
            "X3N0YWxlbmVzcxgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkgA",
            "Eh0KFXJldHVybl9yZWFkX3RpbWVzdGFtcBgGIAEoCEIRCg90aW1lc3RhbXBf",
            "Ym91bmRCBgoEbW9kZSJNCgtUcmFuc2FjdGlvbhIKCgJpZBgBIAEoDBIyCg5y",
            "ZWFkX3RpbWVzdGFtcBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3Rh",
            "bXAipAEKE1RyYW5zYWN0aW9uU2VsZWN0b3ISOwoKc2luZ2xlX3VzZRgBIAEo",
            "CzIlLmdvb2dsZS5zcGFubmVyLnYxLlRyYW5zYWN0aW9uT3B0aW9uc0gAEgwK",
            "AmlkGAIgASgMSAASNgoFYmVnaW4YAyABKAsyJS5nb29nbGUuc3Bhbm5lci52",
            "MS5UcmFuc2FjdGlvbk9wdGlvbnNIAEIKCghzZWxlY3RvckK2AQoVY29tLmdv",
            "b2dsZS5zcGFubmVyLnYxQhBUcmFuc2FjdGlvblByb3RvUAFaOGdvb2dsZS5n",
            "b2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvc3Bhbm5lci92MTtzcGFu",
            "bmVyqgIXR29vZ2xlLkNsb3VkLlNwYW5uZXIuVjHKAhdHb29nbGVcQ2xvdWRc",
            "U3Bhbm5lclxWMeoCGkdvb2dsZTo6Q2xvdWQ6OlNwYW5uZXI6OlYxYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions), global::Google.Cloud.Spanner.V1.TransactionOptions.Parser, new[]{ "ReadWrite", "PartitionedDml", "ReadOnly" }, new[]{ "Mode" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite), global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml), global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly), global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly.Parser, new[]{ "Strong", "MinReadTimestamp", "MaxStaleness", "ReadTimestamp", "ExactStaleness", "ReturnReadTimestamp" }, new[]{ "TimestampBound" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.Transaction), global::Google.Cloud.Spanner.V1.Transaction.Parser, new[]{ "Id", "ReadTimestamp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionSelector), global::Google.Cloud.Spanner.V1.TransactionSelector.Parser, new[]{ "SingleUse", "Id", "Begin" }, new[]{ "Selector" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// # Transactions
  ///
  /// Each session can have at most one active transaction at a time (note that
  /// standalone reads and queries use a transaction internally and do count
  /// towards the one transaction limit). After the active transaction is
  /// completed, the session can immediately be re-used for the next transaction.
  /// It is not necessary to create a new session for each transaction.
  ///
  /// # Transaction Modes
  ///
  /// Cloud Spanner supports three transaction modes:
  ///
  ///   1. Locking read-write. This type of transaction is the only way
  ///      to write data into Cloud Spanner. These transactions rely on
  ///      pessimistic locking and, if necessary, two-phase commit.
  ///      Locking read-write transactions may abort, requiring the
  ///      application to retry.
  ///
  ///   2. Snapshot read-only. This transaction type provides guaranteed
  ///      consistency across several reads, but does not allow
  ///      writes. Snapshot read-only transactions can be configured to
  ///      read at timestamps in the past. Snapshot read-only
  ///      transactions do not need to be committed.
  ///
  ///   3. Partitioned DML. This type of transaction is used to execute
  ///      a single Partitioned DML statement. Partitioned DML partitions
  ///      the key space and runs the DML statement over each partition
  ///      in parallel using separate, internal transactions that commit
  ///      independently. Partitioned DML transactions do not need to be
  ///      committed.
  ///
  /// For transactions that only read, snapshot read-only transactions
  /// provide simpler semantics and are almost always faster. In
  /// particular, read-only transactions do not take locks, so they do
  /// not conflict with read-write transactions. As a consequence of not
  /// taking locks, they also do not abort, so retry loops are not needed.
  ///
  /// Transactions may only read/write data in a single database. They
  /// may, however, read/write data in different tables within that
  /// database.
  ///
  /// ## Locking Read-Write Transactions
  ///
  /// Locking transactions may be used to atomically read-modify-write
  /// data anywhere in a database. This type of transaction is externally
  /// consistent.
  ///
  /// Clients should attempt to minimize the amount of time a transaction
  /// is active. Faster transactions commit with higher probability
  /// and cause less contention. Cloud Spanner attempts to keep read locks
  /// active as long as the transaction continues to do reads, and the
  /// transaction has not been terminated by
  /// [Commit][google.spanner.v1.Spanner.Commit] or
  /// [Rollback][google.spanner.v1.Spanner.Rollback].  Long periods of
  /// inactivity at the client may cause Cloud Spanner to release a
  /// transaction's locks and abort it.
  ///
  /// Conceptually, a read-write transaction consists of zero or more
  /// reads or SQL statements followed by
  /// [Commit][google.spanner.v1.Spanner.Commit]. At any time before
  /// [Commit][google.spanner.v1.Spanner.Commit], the client can send a
  /// [Rollback][google.spanner.v1.Spanner.Rollback] request to abort the
  /// transaction.
  ///
  /// ## Semantics
  ///
  /// Cloud Spanner can commit the transaction if all read locks it acquired
  /// are still valid at commit time, and it is able to acquire write
  /// locks for all writes. Cloud Spanner can abort the transaction for any
  /// reason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees
  /// that the transaction has not modified any user data in Cloud Spanner.
  ///
  /// Unless the transaction commits, Cloud Spanner makes no guarantees about
  /// how long the transaction's locks were held for. It is an error to
  /// use Cloud Spanner locks for any sort of mutual exclusion other than
  /// between Cloud Spanner transactions themselves.
  ///
  /// ## Retrying Aborted Transactions
  ///
  /// When a transaction aborts, the application can choose to retry the
  /// whole transaction again. To maximize the chances of successfully
  /// committing the retry, the client should execute the retry in the
  /// same session as the original attempt. The original session's lock
  /// priority increases with each consecutive abort, meaning that each
  /// attempt has a slightly better chance of success than the previous.
  ///
  /// Under some circumstances (e.g., many transactions attempting to
  /// modify the same row(s)), a transaction can abort many times in a
  /// short period before successfully committing. Thus, it is not a good
  /// idea to cap the number of retries a transaction can attempt;
  /// instead, it is better to limit the total amount of wall time spent
  /// retrying.
  ///
  /// ## Idle Transactions
  ///
  /// A transaction is considered idle if it has no outstanding reads or
  /// SQL queries and has not started a read or SQL query within the last 10
  /// seconds. Idle transactions can be aborted by Cloud Spanner so that they
  /// don't hold on to locks indefinitely. In that case, the commit will
  /// fail with error `ABORTED`.
  ///
  /// If this behavior is undesirable, periodically executing a simple
  /// SQL query in the transaction (e.g., `SELECT 1`) prevents the
  /// transaction from becoming idle.
  ///
  /// ## Snapshot Read-Only Transactions
  ///
  /// Snapshot read-only transactions provides a simpler method than
  /// locking read-write transactions for doing several consistent
  /// reads. However, this type of transaction does not support writes.
  ///
  /// Snapshot transactions do not take locks. Instead, they work by
  /// choosing a Cloud Spanner timestamp, then executing all reads at that
  /// timestamp. Since they do not acquire locks, they do not block
  /// concurrent read-write transactions.
  ///
  /// Unlike locking read-write transactions, snapshot read-only
  /// transactions never abort. They can fail if the chosen read
  /// timestamp is garbage collected; however, the default garbage
  /// collection policy is generous enough that most applications do not
  /// need to worry about this in practice.
  ///
  /// Snapshot read-only transactions do not need to call
  /// [Commit][google.spanner.v1.Spanner.Commit] or
  /// [Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not
  /// permitted to do so).
  ///
  /// To execute a snapshot transaction, the client specifies a timestamp
  /// bound, which tells Cloud Spanner how to choose a read timestamp.
  ///
  /// The types of timestamp bound are:
  ///
  ///   - Strong (the default).
  ///   - Bounded staleness.
  ///   - Exact staleness.
  ///
  /// If the Cloud Spanner database to be read is geographically distributed,
  /// stale read-only transactions can execute more quickly than strong
  /// or read-write transaction, because they are able to execute far
  /// from the leader replica.
  ///
  /// Each type of timestamp bound is discussed in detail below.
  ///
  /// ## Strong
  ///
  /// Strong reads are guaranteed to see the effects of all transactions
  /// that have committed before the start of the read. Furthermore, all
  /// rows yielded by a single read are consistent with each other -- if
  /// any part of the read observes a transaction, all parts of the read
  /// see the transaction.
  ///
  /// Strong reads are not repeatable: two consecutive strong read-only
  /// transactions might return inconsistent results if there are
  /// concurrent writes. If consistency across reads is required, the
  /// reads should be executed within a transaction or at an exact read
  /// timestamp.
  ///
  /// See [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].
  ///
  /// ## Exact Staleness
  ///
  /// These timestamp bounds execute reads at a user-specified
  /// timestamp. Reads at a timestamp are guaranteed to see a consistent
  /// prefix of the global transaction history: they observe
  /// modifications done by all transactions with a commit timestamp &lt;=
  /// the read timestamp, and observe none of the modifications done by
  /// transactions with a larger commit timestamp. They will block until
  /// all conflicting transactions that may be assigned commit timestamps
  /// &lt;= the read timestamp have finished.
  ///
  /// The timestamp can either be expressed as an absolute Cloud Spanner commit
  /// timestamp or a staleness relative to the current time.
  ///
  /// These modes do not require a "negotiation phase" to pick a
  /// timestamp. As a result, they execute slightly faster than the
  /// equivalent boundedly stale concurrency modes. On the other hand,
  /// boundedly stale reads usually return fresher results.
  ///
  /// See [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp] and
  /// [TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].
  ///
  /// ## Bounded Staleness
  ///
  /// Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
  /// subject to a user-provided staleness bound. Cloud Spanner chooses the
  /// newest timestamp within the staleness bound that allows execution
  /// of the reads at the closest available replica without blocking.
  ///
  /// All rows yielded are consistent with each other -- if any part of
  /// the read observes a transaction, all parts of the read see the
  /// transaction. Boundedly stale reads are not repeatable: two stale
  /// reads, even if they use the same staleness bound, can execute at
  /// different timestamps and thus return inconsistent results.
  ///
  /// Boundedly stale reads execute in two phases: the first phase
  /// negotiates a timestamp among all replicas needed to serve the
  /// read. In the second phase, reads are executed at the negotiated
  /// timestamp.
  ///
  /// As a result of the two phase execution, bounded staleness reads are
  /// usually a little slower than comparable exact staleness
  /// reads. However, they are typically able to return fresher
  /// results, and are more likely to execute at the closest replica.
  ///
  /// Because the timestamp negotiation requires up-front knowledge of
  /// which rows will be read, it can only be used with single-use
  /// read-only transactions.
  ///
  /// See [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness] and
  /// [TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].
  ///
  /// ## Old Read Timestamps and Garbage Collection
  ///
  /// Cloud Spanner continuously garbage collects deleted and overwritten data
  /// in the background to reclaim storage space. This process is known
  /// as "version GC". By default, version GC reclaims versions after they
  /// are one hour old. Because of this, Cloud Spanner cannot perform reads
  /// at read timestamps more than one hour in the past. This
  /// restriction also applies to in-progress reads and/or SQL queries whose
  /// timestamp become too old while executing. Reads and SQL queries with
  /// too-old read timestamps fail with the error `FAILED_PRECONDITION`.
  ///
  /// ## Partitioned DML Transactions
  ///
  /// Partitioned DML transactions are used to execute DML statements with a
  /// different execution strategy that provides different, and often better,
  /// scalability properties for large, table-wide operations than DML in a
  /// ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
  /// should prefer using ReadWrite transactions.
  ///
  /// Partitioned DML partitions the keyspace and runs the DML statement on each
  /// partition in separate, internal transactions. These transactions commit
  /// automatically when complete, and run independently from one another.
  ///
  /// To reduce lock contention, this execution strategy only acquires read locks
  /// on rows that match the WHERE clause of the statement. Additionally, the
  /// smaller per-partition transactions hold locks for less time.
  ///
  /// That said, Partitioned DML is not a drop-in replacement for standard DML used
  /// in ReadWrite transactions.
  ///
  ///  - The DML statement must be fully-partitionable. Specifically, the statement
  ///    must be expressible as the union of many statements which each access only
  ///    a single row of the table.
  ///
  ///  - The statement is not applied atomically to all rows of the table. Rather,
  ///    the statement is applied atomically to partitions of the table, in
  ///    independent transactions. Secondary index rows are updated atomically
  ///    with the base table rows.
  ///
  ///  - Partitioned DML does not guarantee exactly-once execution semantics
  ///    against a partition. The statement will be applied at least once to each
  ///    partition. It is strongly recommended that the DML statement should be
  ///    idempotent to avoid unexpected results. For instance, it is potentially
  ///    dangerous to run a statement such as
  ///    `UPDATE table SET column = column + 1` as it could be run multiple times
  ///    against some rows.
  ///
  ///  - The partitions are committed automatically - there is no support for
  ///    Commit or Rollback. If the call returns an error, or if the client issuing
  ///    the ExecuteSql call dies, it is possible that some rows had the statement
  ///    executed on them successfully. It is also possible that statement was
  ///    never executed against other rows.
  ///
  ///  - Partitioned DML transactions may only contain the execution of a single
  ///    DML statement via ExecuteSql or ExecuteStreamingSql.
  ///
  ///  - If any error is encountered during the execution of the partitioned DML
  ///    operation (for instance, a UNIQUE INDEX violation, division by zero, or a
  ///    value that cannot be stored due to schema constraints), then the
  ///    operation is stopped at that point and an error is returned. It is
  ///    possible that at this point, some partitions have been committed (or even
  ///    committed multiple times), and other partitions have not been run at all.
  ///
  /// Given the above, Partitioned DML is good fit for large, database-wide,
  /// operations that are idempotent, such as deleting old rows from a very large
  /// table.
  /// </summary>
  public sealed partial class TransactionOptions : pb::IMessage<TransactionOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransactionOptions> _parser = new pb::MessageParser<TransactionOptions>(() => new TransactionOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransactionOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Spanner.V1.TransactionReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransactionOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransactionOptions(TransactionOptions other) : this() {
      switch (other.ModeCase) {
        case ModeOneofCase.ReadWrite:
          ReadWrite = other.ReadWrite.Clone();
          break;
        case ModeOneofCase.PartitionedDml:
          PartitionedDml = other.PartitionedDml.Clone();
          break;
        case ModeOneofCase.ReadOnly:
          ReadOnly = other.ReadOnly.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransactionOptions Clone() {
      return new TransactionOptions(this);
    }

    /// <summary>Field number for the "read_write" field.</summary>
    public const int ReadWriteFieldNumber = 1;
    /// <summary>
    /// Transaction may write.
    ///
    /// Authorization to begin a read-write transaction requires
    /// `spanner.databases.beginOrRollbackReadWriteTransaction` permission
    /// on the `session` resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite ReadWrite {
      get { return modeCase_ == ModeOneofCase.ReadWrite ? (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite) mode_ : null; }
      set {
        mode_ = value;
        modeCase_ = value == null ? ModeOneofCase.None : ModeOneofCase.ReadWrite;
      }
    }

    /// <summary>Field number for the "partitioned_dml" field.</summary>
    public const int PartitionedDmlFieldNumber = 3;
    /// <summary>
    /// Partitioned DML transaction.
    ///
    /// Authorization to begin a Partitioned DML transaction requires
    /// `spanner.databases.beginPartitionedDmlTransaction` permission
    /// on the `session` resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml PartitionedDml {
      get { return modeCase_ == ModeOneofCase.PartitionedDml ? (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml) mode_ : null; }
      set {
        mode_ = value;
        modeCase_ = value == null ? ModeOneofCase.None : ModeOneofCase.PartitionedDml;
      }
    }

    /// <summary>Field number for the "read_only" field.</summary>
    public const int ReadOnlyFieldNumber = 2;
    /// <summary>
    /// Transaction will not write.
    ///
    /// Authorization to begin a read-only transaction requires
    /// `spanner.databases.beginReadOnlyTransaction` permission
    /// on the `session` resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly ReadOnly {
      get { return modeCase_ == ModeOneofCase.ReadOnly ? (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly) mode_ : null; }
      set {
        mode_ = value;
        modeCase_ = value == null ? ModeOneofCase.None : ModeOneofCase.ReadOnly;
      }
    }

    private object mode_;
    /// <summary>Enum of possible cases for the "mode" oneof.</summary>
    public enum ModeOneofCase {
      None = 0,
      ReadWrite = 1,
      PartitionedDml = 3,
      ReadOnly = 2,
    }
    private ModeOneofCase modeCase_ = ModeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModeOneofCase ModeCase {
      get { return modeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMode() {
      modeCase_ = ModeOneofCase.None;
      mode_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransactionOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransactionOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ReadWrite, other.ReadWrite)) return false;
      if (!object.Equals(PartitionedDml, other.PartitionedDml)) return false;
      if (!object.Equals(ReadOnly, other.ReadOnly)) return false;
      if (ModeCase != other.ModeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (modeCase_ == ModeOneofCase.ReadWrite) hash ^= ReadWrite.GetHashCode();
      if (modeCase_ == ModeOneofCase.PartitionedDml) hash ^= PartitionedDml.GetHashCode();
      if (modeCase_ == ModeOneofCase.ReadOnly) hash ^= ReadOnly.GetHashCode();
      hash ^= (int) modeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (modeCase_ == ModeOneofCase.ReadWrite) {
        output.WriteRawTag(10);
        output.WriteMessage(ReadWrite);
      }
      if (modeCase_ == ModeOneofCase.ReadOnly) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadOnly);
      }
      if (modeCase_ == ModeOneofCase.PartitionedDml) {
        output.WriteRawTag(26);
        output.WriteMessage(PartitionedDml);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (modeCase_ == ModeOneofCase.ReadWrite) {
        output.WriteRawTag(10);
        output.WriteMessage(ReadWrite);
      }
      if (modeCase_ == ModeOneofCase.ReadOnly) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadOnly);
      }
      if (modeCase_ == ModeOneofCase.PartitionedDml) {
        output.WriteRawTag(26);
        output.WriteMessage(PartitionedDml);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (modeCase_ == ModeOneofCase.ReadWrite) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadWrite);
      }
      if (modeCase_ == ModeOneofCase.PartitionedDml) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PartitionedDml);
      }
      if (modeCase_ == ModeOneofCase.ReadOnly) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadOnly);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransactionOptions other) {
      if (other == null) {
        return;
      }
      switch (other.ModeCase) {
        case ModeOneofCase.ReadWrite:
          if (ReadWrite == null) {
            ReadWrite = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite();
          }
          ReadWrite.MergeFrom(other.ReadWrite);
          break;
        case ModeOneofCase.PartitionedDml:
          if (PartitionedDml == null) {
            PartitionedDml = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml();
          }
          PartitionedDml.MergeFrom(other.PartitionedDml);
          break;
        case ModeOneofCase.ReadOnly:
          if (ReadOnly == null) {
            ReadOnly = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly();
          }
          ReadOnly.MergeFrom(other.ReadOnly);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite();
            if (modeCase_ == ModeOneofCase.ReadWrite) {
              subBuilder.MergeFrom(ReadWrite);
            }
            input.ReadMessage(subBuilder);
            ReadWrite = subBuilder;
            break;
          }
          case 18: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly();
            if (modeCase_ == ModeOneofCase.ReadOnly) {
              subBuilder.MergeFrom(ReadOnly);
            }
            input.ReadMessage(subBuilder);
            ReadOnly = subBuilder;
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml();
            if (modeCase_ == ModeOneofCase.PartitionedDml) {
              subBuilder.MergeFrom(PartitionedDml);
            }
            input.ReadMessage(subBuilder);
            PartitionedDml = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite();
            if (modeCase_ == ModeOneofCase.ReadWrite) {
              subBuilder.MergeFrom(ReadWrite);
            }
            input.ReadMessage(subBuilder);
            ReadWrite = subBuilder;
            break;
          }
          case 18: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly();
            if (modeCase_ == ModeOneofCase.ReadOnly) {
              subBuilder.MergeFrom(ReadOnly);
            }
            input.ReadMessage(subBuilder);
            ReadOnly = subBuilder;
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml();
            if (modeCase_ == ModeOneofCase.PartitionedDml) {
              subBuilder.MergeFrom(PartitionedDml);
            }
            input.ReadMessage(subBuilder);
            PartitionedDml = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TransactionOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Message type to initiate a read-write transaction. Currently this
      /// transaction type has no options.
      /// </summary>
      public sealed partial class ReadWrite : pb::IMessage<ReadWrite>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ReadWrite> _parser = new pb::MessageParser<ReadWrite>(() => new ReadWrite());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ReadWrite> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Spanner.V1.TransactionOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReadWrite() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReadWrite(ReadWrite other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReadWrite Clone() {
          return new ReadWrite(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ReadWrite);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ReadWrite other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ReadWrite other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Message type to initiate a Partitioned DML transaction.
      /// </summary>
      public sealed partial class PartitionedDml : pb::IMessage<PartitionedDml>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PartitionedDml> _parser = new pb::MessageParser<PartitionedDml>(() => new PartitionedDml());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PartitionedDml> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Spanner.V1.TransactionOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PartitionedDml() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PartitionedDml(PartitionedDml other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PartitionedDml Clone() {
          return new PartitionedDml(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PartitionedDml);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PartitionedDml other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PartitionedDml other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Message type to initiate a read-only transaction.
      /// </summary>
      public sealed partial class ReadOnly : pb::IMessage<ReadOnly>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ReadOnly> _parser = new pb::MessageParser<ReadOnly>(() => new ReadOnly());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ReadOnly> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Spanner.V1.TransactionOptions.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReadOnly() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReadOnly(ReadOnly other) : this() {
          returnReadTimestamp_ = other.returnReadTimestamp_;
          switch (other.TimestampBoundCase) {
            case TimestampBoundOneofCase.Strong:
              Strong = other.Strong;
              break;
            case TimestampBoundOneofCase.MinReadTimestamp:
              MinReadTimestamp = other.MinReadTimestamp.Clone();
              break;
            case TimestampBoundOneofCase.MaxStaleness:
              MaxStaleness = other.MaxStaleness.Clone();
              break;
            case TimestampBoundOneofCase.ReadTimestamp:
              ReadTimestamp = other.ReadTimestamp.Clone();
              break;
            case TimestampBoundOneofCase.ExactStaleness:
              ExactStaleness = other.ExactStaleness.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReadOnly Clone() {
          return new ReadOnly(this);
        }

        /// <summary>Field number for the "strong" field.</summary>
        public const int StrongFieldNumber = 1;
        /// <summary>
        /// Read at a timestamp where all previously committed transactions
        /// are visible.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Strong {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.Strong ? (bool) timestampBound_ : false; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = TimestampBoundOneofCase.Strong;
          }
        }

        /// <summary>Field number for the "min_read_timestamp" field.</summary>
        public const int MinReadTimestampFieldNumber = 2;
        /// <summary>
        /// Executes all reads at a timestamp >= `min_read_timestamp`.
        ///
        /// This is useful for requesting fresher data than some previous
        /// read, or data that is fresh enough to observe the effects of some
        /// previously committed transaction whose timestamp is known.
        ///
        /// Note that this option can only be used in single-use transactions.
        ///
        /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
        /// Example: `"2014-10-02T15:01:23.045123456Z"`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp MinReadTimestamp {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp ? (global::Google.Protobuf.WellKnownTypes.Timestamp) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.MinReadTimestamp;
          }
        }

        /// <summary>Field number for the "max_staleness" field.</summary>
        public const int MaxStalenessFieldNumber = 3;
        /// <summary>
        /// Read data at a timestamp >= `NOW - max_staleness`
        /// seconds. Guarantees that all writes that have committed more
        /// than the specified number of seconds ago are visible. Because
        /// Cloud Spanner chooses the exact timestamp, this mode works even if
        /// the client's local clock is substantially skewed from Cloud Spanner
        /// commit timestamps.
        ///
        /// Useful for reading the freshest data available at a nearby
        /// replica, while bounding the possible staleness if the local
        /// replica has fallen behind.
        ///
        /// Note that this option can only be used in single-use
        /// transactions.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxStaleness {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness ? (global::Google.Protobuf.WellKnownTypes.Duration) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.MaxStaleness;
          }
        }

        /// <summary>Field number for the "read_timestamp" field.</summary>
        public const int ReadTimestampFieldNumber = 4;
        /// <summary>
        /// Executes all reads at the given timestamp. Unlike other modes,
        /// reads at a specific timestamp are repeatable; the same read at
        /// the same timestamp always returns the same data. If the
        /// timestamp is in the future, the read will block until the
        /// specified timestamp, modulo the read's deadline.
        ///
        /// Useful for large scale consistent reads such as mapreduces, or
        /// for coordinating many reads against a consistent snapshot of the
        /// data.
        ///
        /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
        /// Example: `"2014-10-02T15:01:23.045123456Z"`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp ReadTimestamp {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp ? (global::Google.Protobuf.WellKnownTypes.Timestamp) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.ReadTimestamp;
          }
        }

        /// <summary>Field number for the "exact_staleness" field.</summary>
        public const int ExactStalenessFieldNumber = 5;
        /// <summary>
        /// Executes all reads at a timestamp that is `exact_staleness`
        /// old. The timestamp is chosen soon after the read is started.
        ///
        /// Guarantees that all writes that have committed more than the
        /// specified number of seconds ago are visible. Because Cloud Spanner
        /// chooses the exact timestamp, this mode works even if the client's
        /// local clock is substantially skewed from Cloud Spanner commit
        /// timestamps.
        ///
        /// Useful for reading at nearby replicas without the distributed
        /// timestamp negotiation overhead of `max_staleness`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration ExactStaleness {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness ? (global::Google.Protobuf.WellKnownTypes.Duration) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.ExactStaleness;
          }
        }

        /// <summary>Field number for the "return_read_timestamp" field.</summary>
        public const int ReturnReadTimestampFieldNumber = 6;
        private bool returnReadTimestamp_;
        /// <summary>
        /// If true, the Cloud Spanner-selected read timestamp is included in
        /// the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ReturnReadTimestamp {
          get { return returnReadTimestamp_; }
          set {
            returnReadTimestamp_ = value;
          }
        }

        private object timestampBound_;
        /// <summary>Enum of possible cases for the "timestamp_bound" oneof.</summary>
        public enum TimestampBoundOneofCase {
          None = 0,
          Strong = 1,
          MinReadTimestamp = 2,
          MaxStaleness = 3,
          ReadTimestamp = 4,
          ExactStaleness = 5,
        }
        private TimestampBoundOneofCase timestampBoundCase_ = TimestampBoundOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimestampBoundOneofCase TimestampBoundCase {
          get { return timestampBoundCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTimestampBound() {
          timestampBoundCase_ = TimestampBoundOneofCase.None;
          timestampBound_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ReadOnly);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ReadOnly other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Strong != other.Strong) return false;
          if (!object.Equals(MinReadTimestamp, other.MinReadTimestamp)) return false;
          if (!object.Equals(MaxStaleness, other.MaxStaleness)) return false;
          if (!object.Equals(ReadTimestamp, other.ReadTimestamp)) return false;
          if (!object.Equals(ExactStaleness, other.ExactStaleness)) return false;
          if (ReturnReadTimestamp != other.ReturnReadTimestamp) return false;
          if (TimestampBoundCase != other.TimestampBoundCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (timestampBoundCase_ == TimestampBoundOneofCase.Strong) hash ^= Strong.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) hash ^= MinReadTimestamp.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) hash ^= MaxStaleness.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) hash ^= ReadTimestamp.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) hash ^= ExactStaleness.GetHashCode();
          if (ReturnReadTimestamp != false) hash ^= ReturnReadTimestamp.GetHashCode();
          hash ^= (int) timestampBoundCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (timestampBoundCase_ == TimestampBoundOneofCase.Strong) {
            output.WriteRawTag(8);
            output.WriteBool(Strong);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
            output.WriteRawTag(18);
            output.WriteMessage(MinReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
            output.WriteRawTag(26);
            output.WriteMessage(MaxStaleness);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
            output.WriteRawTag(34);
            output.WriteMessage(ReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
            output.WriteRawTag(42);
            output.WriteMessage(ExactStaleness);
          }
          if (ReturnReadTimestamp != false) {
            output.WriteRawTag(48);
            output.WriteBool(ReturnReadTimestamp);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (timestampBoundCase_ == TimestampBoundOneofCase.Strong) {
            output.WriteRawTag(8);
            output.WriteBool(Strong);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
            output.WriteRawTag(18);
            output.WriteMessage(MinReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
            output.WriteRawTag(26);
            output.WriteMessage(MaxStaleness);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
            output.WriteRawTag(34);
            output.WriteMessage(ReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
            output.WriteRawTag(42);
            output.WriteMessage(ExactStaleness);
          }
          if (ReturnReadTimestamp != false) {
            output.WriteRawTag(48);
            output.WriteBool(ReturnReadTimestamp);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (timestampBoundCase_ == TimestampBoundOneofCase.Strong) {
            size += 1 + 1;
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxStaleness);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExactStaleness);
          }
          if (ReturnReadTimestamp != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ReadOnly other) {
          if (other == null) {
            return;
          }
          if (other.ReturnReadTimestamp != false) {
            ReturnReadTimestamp = other.ReturnReadTimestamp;
          }
          switch (other.TimestampBoundCase) {
            case TimestampBoundOneofCase.Strong:
              Strong = other.Strong;
              break;
            case TimestampBoundOneofCase.MinReadTimestamp:
              if (MinReadTimestamp == null) {
                MinReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
              }
              MinReadTimestamp.MergeFrom(other.MinReadTimestamp);
              break;
            case TimestampBoundOneofCase.MaxStaleness:
              if (MaxStaleness == null) {
                MaxStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
              }
              MaxStaleness.MergeFrom(other.MaxStaleness);
              break;
            case TimestampBoundOneofCase.ReadTimestamp:
              if (ReadTimestamp == null) {
                ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
              }
              ReadTimestamp.MergeFrom(other.ReadTimestamp);
              break;
            case TimestampBoundOneofCase.ExactStaleness:
              if (ExactStaleness == null) {
                ExactStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
              }
              ExactStaleness.MergeFrom(other.ExactStaleness);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Strong = input.ReadBool();
                break;
              }
              case 18: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
                  subBuilder.MergeFrom(MinReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                MinReadTimestamp = subBuilder;
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
                  subBuilder.MergeFrom(MaxStaleness);
                }
                input.ReadMessage(subBuilder);
                MaxStaleness = subBuilder;
                break;
              }
              case 34: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
                  subBuilder.MergeFrom(ReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                ReadTimestamp = subBuilder;
                break;
              }
              case 42: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
                  subBuilder.MergeFrom(ExactStaleness);
                }
                input.ReadMessage(subBuilder);
                ExactStaleness = subBuilder;
                break;
              }
              case 48: {
                ReturnReadTimestamp = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Strong = input.ReadBool();
                break;
              }
              case 18: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
                  subBuilder.MergeFrom(MinReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                MinReadTimestamp = subBuilder;
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
                  subBuilder.MergeFrom(MaxStaleness);
                }
                input.ReadMessage(subBuilder);
                MaxStaleness = subBuilder;
                break;
              }
              case 34: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
                  subBuilder.MergeFrom(ReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                ReadTimestamp = subBuilder;
                break;
              }
              case 42: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
                  subBuilder.MergeFrom(ExactStaleness);
                }
                input.ReadMessage(subBuilder);
                ExactStaleness = subBuilder;
                break;
              }
              case 48: {
                ReturnReadTimestamp = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A transaction.
  /// </summary>
  public sealed partial class Transaction : pb::IMessage<Transaction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Transaction> _parser = new pb::MessageParser<Transaction>(() => new Transaction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Transaction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Spanner.V1.TransactionReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Transaction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Transaction(Transaction other) : this() {
      id_ = other.id_;
      readTimestamp_ = other.readTimestamp_ != null ? other.readTimestamp_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Transaction Clone() {
      return new Transaction(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private pb::ByteString id_ = pb::ByteString.Empty;
    /// <summary>
    /// `id` may be used to identify the transaction in subsequent
    /// [Read][google.spanner.v1.Spanner.Read],
    /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],
    /// [Commit][google.spanner.v1.Spanner.Commit], or
    /// [Rollback][google.spanner.v1.Spanner.Rollback] calls.
    ///
    /// Single-use read-only transactions do not have IDs, because
    /// single-use transactions do not support multiple requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "read_timestamp" field.</summary>
    public const int ReadTimestampFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp readTimestamp_;
    /// <summary>
    /// For snapshot read-only transactions, the read timestamp chosen
    /// for the transaction. Not returned by default: see
    /// [TransactionOptions.ReadOnly.return_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.return_read_timestamp].
    ///
    /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
    /// Example: `"2014-10-02T15:01:23.045123456Z"`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ReadTimestamp {
      get { return readTimestamp_; }
      set {
        readTimestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Transaction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Transaction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!object.Equals(ReadTimestamp, other.ReadTimestamp)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (readTimestamp_ != null) hash ^= ReadTimestamp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Id);
      }
      if (readTimestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Id);
      }
      if (readTimestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Id);
      }
      if (readTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadTimestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Transaction other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.readTimestamp_ != null) {
        if (readTimestamp_ == null) {
          ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ReadTimestamp.MergeFrom(other.ReadTimestamp);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadBytes();
            break;
          }
          case 18: {
            if (readTimestamp_ == null) {
              ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReadTimestamp);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Id = input.ReadBytes();
            break;
          }
          case 18: {
            if (readTimestamp_ == null) {
              ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReadTimestamp);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// This message is used to select the transaction in which a
  /// [Read][google.spanner.v1.Spanner.Read] or
  /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] call runs.
  ///
  /// See [TransactionOptions][google.spanner.v1.TransactionOptions] for more information about transactions.
  /// </summary>
  public sealed partial class TransactionSelector : pb::IMessage<TransactionSelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransactionSelector> _parser = new pb::MessageParser<TransactionSelector>(() => new TransactionSelector());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransactionSelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Spanner.V1.TransactionReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransactionSelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransactionSelector(TransactionSelector other) : this() {
      switch (other.SelectorCase) {
        case SelectorOneofCase.SingleUse:
          SingleUse = other.SingleUse.Clone();
          break;
        case SelectorOneofCase.Id:
          Id = other.Id;
          break;
        case SelectorOneofCase.Begin:
          Begin = other.Begin.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransactionSelector Clone() {
      return new TransactionSelector(this);
    }

    /// <summary>Field number for the "single_use" field.</summary>
    public const int SingleUseFieldNumber = 1;
    /// <summary>
    /// Execute the read or SQL query in a temporary transaction.
    /// This is the most efficient way to execute a transaction that
    /// consists of a single SQL query.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Spanner.V1.TransactionOptions SingleUse {
      get { return selectorCase_ == SelectorOneofCase.SingleUse ? (global::Google.Cloud.Spanner.V1.TransactionOptions) selector_ : null; }
      set {
        selector_ = value;
        selectorCase_ = value == null ? SelectorOneofCase.None : SelectorOneofCase.SingleUse;
      }
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 2;
    /// <summary>
    /// Execute the read or SQL query in a previously-started transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Id {
      get { return selectorCase_ == SelectorOneofCase.Id ? (pb::ByteString) selector_ : pb::ByteString.Empty; }
      set {
        selector_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        selectorCase_ = SelectorOneofCase.Id;
      }
    }

    /// <summary>Field number for the "begin" field.</summary>
    public const int BeginFieldNumber = 3;
    /// <summary>
    /// Begin a new transaction and execute this read or SQL query in
    /// it. The transaction ID of the new transaction is returned in
    /// [ResultSetMetadata.transaction][google.spanner.v1.ResultSetMetadata.transaction], which is a [Transaction][google.spanner.v1.Transaction].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Spanner.V1.TransactionOptions Begin {
      get { return selectorCase_ == SelectorOneofCase.Begin ? (global::Google.Cloud.Spanner.V1.TransactionOptions) selector_ : null; }
      set {
        selector_ = value;
        selectorCase_ = value == null ? SelectorOneofCase.None : SelectorOneofCase.Begin;
      }
    }

    private object selector_;
    /// <summary>Enum of possible cases for the "selector" oneof.</summary>
    public enum SelectorOneofCase {
      None = 0,
      SingleUse = 1,
      Id = 2,
      Begin = 3,
    }
    private SelectorOneofCase selectorCase_ = SelectorOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SelectorOneofCase SelectorCase {
      get { return selectorCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSelector() {
      selectorCase_ = SelectorOneofCase.None;
      selector_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransactionSelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransactionSelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SingleUse, other.SingleUse)) return false;
      if (Id != other.Id) return false;
      if (!object.Equals(Begin, other.Begin)) return false;
      if (SelectorCase != other.SelectorCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (selectorCase_ == SelectorOneofCase.SingleUse) hash ^= SingleUse.GetHashCode();
      if (selectorCase_ == SelectorOneofCase.Id) hash ^= Id.GetHashCode();
      if (selectorCase_ == SelectorOneofCase.Begin) hash ^= Begin.GetHashCode();
      hash ^= (int) selectorCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (selectorCase_ == SelectorOneofCase.SingleUse) {
        output.WriteRawTag(10);
        output.WriteMessage(SingleUse);
      }
      if (selectorCase_ == SelectorOneofCase.Id) {
        output.WriteRawTag(18);
        output.WriteBytes(Id);
      }
      if (selectorCase_ == SelectorOneofCase.Begin) {
        output.WriteRawTag(26);
        output.WriteMessage(Begin);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (selectorCase_ == SelectorOneofCase.SingleUse) {
        output.WriteRawTag(10);
        output.WriteMessage(SingleUse);
      }
      if (selectorCase_ == SelectorOneofCase.Id) {
        output.WriteRawTag(18);
        output.WriteBytes(Id);
      }
      if (selectorCase_ == SelectorOneofCase.Begin) {
        output.WriteRawTag(26);
        output.WriteMessage(Begin);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (selectorCase_ == SelectorOneofCase.SingleUse) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SingleUse);
      }
      if (selectorCase_ == SelectorOneofCase.Id) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Id);
      }
      if (selectorCase_ == SelectorOneofCase.Begin) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Begin);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransactionSelector other) {
      if (other == null) {
        return;
      }
      switch (other.SelectorCase) {
        case SelectorOneofCase.SingleUse:
          if (SingleUse == null) {
            SingleUse = new global::Google.Cloud.Spanner.V1.TransactionOptions();
          }
          SingleUse.MergeFrom(other.SingleUse);
          break;
        case SelectorOneofCase.Id:
          Id = other.Id;
          break;
        case SelectorOneofCase.Begin:
          if (Begin == null) {
            Begin = new global::Google.Cloud.Spanner.V1.TransactionOptions();
          }
          Begin.MergeFrom(other.Begin);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.SingleUse) {
              subBuilder.MergeFrom(SingleUse);
            }
            input.ReadMessage(subBuilder);
            SingleUse = subBuilder;
            break;
          }
          case 18: {
            Id = input.ReadBytes();
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.Begin) {
              subBuilder.MergeFrom(Begin);
            }
            input.ReadMessage(subBuilder);
            Begin = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.SingleUse) {
              subBuilder.MergeFrom(SingleUse);
            }
            input.ReadMessage(subBuilder);
            SingleUse = subBuilder;
            break;
          }
          case 18: {
            Id = input.ReadBytes();
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.Begin) {
              subBuilder.MergeFrom(Begin);
            }
            input.ReadMessage(subBuilder);
            Begin = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
