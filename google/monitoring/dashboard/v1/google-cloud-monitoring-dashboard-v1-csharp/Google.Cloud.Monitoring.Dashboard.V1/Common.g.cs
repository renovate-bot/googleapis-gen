// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/monitoring/dashboard/v1/common.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Monitoring.Dashboard.V1 {

  /// <summary>Holder for reflection information generated from google/monitoring/dashboard/v1/common.proto</summary>
  public static partial class CommonReflection {

    #region Descriptor
    /// <summary>File descriptor for google/monitoring/dashboard/v1/common.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CommonReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Citnb29nbGUvbW9uaXRvcmluZy9kYXNoYm9hcmQvdjEvY29tbW9uLnByb3Rv",
            "Eh5nb29nbGUubW9uaXRvcmluZy5kYXNoYm9hcmQudjEaHWdvb2dsZS9hcGkv",
            "ZGlzdHJpYnV0aW9uLnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24u",
            "cHJvdG8iwQcKC0FnZ3JlZ2F0aW9uEjMKEGFsaWdubWVudF9wZXJpb2QYASAB",
            "KAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24STwoScGVyX3Nlcmllc19h",
            "bGlnbmVyGAIgASgOMjMuZ29vZ2xlLm1vbml0b3JpbmcuZGFzaGJvYXJkLnYx",
            "LkFnZ3JlZ2F0aW9uLkFsaWduZXISUQoUY3Jvc3Nfc2VyaWVzX3JlZHVjZXIY",
            "BCABKA4yMy5nb29nbGUubW9uaXRvcmluZy5kYXNoYm9hcmQudjEuQWdncmVn",
            "YXRpb24uUmVkdWNlchIXCg9ncm91cF9ieV9maWVsZHMYBSADKAkiiwMKB0Fs",
            "aWduZXISDgoKQUxJR05fTk9ORRAAEg8KC0FMSUdOX0RFTFRBEAESDgoKQUxJ",
            "R05fUkFURRACEhUKEUFMSUdOX0lOVEVSUE9MQVRFEAMSFAoQQUxJR05fTkVY",
            "VF9PTERFUhAEEg0KCUFMSUdOX01JThAKEg0KCUFMSUdOX01BWBALEg4KCkFM",
            "SUdOX01FQU4QDBIPCgtBTElHTl9DT1VOVBANEg0KCUFMSUdOX1NVTRAOEhAK",
            "DEFMSUdOX1NURERFVhAPEhQKEEFMSUdOX0NPVU5UX1RSVUUQEBIVChFBTElH",
            "Tl9DT1VOVF9GQUxTRRAYEhcKE0FMSUdOX0ZSQUNUSU9OX1RSVUUQERIXChNB",
            "TElHTl9QRVJDRU5USUxFXzk5EBISFwoTQUxJR05fUEVSQ0VOVElMRV85NRAT",
            "EhcKE0FMSUdOX1BFUkNFTlRJTEVfNTAQFBIXChNBTElHTl9QRVJDRU5USUxF",
            "XzA1EBUSGAoUQUxJR05fUEVSQ0VOVF9DSEFOR0UQFyKxAgoHUmVkdWNlchIP",
            "CgtSRURVQ0VfTk9ORRAAEg8KC1JFRFVDRV9NRUFOEAESDgoKUkVEVUNFX01J",
            "ThACEg4KClJFRFVDRV9NQVgQAxIOCgpSRURVQ0VfU1VNEAQSEQoNUkVEVUNF",
            "X1NURERFVhAFEhAKDFJFRFVDRV9DT1VOVBAGEhUKEVJFRFVDRV9DT1VOVF9U",
            "UlVFEAcSFgoSUkVEVUNFX0NPVU5UX0ZBTFNFEA8SGAoUUkVEVUNFX0ZSQUNU",
            "SU9OX1RSVUUQCBIYChRSRURVQ0VfUEVSQ0VOVElMRV85ORAJEhgKFFJFRFVD",
            "RV9QRVJDRU5USUxFXzk1EAoSGAoUUkVEVUNFX1BFUkNFTlRJTEVfNTAQCxIY",
            "ChRSRURVQ0VfUEVSQ0VOVElMRV8wNRAMIooDChRQaWNrVGltZVNlcmllc0Zp",
            "bHRlchJTCg5yYW5raW5nX21ldGhvZBgBIAEoDjI7Lmdvb2dsZS5tb25pdG9y",
            "aW5nLmRhc2hib2FyZC52MS5QaWNrVGltZVNlcmllc0ZpbHRlci5NZXRob2QS",
            "FwoPbnVtX3RpbWVfc2VyaWVzGAIgASgFElEKCWRpcmVjdGlvbhgDIAEoDjI+",
            "Lmdvb2dsZS5tb25pdG9yaW5nLmRhc2hib2FyZC52MS5QaWNrVGltZVNlcmll",
            "c0ZpbHRlci5EaXJlY3Rpb24idAoGTWV0aG9kEhYKEk1FVEhPRF9VTlNQRUNJ",
            "RklFRBAAEg8KC01FVEhPRF9NRUFOEAESDgoKTUVUSE9EX01BWBACEg4KCk1F",
            "VEhPRF9NSU4QAxIOCgpNRVRIT0RfU1VNEAQSEQoNTUVUSE9EX0xBVEVTVBAF",
            "IjsKCURpcmVjdGlvbhIZChVESVJFQ1RJT05fVU5TUEVDSUZJRUQQABIHCgNU",
            "T1AQARIKCgZCT1RUT00QAiLQAQobU3RhdGlzdGljYWxUaW1lU2VyaWVzRmls",
            "dGVyEloKDnJhbmtpbmdfbWV0aG9kGAEgASgOMkIuZ29vZ2xlLm1vbml0b3Jp",
            "bmcuZGFzaGJvYXJkLnYxLlN0YXRpc3RpY2FsVGltZVNlcmllc0ZpbHRlci5N",
            "ZXRob2QSFwoPbnVtX3RpbWVfc2VyaWVzGAIgASgFIjwKBk1ldGhvZBIWChJN",
            "RVRIT0RfVU5TUEVDSUZJRUQQABIaChZNRVRIT0RfQ0xVU1RFUl9PVVRMSUVS",
            "EAFC9QEKImNvbS5nb29nbGUubW9uaXRvcmluZy5kYXNoYm9hcmQudjFCC0Nv",
            "bW1vblByb3RvUAFaR2dvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2ds",
            "ZWFwaXMvbW9uaXRvcmluZy9kYXNoYm9hcmQvdjE7ZGFzaGJvYXJkqgIkR29v",
            "Z2xlLkNsb3VkLk1vbml0b3JpbmcuRGFzaGJvYXJkLlYxygIkR29vZ2xlXENs",
            "b3VkXE1vbml0b3JpbmdcRGFzaGJvYXJkXFYx6gIoR29vZ2xlOjpDbG91ZDo6",
            "TW9uaXRvcmluZzo6RGFzaGJvYXJkOjpWMWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.DistributionReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation), global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Parser, new[]{ "AlignmentPeriod", "PerSeriesAligner", "CrossSeriesReducer", "GroupByFields" }, null, new[]{ typeof(global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner), typeof(global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter), global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Parser, new[]{ "RankingMethod", "NumTimeSeries", "Direction" }, null, new[]{ typeof(global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method), typeof(global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter), global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Parser, new[]{ "RankingMethod", "NumTimeSeries" }, null, new[]{ typeof(global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Describes how to combine multiple time series to provide a different view of
  /// the data.  Aggregation of time series is done in two steps. First, each time
  /// series in the set is _aligned_ to the same time interval boundaries, then the
  /// set of time series is optionally _reduced_ in number.
  ///
  /// Alignment consists of applying the `per_series_aligner` operation
  /// to each time series after its data has been divided into regular
  /// `alignment_period` time intervals. This process takes _all_ of the data
  /// points in an alignment period, applies a mathematical transformation such as
  /// averaging, minimum, maximum, delta, etc., and converts them into a single
  /// data point per period.
  ///
  /// Reduction is when the aligned and transformed time series can optionally be
  /// combined, reducing the number of time series through similar mathematical
  /// transformations. Reduction involves applying a `cross_series_reducer` to
  /// all the time series, optionally sorting the time series into subsets with
  /// `group_by_fields`, and applying the reducer to each subset.
  ///
  /// The raw time series data can contain a huge amount of information from
  /// multiple sources. Alignment and reduction transforms this mass of data into
  /// a more manageable and representative collection of data, for example "the
  /// 95% latency across the average of all tasks in a cluster". This
  /// representative data can be more easily graphed and comprehended, and the
  /// individual time series data is still available for later drilldown. For more
  /// details, see [Filtering and
  /// aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
  /// </summary>
  public sealed partial class Aggregation : pb::IMessage<Aggregation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Aggregation> _parser = new pb::MessageParser<Aggregation>(() => new Aggregation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Aggregation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.Dashboard.V1.CommonReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Aggregation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Aggregation(Aggregation other) : this() {
      alignmentPeriod_ = other.alignmentPeriod_ != null ? other.alignmentPeriod_.Clone() : null;
      perSeriesAligner_ = other.perSeriesAligner_;
      crossSeriesReducer_ = other.crossSeriesReducer_;
      groupByFields_ = other.groupByFields_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Aggregation Clone() {
      return new Aggregation(this);
    }

    /// <summary>Field number for the "alignment_period" field.</summary>
    public const int AlignmentPeriodFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration alignmentPeriod_;
    /// <summary>
    /// The `alignment_period` specifies a time interval, in seconds, that is used
    /// to divide the data in all the
    /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
    /// time. This will be done before the per-series aligner can be applied to
    /// the data.
    ///
    /// The value must be at least 60 seconds. If a per-series aligner other than
    /// `ALIGN_NONE` is specified, this field is required or an error is returned.
    /// If no per-series aligner is specified, or the aligner `ALIGN_NONE` is
    /// specified, then this field is ignored.
    ///
    /// The maximum value of the `alignment_period` is 2 years, or 104 weeks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration AlignmentPeriod {
      get { return alignmentPeriod_; }
      set {
        alignmentPeriod_ = value;
      }
    }

    /// <summary>Field number for the "per_series_aligner" field.</summary>
    public const int PerSeriesAlignerFieldNumber = 2;
    private global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner perSeriesAligner_ = global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner.AlignNone;
    /// <summary>
    /// An `Aligner` describes how to bring the data points in a single
    /// time series into temporal alignment. Except for `ALIGN_NONE`, all
    /// alignments cause all the data points in an `alignment_period` to be
    /// mathematically grouped together, resulting in a single data point for
    /// each `alignment_period` with end timestamp at the end of the period.
    ///
    /// Not all alignment operations may be applied to all time series. The valid
    /// choices depend on the `metric_kind` and `value_type` of the original time
    /// series. Alignment can change the `metric_kind` or the `value_type` of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `cross_series_reducer` is specified, then
    /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
    /// and `alignment_period` must be specified; otherwise, an error is
    /// returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner PerSeriesAligner {
      get { return perSeriesAligner_; }
      set {
        perSeriesAligner_ = value;
      }
    }

    /// <summary>Field number for the "cross_series_reducer" field.</summary>
    public const int CrossSeriesReducerFieldNumber = 4;
    private global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer crossSeriesReducer_ = global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer.ReduceNone;
    /// <summary>
    /// The reduction operation to be used to combine time series into a single
    /// time series, where the value of each data point in the resulting series is
    /// a function of all the already aligned values in the input time series.
    ///
    /// Not all reducer operations can be applied to all time series. The valid
    /// choices depend on the `metric_kind` and the `value_type` of the original
    /// time series. Reduction can yield a time series with a different
    /// `metric_kind` or `value_type` than the input time series.
    ///
    /// Time series data must first be aligned (see `per_series_aligner`) in order
    /// to perform cross-time series reduction. If `cross_series_reducer` is
    /// specified, then `per_series_aligner` must be specified, and must not be
    /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
    /// error is returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer CrossSeriesReducer {
      get { return crossSeriesReducer_; }
      set {
        crossSeriesReducer_ = value;
      }
    }

    /// <summary>Field number for the "group_by_fields" field.</summary>
    public const int GroupByFieldsFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_groupByFields_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> groupByFields_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The set of fields to preserve when `cross_series_reducer` is
    /// specified. The `group_by_fields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// operation. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `cross_series_reducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `group_by_fields` are aggregated away.  If
    /// `group_by_fields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `cross_series_reducer` is not
    /// defined, this field is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> GroupByFields {
      get { return groupByFields_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Aggregation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Aggregation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AlignmentPeriod, other.AlignmentPeriod)) return false;
      if (PerSeriesAligner != other.PerSeriesAligner) return false;
      if (CrossSeriesReducer != other.CrossSeriesReducer) return false;
      if(!groupByFields_.Equals(other.groupByFields_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (alignmentPeriod_ != null) hash ^= AlignmentPeriod.GetHashCode();
      if (PerSeriesAligner != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner.AlignNone) hash ^= PerSeriesAligner.GetHashCode();
      if (CrossSeriesReducer != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer.ReduceNone) hash ^= CrossSeriesReducer.GetHashCode();
      hash ^= groupByFields_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (alignmentPeriod_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AlignmentPeriod);
      }
      if (PerSeriesAligner != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner.AlignNone) {
        output.WriteRawTag(16);
        output.WriteEnum((int) PerSeriesAligner);
      }
      if (CrossSeriesReducer != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer.ReduceNone) {
        output.WriteRawTag(32);
        output.WriteEnum((int) CrossSeriesReducer);
      }
      groupByFields_.WriteTo(output, _repeated_groupByFields_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (alignmentPeriod_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AlignmentPeriod);
      }
      if (PerSeriesAligner != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner.AlignNone) {
        output.WriteRawTag(16);
        output.WriteEnum((int) PerSeriesAligner);
      }
      if (CrossSeriesReducer != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer.ReduceNone) {
        output.WriteRawTag(32);
        output.WriteEnum((int) CrossSeriesReducer);
      }
      groupByFields_.WriteTo(ref output, _repeated_groupByFields_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (alignmentPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AlignmentPeriod);
      }
      if (PerSeriesAligner != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner.AlignNone) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PerSeriesAligner);
      }
      if (CrossSeriesReducer != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer.ReduceNone) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CrossSeriesReducer);
      }
      size += groupByFields_.CalculateSize(_repeated_groupByFields_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Aggregation other) {
      if (other == null) {
        return;
      }
      if (other.alignmentPeriod_ != null) {
        if (alignmentPeriod_ == null) {
          AlignmentPeriod = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        AlignmentPeriod.MergeFrom(other.AlignmentPeriod);
      }
      if (other.PerSeriesAligner != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner.AlignNone) {
        PerSeriesAligner = other.PerSeriesAligner;
      }
      if (other.CrossSeriesReducer != global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer.ReduceNone) {
        CrossSeriesReducer = other.CrossSeriesReducer;
      }
      groupByFields_.Add(other.groupByFields_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (alignmentPeriod_ == null) {
              AlignmentPeriod = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(AlignmentPeriod);
            break;
          }
          case 16: {
            PerSeriesAligner = (global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner) input.ReadEnum();
            break;
          }
          case 32: {
            CrossSeriesReducer = (global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer) input.ReadEnum();
            break;
          }
          case 42: {
            groupByFields_.AddEntriesFrom(input, _repeated_groupByFields_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (alignmentPeriod_ == null) {
              AlignmentPeriod = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(AlignmentPeriod);
            break;
          }
          case 16: {
            PerSeriesAligner = (global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Aligner) input.ReadEnum();
            break;
          }
          case 32: {
            CrossSeriesReducer = (global::Google.Cloud.Monitoring.Dashboard.V1.Aggregation.Types.Reducer) input.ReadEnum();
            break;
          }
          case 42: {
            groupByFields_.AddEntriesFrom(ref input, _repeated_groupByFields_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Aggregation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The `Aligner` specifies the operation that will be applied to the data
      /// points in each alignment period in a time series. Except for
      /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
      /// operation replaces the set of data values in each alignment period with
      /// a single value: the result of applying the operation to the data values.
      /// An aligned time series has a single data value at the end of each
      /// `alignment_period`.
      ///
      /// An alignment operation can change the data type of the values, too. For
      /// example, if you apply a counting operation to boolean values, the data
      /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
      /// in the aligned result is `INT64`.
      /// </summary>
      public enum Aligner {
        /// <summary>
        /// No alignment. Raw data is returned. Not valid if cross-series reduction
        /// is requested. The `value_type` of the result is the same as the
        /// `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_NONE")] AlignNone = 0,
        /// <summary>
        /// Align and convert to
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
        /// The output is `delta = y1 - y0`.
        ///
        /// This alignment is valid for
        /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
        /// `DELTA` metrics. If the selected alignment period results in periods
        /// with no data, then the aligned value for such a period is created by
        /// interpolation. The `value_type`  of the aligned result is the same as
        /// the `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_DELTA")] AlignDelta = 1,
        /// <summary>
        /// Align and convert to a rate. The result is computed as
        /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
        /// Think of this aligner as providing the slope of the line that passes
        /// through the value at the start and at the end of the `alignment_period`.
        ///
        /// This aligner is valid for `CUMULATIVE`
        /// and `DELTA` metrics with numeric values. If the selected alignment
        /// period results in periods with no data, then the aligned value for
        /// such a period is created by interpolation. The output is a `GAUGE`
        /// metric with `value_type` `DOUBLE`.
        ///
        /// If, by "rate", you mean "percentage change", see the
        /// `ALIGN_PERCENT_CHANGE` aligner instead.
        /// </summary>
        [pbr::OriginalName("ALIGN_RATE")] AlignRate = 2,
        /// <summary>
        /// Align by interpolating between adjacent points around the alignment
        /// period boundary. This aligner is valid for `GAUGE` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as the
        /// `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_INTERPOLATE")] AlignInterpolate = 3,
        /// <summary>
        /// Align by moving the most recent data point before the end of the
        /// alignment period to the boundary at the end of the alignment
        /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
        /// the aligned result is the same as the `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_NEXT_OLDER")] AlignNextOlder = 4,
        /// <summary>
        /// Align the time series by returning the minimum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_MIN")] AlignMin = 10,
        /// <summary>
        /// Align the time series by returning the maximum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_MAX")] AlignMax = 11,
        /// <summary>
        /// Align the time series by returning the mean value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_MEAN")] AlignMean = 12,
        /// <summary>
        /// Align the time series by returning the number of values in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric or Boolean values. The `value_type` of the aligned result is
        /// `INT64`.
        /// </summary>
        [pbr::OriginalName("ALIGN_COUNT")] AlignCount = 13,
        /// <summary>
        /// Align the time series by returning the sum of the values in each
        /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with numeric and distribution values. The `value_type` of the
        /// aligned result is the same as the `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_SUM")] AlignSum = 14,
        /// <summary>
        /// Align the time series by returning the standard deviation of the values
        /// in each alignment period. This aligner is valid for `GAUGE` and
        /// `DELTA` metrics with numeric values. The `value_type` of the output is
        /// `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_STDDEV")] AlignStddev = 15,
        /// <summary>
        /// Align the time series by returning the number of `True` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        /// </summary>
        [pbr::OriginalName("ALIGN_COUNT_TRUE")] AlignCountTrue = 16,
        /// <summary>
        /// Align the time series by returning the number of `False` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        /// </summary>
        [pbr::OriginalName("ALIGN_COUNT_FALSE")] AlignCountFalse = 24,
        /// <summary>
        /// Align the time series by returning the ratio of the number of `True`
        /// values to the total number of values in each alignment period. This
        /// aligner is valid for `GAUGE` metrics with Boolean values. The output
        /// value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_FRACTION_TRUE")] AlignFractionTrue = 17,
        /// <summary>
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 99th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_99")] AlignPercentile99 = 18,
        /// <summary>
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 95th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_95")] AlignPercentile95 = 19,
        /// <summary>
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 50th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_50")] AlignPercentile50 = 20,
        /// <summary>
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 5th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_05")] AlignPercentile05 = 21,
        /// <summary>
        /// Align and convert to a percentage change. This aligner is valid for
        /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
        /// `((current - previous)/previous) * 100`, where the value of `previous` is
        /// determined based on the `alignment_period`.
        ///
        /// If the values of `current` and `previous` are both 0, then the returned
        /// value is 0. If only `previous` is 0, the returned value is infinity.
        ///
        /// A 10-minute moving mean is computed at each point of the alignment period
        /// prior to the above calculation to smooth the metric and prevent false
        /// positives from very short-lived spikes. The moving mean is only
        /// applicable for data whose values are `>= 0`. Any values `&lt; 0` are
        /// treated as a missing datapoint, and are ignored. While `DELTA`
        /// metrics are accepted by this alignment, special care should be taken that
        /// the values for the metric will always be positive. The output is a
        /// `GAUGE` metric with `value_type` `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENT_CHANGE")] AlignPercentChange = 23,
      }

      /// <summary>
      /// A Reducer operation describes how to aggregate data points from multiple
      /// time series into a single time series, where the value of each data point
      /// in the resulting series is a function of all the already aligned values in
      /// the input time series.
      /// </summary>
      public enum Reducer {
        /// <summary>
        /// No cross-time series reduction. The output of the `Aligner` is
        /// returned.
        /// </summary>
        [pbr::OriginalName("REDUCE_NONE")] ReduceNone = 0,
        /// <summary>
        /// Reduce by computing the mean value across time series for each
        /// alignment period. This reducer is valid for
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
        /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
        /// numeric or distribution values. The `value_type` of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("REDUCE_MEAN")] ReduceMean = 1,
        /// <summary>
        /// Reduce by computing the minimum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("REDUCE_MIN")] ReduceMin = 2,
        /// <summary>
        /// Reduce by computing the maximum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("REDUCE_MAX")] ReduceMax = 3,
        /// <summary>
        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric and distribution values. The `value_type` of the output is
        /// the same as the `value_type` of the input.
        /// </summary>
        [pbr::OriginalName("REDUCE_SUM")] ReduceSum = 4,
        /// <summary>
        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics with numeric or distribution values. The `value_type`
        /// of the output is `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("REDUCE_STDDEV")] ReduceStddev = 5,
        /// <summary>
        /// Reduce by computing the number of data points across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of numeric, Boolean, distribution, and string
        /// `value_type`. The `value_type` of the output is `INT64`.
        /// </summary>
        [pbr::OriginalName("REDUCE_COUNT")] ReduceCount = 6,
        /// <summary>
        /// Reduce by computing the number of `True`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        /// </summary>
        [pbr::OriginalName("REDUCE_COUNT_TRUE")] ReduceCountTrue = 7,
        /// <summary>
        /// Reduce by computing the number of `False`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        /// </summary>
        [pbr::OriginalName("REDUCE_COUNT_FALSE")] ReduceCountFalse = 15,
        /// <summary>
        /// Reduce by computing the ratio of the number of `True`-valued data points
        /// to the total number of data points for each alignment period. This
        /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
        /// The output value is in the range [0.0, 1.0] and has `value_type`
        /// `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("REDUCE_FRACTION_TRUE")] ReduceFractionTrue = 8,
        /// <summary>
        /// Reduce by computing the [99th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_99")] ReducePercentile99 = 9,
        /// <summary>
        /// Reduce by computing the [95th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_95")] ReducePercentile95 = 10,
        /// <summary>
        /// Reduce by computing the [50th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_50")] ReducePercentile50 = 11,
        /// <summary>
        /// Reduce by computing the [5th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_05")] ReducePercentile05 = 12,
      }

    }
    #endregion

  }

  /// <summary>
  /// Describes a ranking-based time series filter. Each input time series is
  /// ranked with an aligner. The filter will allow up to `num_time_series` time
  /// series to pass through it, selecting them based on the relative ranking.
  ///
  /// For example, if `ranking_method` is `METHOD_MEAN`,`direction` is `BOTTOM`,
  /// and `num_time_series` is 3, then the 3 times series with the lowest mean
  /// values will pass through the filter.
  /// </summary>
  public sealed partial class PickTimeSeriesFilter : pb::IMessage<PickTimeSeriesFilter>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PickTimeSeriesFilter> _parser = new pb::MessageParser<PickTimeSeriesFilter>(() => new PickTimeSeriesFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PickTimeSeriesFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.Dashboard.V1.CommonReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickTimeSeriesFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickTimeSeriesFilter(PickTimeSeriesFilter other) : this() {
      rankingMethod_ = other.rankingMethod_;
      numTimeSeries_ = other.numTimeSeries_;
      direction_ = other.direction_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickTimeSeriesFilter Clone() {
      return new PickTimeSeriesFilter(this);
    }

    /// <summary>Field number for the "ranking_method" field.</summary>
    public const int RankingMethodFieldNumber = 1;
    private global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method rankingMethod_ = global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method.Unspecified;
    /// <summary>
    /// `ranking_method` is applied to each time series independently to produce
    /// the value which will be used to compare the time series to other time
    /// series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method RankingMethod {
      get { return rankingMethod_; }
      set {
        rankingMethod_ = value;
      }
    }

    /// <summary>Field number for the "num_time_series" field.</summary>
    public const int NumTimeSeriesFieldNumber = 2;
    private int numTimeSeries_;
    /// <summary>
    /// How many time series to allow to pass through the filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumTimeSeries {
      get { return numTimeSeries_; }
      set {
        numTimeSeries_ = value;
      }
    }

    /// <summary>Field number for the "direction" field.</summary>
    public const int DirectionFieldNumber = 3;
    private global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction direction_ = global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction.Unspecified;
    /// <summary>
    /// How to use the ranking to select time series that pass through the filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction Direction {
      get { return direction_; }
      set {
        direction_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PickTimeSeriesFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PickTimeSeriesFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RankingMethod != other.RankingMethod) return false;
      if (NumTimeSeries != other.NumTimeSeries) return false;
      if (Direction != other.Direction) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method.Unspecified) hash ^= RankingMethod.GetHashCode();
      if (NumTimeSeries != 0) hash ^= NumTimeSeries.GetHashCode();
      if (Direction != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction.Unspecified) hash ^= Direction.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumTimeSeries);
      }
      if (Direction != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Direction);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumTimeSeries);
      }
      if (Direction != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Direction);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumTimeSeries);
      }
      if (Direction != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Direction);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PickTimeSeriesFilter other) {
      if (other == null) {
        return;
      }
      if (other.RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method.Unspecified) {
        RankingMethod = other.RankingMethod;
      }
      if (other.NumTimeSeries != 0) {
        NumTimeSeries = other.NumTimeSeries;
      }
      if (other.Direction != global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction.Unspecified) {
        Direction = other.Direction;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RankingMethod = (global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method) input.ReadEnum();
            break;
          }
          case 16: {
            NumTimeSeries = input.ReadInt32();
            break;
          }
          case 24: {
            Direction = (global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            RankingMethod = (global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Method) input.ReadEnum();
            break;
          }
          case 16: {
            NumTimeSeries = input.ReadInt32();
            break;
          }
          case 24: {
            Direction = (global::Google.Cloud.Monitoring.Dashboard.V1.PickTimeSeriesFilter.Types.Direction) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the PickTimeSeriesFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The value reducers that can be applied to a `PickTimeSeriesFilter`.
      /// </summary>
      public enum Method {
        /// <summary>
        /// Not allowed. You must specify a different `Method` if you specify a
        /// `PickTimeSeriesFilter`.
        /// </summary>
        [pbr::OriginalName("METHOD_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Select the mean of all values.
        /// </summary>
        [pbr::OriginalName("METHOD_MEAN")] Mean = 1,
        /// <summary>
        /// Select the maximum value.
        /// </summary>
        [pbr::OriginalName("METHOD_MAX")] Max = 2,
        /// <summary>
        /// Select the minimum value.
        /// </summary>
        [pbr::OriginalName("METHOD_MIN")] Min = 3,
        /// <summary>
        /// Compute the sum of all values.
        /// </summary>
        [pbr::OriginalName("METHOD_SUM")] Sum = 4,
        /// <summary>
        /// Select the most recent value.
        /// </summary>
        [pbr::OriginalName("METHOD_LATEST")] Latest = 5,
      }

      /// <summary>
      /// Describes the ranking directions.
      /// </summary>
      public enum Direction {
        /// <summary>
        /// Not allowed. You must specify a different `Direction` if you specify a
        /// `PickTimeSeriesFilter`.
        /// </summary>
        [pbr::OriginalName("DIRECTION_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Pass the highest `num_time_series` ranking inputs.
        /// </summary>
        [pbr::OriginalName("TOP")] Top = 1,
        /// <summary>
        /// Pass the lowest `num_time_series` ranking inputs.
        /// </summary>
        [pbr::OriginalName("BOTTOM")] Bottom = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// A filter that ranks streams based on their statistical relation to other
  /// streams in a request.
  /// Note: This field is deprecated and completely ignored by the API.
  /// </summary>
  public sealed partial class StatisticalTimeSeriesFilter : pb::IMessage<StatisticalTimeSeriesFilter>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StatisticalTimeSeriesFilter> _parser = new pb::MessageParser<StatisticalTimeSeriesFilter>(() => new StatisticalTimeSeriesFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StatisticalTimeSeriesFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.Dashboard.V1.CommonReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StatisticalTimeSeriesFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StatisticalTimeSeriesFilter(StatisticalTimeSeriesFilter other) : this() {
      rankingMethod_ = other.rankingMethod_;
      numTimeSeries_ = other.numTimeSeries_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StatisticalTimeSeriesFilter Clone() {
      return new StatisticalTimeSeriesFilter(this);
    }

    /// <summary>Field number for the "ranking_method" field.</summary>
    public const int RankingMethodFieldNumber = 1;
    private global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method rankingMethod_ = global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method.Unspecified;
    /// <summary>
    /// `rankingMethod` is applied to a set of time series, and then the produced
    /// value for each individual time series is used to compare a given time
    /// series to others.
    /// These are methods that cannot be applied stream-by-stream, but rather
    /// require the full context of a request to evaluate time series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method RankingMethod {
      get { return rankingMethod_; }
      set {
        rankingMethod_ = value;
      }
    }

    /// <summary>Field number for the "num_time_series" field.</summary>
    public const int NumTimeSeriesFieldNumber = 2;
    private int numTimeSeries_;
    /// <summary>
    /// How many time series to output.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumTimeSeries {
      get { return numTimeSeries_; }
      set {
        numTimeSeries_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StatisticalTimeSeriesFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StatisticalTimeSeriesFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RankingMethod != other.RankingMethod) return false;
      if (NumTimeSeries != other.NumTimeSeries) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method.Unspecified) hash ^= RankingMethod.GetHashCode();
      if (NumTimeSeries != 0) hash ^= NumTimeSeries.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumTimeSeries);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumTimeSeries);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumTimeSeries);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StatisticalTimeSeriesFilter other) {
      if (other == null) {
        return;
      }
      if (other.RankingMethod != global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method.Unspecified) {
        RankingMethod = other.RankingMethod;
      }
      if (other.NumTimeSeries != 0) {
        NumTimeSeries = other.NumTimeSeries;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RankingMethod = (global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method) input.ReadEnum();
            break;
          }
          case 16: {
            NumTimeSeries = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            RankingMethod = (global::Google.Cloud.Monitoring.Dashboard.V1.StatisticalTimeSeriesFilter.Types.Method) input.ReadEnum();
            break;
          }
          case 16: {
            NumTimeSeries = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StatisticalTimeSeriesFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The filter methods that can be applied to a stream.
      /// </summary>
      public enum Method {
        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        [pbr::OriginalName("METHOD_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Compute the outlier score of each stream.
        /// </summary>
        [pbr::OriginalName("METHOD_CLUSTER_OUTLIER")] ClusterOutlier = 1,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
