// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/devtools/remoteworkers/v1test2/worker.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.DevTools.RemoteWorkers.V1Test2 {

  /// <summary>Holder for reflection information generated from google/devtools/remoteworkers/v1test2/worker.proto</summary>
  public static partial class WorkerReflection {

    #region Descriptor
    /// <summary>File descriptor for google/devtools/remoteworkers/v1test2/worker.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static WorkerReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjJnb29nbGUvZGV2dG9vbHMvcmVtb3Rld29ya2Vycy92MXRlc3QyL3dvcmtl",
            "ci5wcm90bxIlZ29vZ2xlLmRldnRvb2xzLnJlbW90ZXdvcmtlcnMudjF0ZXN0",
            "MiKpAgoGV29ya2VyEj4KB2RldmljZXMYASADKAsyLS5nb29nbGUuZGV2dG9v",
            "bHMucmVtb3Rld29ya2Vycy52MXRlc3QyLkRldmljZRJKCgpwcm9wZXJ0aWVz",
            "GAIgAygLMjYuZ29vZ2xlLmRldnRvb2xzLnJlbW90ZXdvcmtlcnMudjF0ZXN0",
            "Mi5Xb3JrZXIuUHJvcGVydHkSRQoHY29uZmlncxgDIAMoCzI0Lmdvb2dsZS5k",
            "ZXZ0b29scy5yZW1vdGV3b3JrZXJzLnYxdGVzdDIuV29ya2VyLkNvbmZpZxom",
            "CghQcm9wZXJ0eRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAkaJAoGQ29u",
            "ZmlnEgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCSKMAQoGRGV2aWNlEg4K",
            "BmhhbmRsZRgBIAEoCRJKCgpwcm9wZXJ0aWVzGAIgAygLMjYuZ29vZ2xlLmRl",
            "dnRvb2xzLnJlbW90ZXdvcmtlcnMudjF0ZXN0Mi5EZXZpY2UuUHJvcGVydHka",
            "JgoIUHJvcGVydHkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJQugBCilj",
            "b20uZ29vZ2xlLmRldnRvb2xzLnJlbW90ZXdvcmtlcnMudjF0ZXN0MkITUmVt",
            "b3RlV29ya2Vyc1dvcmtlclABWlJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90",
            "by9nb29nbGVhcGlzL2RldnRvb2xzL3JlbW90ZXdvcmtlcnMvdjF0ZXN0Mjty",
            "ZW1vdGV3b3JrZXJzogICUleqAiVHb29nbGUuRGV2VG9vbHMuUmVtb3RlV29y",
            "a2Vycy5WMVRlc3QyygIiR29vZ2xlXENsb3VkXFJlbW90ZXdvcmtlcnNcVjF0",
            "ZXN0MmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.DevTools.RemoteWorkers.V1Test2.Worker), global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Parser, new[]{ "Devices", "Properties", "Configs" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Property), global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Property.Parser, new[]{ "Key", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Config), global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Config.Parser, new[]{ "Key", "Value" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.DevTools.RemoteWorkers.V1Test2.Device), global::Google.DevTools.RemoteWorkers.V1Test2.Device.Parser, new[]{ "Handle", "Properties" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.DevTools.RemoteWorkers.V1Test2.Device.Types.Property), global::Google.DevTools.RemoteWorkers.V1Test2.Device.Types.Property.Parser, new[]{ "Key", "Value" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Describes a worker, which is a list of one or more devices and the
  /// connections between them. A device could be a computer, a phone, or even an
  /// accelerator like a GPU; it's up to the farm administrator to decide how to
  /// model their farm. For example, if a farm only has one type of GPU, the GPU
  /// could be modelled as a "has_gpu" property on its host computer; if it has
  /// many subproperties itself, it might be better to model it as a separate
  /// device.
  ///
  /// The first device in the worker is the "primary device" - that is, the device
  /// running a bot and which is responsible for actually executing commands. All
  /// other devices are considered to be attached devices, and must be controllable
  /// by the primary device.
  ///
  /// This message (and all its submessages) can be used in two contexts:
  ///
  /// * Status: sent by the bot to report the current capabilities of the device to
  /// allow reservation matching.
  /// * Request: sent by a client to request a device with certain capabilities in
  /// a reservation.
  ///
  /// Several of the fields in this message have different semantics depending on
  /// which of which of these contexts it is used. These semantics are described
  /// below.
  ///
  /// Several messages in Worker and its submessages have the concept of keys and
  /// values, such as `Worker.Property` and `Device.Property`. All keys are simple
  /// strings, but certain keys are "standard" keys and should be broadly supported
  /// across farms and implementations; these are listed below each relevant
  /// message. Bot implementations or farm admins may add *additional* keys, but
  /// these SHOULD all begin with an underscore so they do not conflict with
  /// standard keys that may be added in the future.
  ///
  /// Keys are not context sensitive.
  ///
  /// See http://goo.gl/NurY8g for more information on the Worker message.
  /// </summary>
  public sealed partial class Worker : pb::IMessage<Worker>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Worker> _parser = new pb::MessageParser<Worker>(() => new Worker());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Worker> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.DevTools.RemoteWorkers.V1Test2.WorkerReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Worker() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Worker(Worker other) : this() {
      devices_ = other.devices_.Clone();
      properties_ = other.properties_.Clone();
      configs_ = other.configs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Worker Clone() {
      return new Worker(this);
    }

    /// <summary>Field number for the "devices" field.</summary>
    public const int DevicesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.DevTools.RemoteWorkers.V1Test2.Device> _repeated_devices_codec
        = pb::FieldCodec.ForMessage(10, global::Google.DevTools.RemoteWorkers.V1Test2.Device.Parser);
    private readonly pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Device> devices_ = new pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Device>();
    /// <summary>
    /// A list of devices; the first device is the primary device. See the `Device`
    /// message for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Device> Devices {
      get { return devices_; }
    }

    /// <summary>Field number for the "properties" field.</summary>
    public const int PropertiesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Property> _repeated_properties_codec
        = pb::FieldCodec.ForMessage(18, global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Property.Parser);
    private readonly pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Property> properties_ = new pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Property>();
    /// <summary>
    /// A worker may contain "global" properties. For example, certain machines
    /// might be reserved for certain types of jobs, like short-running compilation
    /// versus long-running integration tests. This property is known as a "pool"
    /// and is not related to any one device within the worker; rather, it applies
    /// to the worker as a whole.
    ///
    /// The behaviour of repeated keys is identical to that of Device.Property.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Property> Properties {
      get { return properties_; }
    }

    /// <summary>Field number for the "configs" field.</summary>
    public const int ConfigsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Config> _repeated_configs_codec
        = pb::FieldCodec.ForMessage(26, global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Config.Parser);
    private readonly pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Config> configs_ = new pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Config>();
    /// <summary>
    /// Bots can be configured in certain ways when accepting leases. For example,
    /// many leases are executed inside a Docker container. To support this, the
    /// bot needs to be able to report that it has Docker installed (and knows how
    /// to execute something inside a container), and the task submitter needs to
    /// specify which image should be used to start the container. Similarly, a
    /// lease may be able to run as one of several users on the worker; in such
    /// cases, the bot needs to report what users are available, and the submitter
    /// needs to choose one.
    ///
    /// Therefore, when this message is reported by the bot to the service, each
    /// key represents a *type* of configuration that the bot knows how to set,
    /// while each *value* represents a legal value for that configuration (the
    /// empty string is interpretted as a wildcard, such as for Docker images).
    /// When this message is sent by the server to the bot in the context of a
    /// lease, it represents a command to the bot to apply the setting. Keys may
    /// be repeated during reporting but not in a lease.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Types.Config> Configs {
      get { return configs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Worker);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Worker other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!devices_.Equals(other.devices_)) return false;
      if(!properties_.Equals(other.properties_)) return false;
      if(!configs_.Equals(other.configs_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= devices_.GetHashCode();
      hash ^= properties_.GetHashCode();
      hash ^= configs_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      devices_.WriteTo(output, _repeated_devices_codec);
      properties_.WriteTo(output, _repeated_properties_codec);
      configs_.WriteTo(output, _repeated_configs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      devices_.WriteTo(ref output, _repeated_devices_codec);
      properties_.WriteTo(ref output, _repeated_properties_codec);
      configs_.WriteTo(ref output, _repeated_configs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += devices_.CalculateSize(_repeated_devices_codec);
      size += properties_.CalculateSize(_repeated_properties_codec);
      size += configs_.CalculateSize(_repeated_configs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Worker other) {
      if (other == null) {
        return;
      }
      devices_.Add(other.devices_);
      properties_.Add(other.properties_);
      configs_.Add(other.configs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            devices_.AddEntriesFrom(input, _repeated_devices_codec);
            break;
          }
          case 18: {
            properties_.AddEntriesFrom(input, _repeated_properties_codec);
            break;
          }
          case 26: {
            configs_.AddEntriesFrom(input, _repeated_configs_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            devices_.AddEntriesFrom(ref input, _repeated_devices_codec);
            break;
          }
          case 18: {
            properties_.AddEntriesFrom(ref input, _repeated_properties_codec);
            break;
          }
          case 26: {
            configs_.AddEntriesFrom(ref input, _repeated_configs_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Worker message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// A global property; see the `properties` field for more information.
      /// </summary>
      public sealed partial class Property : pb::IMessage<Property>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Property> _parser = new pb::MessageParser<Property>(() => new Property());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Property> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Property() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Property(Property other) : this() {
          key_ = other.key_;
          value_ = other.value_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Property Clone() {
          return new Property(this);
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 1;
        private string key_ = "";
        /// <summary>
        /// For general information on keys, see the documentation to `Worker`.
        ///
        /// The current set of standard keys are:
        ///
        /// * pool: different workers can be reserved for different purposes. For
        /// example, an admin might want to segregate long-running integration tests
        /// from short-running unit tests, so unit tests will always get some
        /// throughput. To support this, the server can assign different values for
        /// `pool` (such as "itest" and "utest") to different workers, and then have
        /// jobs request workers from those pools.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Key {
          get { return key_; }
          set {
            key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private string value_ = "";
        /// <summary>
        /// The property's value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Value {
          get { return value_; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Property);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Property other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Key != other.Key) return false;
          if (Value != other.Value) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Key.Length != 0) hash ^= Key.GetHashCode();
          if (Value.Length != 0) hash ^= Value.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Key.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Key.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Key.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
          }
          if (Value.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Property other) {
          if (other == null) {
            return;
          }
          if (other.Key.Length != 0) {
            Key = other.Key;
          }
          if (other.Value.Length != 0) {
            Value = other.Value;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A configuration request or report; see the `configs` field for more
      /// information.
      /// </summary>
      public sealed partial class Config : pb::IMessage<Config>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Config> _parser = new pb::MessageParser<Config>(() => new Config());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Config> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.DevTools.RemoteWorkers.V1Test2.Worker.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Config() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Config(Config other) : this() {
          key_ = other.key_;
          value_ = other.value_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Config Clone() {
          return new Config(this);
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 1;
        private string key_ = "";
        /// <summary>
        /// For general information on keys, see the documentation to `Worker`.
        ///
        /// The current set of standard keys are:
        ///
        /// * DockerImage: the image of the container. When being reported by the
        /// bot, the empty value should always be included if the bot is able to pull
        /// its own images; the bot may optionally *also* report images that are
        /// present in its cache. When being requested in a lease, the value is the
        /// URI of the image (eg `gcr.io/user/image@sha256:hash`).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Key {
          get { return key_; }
          set {
            key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private string value_ = "";
        /// <summary>
        /// The configuration's value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Value {
          get { return value_; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Config);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Config other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Key != other.Key) return false;
          if (Value != other.Value) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Key.Length != 0) hash ^= Key.GetHashCode();
          if (Value.Length != 0) hash ^= Value.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Key.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Key.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Key.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
          }
          if (Value.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Config other) {
          if (other == null) {
            return;
          }
          if (other.Key.Length != 0) {
            Key = other.Key;
          }
          if (other.Value.Length != 0) {
            Value = other.Value;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Any device, including computers, phones, accelerators (e.g. GPUs), etc. All
  /// names must be unique.
  /// </summary>
  public sealed partial class Device : pb::IMessage<Device>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Device> _parser = new pb::MessageParser<Device>(() => new Device());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Device> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.DevTools.RemoteWorkers.V1Test2.WorkerReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Device() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Device(Device other) : this() {
      handle_ = other.handle_;
      properties_ = other.properties_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Device Clone() {
      return new Device(this);
    }

    /// <summary>Field number for the "handle" field.</summary>
    public const int HandleFieldNumber = 1;
    private string handle_ = "";
    /// <summary>
    /// The handle can be thought of as the "name" of the device, and must be
    /// unique within a Worker.
    ///
    /// In the Status context, the handle should be some human-understandable name,
    /// perhaps corresponding to a label physically written on the device to make
    /// it easy to locate. In the Request context, the name should be the
    /// *logical* name expected by the task. The bot is responsible for mapping the
    /// logical name expected by the task to a machine-readable name that the task
    /// can actually use, such as a USB address. The method by which this mapping
    /// is communicated to the task is not covered in this API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Handle {
      get { return handle_; }
      set {
        handle_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "properties" field.</summary>
    public const int PropertiesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.DevTools.RemoteWorkers.V1Test2.Device.Types.Property> _repeated_properties_codec
        = pb::FieldCodec.ForMessage(18, global::Google.DevTools.RemoteWorkers.V1Test2.Device.Types.Property.Parser);
    private readonly pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Device.Types.Property> properties_ = new pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Device.Types.Property>();
    /// <summary>
    /// Properties of this device that don't change based on the tasks that are
    /// running on it, e.g. OS, CPU architecture, etc.
    ///
    /// Keys may be repeated, and have the following interpretation:
    ///
    ///    * Status context: the device can support *any* the listed values. For
    ///    example, an "ISA" property might include "x86", "x86-64" and "sse4".
    ///
    ///    * Request context: the device *must* support *all* of the listed values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.DevTools.RemoteWorkers.V1Test2.Device.Types.Property> Properties {
      get { return properties_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Device);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Device other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Handle != other.Handle) return false;
      if(!properties_.Equals(other.properties_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Handle.Length != 0) hash ^= Handle.GetHashCode();
      hash ^= properties_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Handle.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Handle);
      }
      properties_.WriteTo(output, _repeated_properties_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Handle.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Handle);
      }
      properties_.WriteTo(ref output, _repeated_properties_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Handle.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Handle);
      }
      size += properties_.CalculateSize(_repeated_properties_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Device other) {
      if (other == null) {
        return;
      }
      if (other.Handle.Length != 0) {
        Handle = other.Handle;
      }
      properties_.Add(other.properties_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Handle = input.ReadString();
            break;
          }
          case 18: {
            properties_.AddEntriesFrom(input, _repeated_properties_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Handle = input.ReadString();
            break;
          }
          case 18: {
            properties_.AddEntriesFrom(ref input, _repeated_properties_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Device message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// A device property; see `properties` for more information.
      /// </summary>
      public sealed partial class Property : pb::IMessage<Property>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Property> _parser = new pb::MessageParser<Property>(() => new Property());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Property> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.DevTools.RemoteWorkers.V1Test2.Device.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Property() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Property(Property other) : this() {
          key_ = other.key_;
          value_ = other.value_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Property Clone() {
          return new Property(this);
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 1;
        private string key_ = "";
        /// <summary>
        /// For general information on keys, see the documentation to `Worker`.
        ///
        /// The current set of standard keys are:
        ///
        /// * os: a human-readable description of the OS. Examples include `linux`,
        /// `ubuntu` and `ubuntu 14.04` (note that a bot may advertise itself as more
        /// than one). This will be replaced in the future by more well-structured
        /// keys and values to represent OS variants.
        ///
        /// * has-docker: "true" if the bot has Docker installed. This will be
        /// replaced in the future by a more structured message for Docker support.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Key {
          get { return key_; }
          set {
            key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private string value_ = "";
        /// <summary>
        /// The property's value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Value {
          get { return value_; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Property);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Property other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Key != other.Key) return false;
          if (Value != other.Value) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Key.Length != 0) hash ^= Key.GetHashCode();
          if (Value.Length != 0) hash ^= Value.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Key.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Key.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Key.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
          }
          if (Value.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Property other) {
          if (other == null) {
            return;
          }
          if (other.Key.Length != 0) {
            Key = other.Key;
          }
          if (other.Value.Length != 0) {
            Value = other.Value;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
